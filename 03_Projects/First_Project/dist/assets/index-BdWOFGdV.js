(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const r of i)
      if (r.type === "childList")
        for (const o of r.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const r = {};
    return (
      i.integrity && (r.integrity = i.integrity),
      i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (r.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (r.credentials = "omit")
        : (r.credentials = "same-origin"),
      r
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const r = t(i);
    fetch(i.href, r);
  }
})();
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const bu = "170",
  Xs = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  zs = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  K_ = 0,
  vf = 1,
  $_ = 2,
  Dp = 1,
  Z_ = 2,
  ji = 3,
  sr = 0,
  Un = 1,
  Ai = 2,
  nr = 0,
  Ys = 1,
  lh = 2,
  xf = 3,
  yf = 4,
  J_ = 5,
  $r = 100,
  Q_ = 101,
  eg = 102,
  tg = 103,
  ng = 104,
  ig = 200,
  rg = 201,
  sg = 202,
  og = 203,
  ch = 204,
  hh = 205,
  ag = 206,
  lg = 207,
  cg = 208,
  hg = 209,
  ug = 210,
  fg = 211,
  dg = 212,
  pg = 213,
  mg = 214,
  uh = 0,
  fh = 1,
  dh = 2,
  no = 3,
  ph = 4,
  mh = 5,
  _h = 6,
  gh = 7,
  Lp = 0,
  _g = 1,
  gg = 2,
  Cr = 0,
  vg = 1,
  xg = 2,
  yg = 3,
  Ip = 4,
  Mg = 5,
  Sg = 6,
  Tg = 7,
  Mf = "attached",
  Eg = "detached",
  Up = 300,
  io = 301,
  ro = 302,
  Il = 303,
  vh = 304,
  Zl = 306,
  so = 1e3,
  Ri = 1001,
  Ul = 1002,
  wn = 1003,
  Np = 1004,
  Bo = 1005,
  tn = 1006,
  gl = 1007,
  Ci = 1008,
  or = 1009,
  Op = 1010,
  Fp = 1011,
  ca = 1012,
  Au = 1013,
  cs = 1014,
  Dn = 1015,
  Kn = 1016,
  wu = 1017,
  Ru = 1018,
  oo = 1020,
  Bp = 35902,
  kp = 1021,
  zp = 1022,
  si = 1023,
  Hp = 1024,
  Vp = 1025,
  qs = 1026,
  ao = 1027,
  Cu = 1028,
  Pu = 1029,
  Gp = 1030,
  Du = 1031,
  Lu = 1033,
  vl = 33776,
  xl = 33777,
  yl = 33778,
  Ml = 33779,
  xh = 35840,
  yh = 35841,
  Mh = 35842,
  Sh = 35843,
  Th = 36196,
  Eh = 37492,
  bh = 37496,
  Ah = 37808,
  wh = 37809,
  Rh = 37810,
  Ch = 37811,
  Ph = 37812,
  Dh = 37813,
  Lh = 37814,
  Ih = 37815,
  Uh = 37816,
  Nh = 37817,
  Oh = 37818,
  Fh = 37819,
  Bh = 37820,
  kh = 37821,
  Sl = 36492,
  zh = 36494,
  Hh = 36495,
  Wp = 36283,
  Vh = 36284,
  Gh = 36285,
  Wh = 36286,
  ha = 2300,
  ua = 2301,
  cc = 2302,
  Sf = 2400,
  Tf = 2401,
  Ef = 2402,
  bg = 2500,
  Ag = 0,
  Xp = 1,
  Xh = 2,
  wg = 3200,
  Rg = 3201,
  Yp = 0,
  Cg = 1,
  Mr = "",
  sn = "srgb",
  pn = "srgb-linear",
  Jl = "linear",
  xt = "srgb",
  ys = 7680,
  bf = 519,
  Pg = 512,
  Dg = 513,
  Lg = 514,
  qp = 515,
  Ig = 516,
  Ug = 517,
  Ng = 518,
  Og = 519,
  Yh = 35044,
  Af = "300 es",
  er = 2e3,
  Nl = 2001;
class ms {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
      e.target = null;
    }
  }
}
const an = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let wf = 1234567;
const jo = Math.PI / 180,
  lo = 180 / Math.PI;
function vi() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    an[s & 255] +
    an[(s >> 8) & 255] +
    an[(s >> 16) & 255] +
    an[(s >> 24) & 255] +
    "-" +
    an[e & 255] +
    an[(e >> 8) & 255] +
    "-" +
    an[((e >> 16) & 15) | 64] +
    an[(e >> 24) & 255] +
    "-" +
    an[(t & 63) | 128] +
    an[(t >> 8) & 255] +
    "-" +
    an[(t >> 16) & 255] +
    an[(t >> 24) & 255] +
    an[n & 255] +
    an[(n >> 8) & 255] +
    an[(n >> 16) & 255] +
    an[(n >> 24) & 255]
  ).toLowerCase();
}
function Qt(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Iu(s, e) {
  return ((s % e) + e) % e;
}
function Fg(s, e, t, n, i) {
  return n + ((s - e) * (i - n)) / (t - e);
}
function Bg(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function Ko(s, e, t) {
  return (1 - t) * s + t * e;
}
function kg(s, e, t, n) {
  return Ko(s, e, 1 - Math.exp(-t * n));
}
function zg(s, e = 1) {
  return e - Math.abs(Iu(s, e * 2) - e);
}
function Hg(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
}
function Vg(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
}
function Gg(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function Wg(s, e) {
  return s + Math.random() * (e - s);
}
function Xg(s) {
  return s * (0.5 - Math.random());
}
function Yg(s) {
  s !== void 0 && (wf = s);
  let e = (wf += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function qg(s) {
  return s * jo;
}
function jg(s) {
  return s * lo;
}
function Kg(s) {
  return (s & (s - 1)) === 0 && s !== 0;
}
function $g(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Zg(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function Jg(s, e, t, n, i) {
  const r = Math.cos,
    o = Math.sin,
    a = r(t / 2),
    l = o(t / 2),
    c = r((e + n) / 2),
    h = o((e + n) / 2),
    u = r((e - n) / 2),
    f = o((e - n) / 2),
    d = r((n - e) / 2),
    _ = o((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(a * h, l * u, l * f, a * c);
      break;
    case "YZY":
      s.set(l * f, a * h, l * u, a * c);
      break;
    case "ZXZ":
      s.set(l * u, l * f, a * h, a * c);
      break;
    case "XZX":
      s.set(a * h, l * _, l * d, a * c);
      break;
    case "YXY":
      s.set(l * d, a * h, l * _, a * c);
      break;
    case "ZYZ":
      s.set(l * _, l * d, a * h, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function _i(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function gt(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const jp = {
  DEG2RAD: jo,
  RAD2DEG: lo,
  generateUUID: vi,
  clamp: Qt,
  euclideanModulo: Iu,
  mapLinear: Fg,
  inverseLerp: Bg,
  lerp: Ko,
  damp: kg,
  pingpong: zg,
  smoothstep: Hg,
  smootherstep: Vg,
  randInt: Gg,
  randFloat: Wg,
  randFloatSpread: Xg,
  seededRandom: Yg,
  degToRad: qg,
  radToDeg: jg,
  isPowerOfTwo: Kg,
  ceilPowerOfTwo: $g,
  floorPowerOfTwo: Zg,
  setQuaternionFromProperEuler: Jg,
  normalize: gt,
  denormalize: _i,
};
class De {
  constructor(e = 0, t = 0) {
    (De.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Qt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = this.x - e.x,
      o = this.y - e.y;
    return (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class $e {
  constructor(e, t, n, i, r, o, a, l, c) {
    ($e.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, r, o, a, l, c);
  }
  set(e, t, n, i, r, o, a, l, c) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = a),
      (h[3] = t),
      (h[4] = r),
      (h[5] = l),
      (h[6] = n),
      (h[7] = o),
      (h[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      o = n[0],
      a = n[3],
      l = n[6],
      c = n[1],
      h = n[4],
      u = n[7],
      f = n[2],
      d = n[5],
      _ = n[8],
      g = i[0],
      m = i[3],
      p = i[6],
      M = i[1],
      S = i[4],
      v = i[7],
      C = i[2],
      w = i[5],
      E = i[8];
    return (
      (r[0] = o * g + a * M + l * C),
      (r[3] = o * m + a * S + l * w),
      (r[6] = o * p + a * v + l * E),
      (r[1] = c * g + h * M + u * C),
      (r[4] = c * m + h * S + u * w),
      (r[7] = c * p + h * v + u * E),
      (r[2] = f * g + d * M + _ * C),
      (r[5] = f * m + d * S + _ * w),
      (r[8] = f * p + d * v + _ * E),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8];
    return (
      t * o * h - t * a * c - n * r * h + n * a * l + i * r * c - i * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      u = h * o - a * c,
      f = a * l - h * r,
      d = c * r - o * l,
      _ = t * u + n * f + i * d;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / _;
    return (
      (e[0] = u * g),
      (e[1] = (i * c - h * n) * g),
      (e[2] = (a * n - i * o) * g),
      (e[3] = f * g),
      (e[4] = (h * t - i * l) * g),
      (e[5] = (i * r - a * t) * g),
      (e[6] = d * g),
      (e[7] = (n * l - c * t) * g),
      (e[8] = (o * t - n * r) * g),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, r, o, a) {
    const l = Math.cos(r),
      c = Math.sin(r);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * o + c * a) + o + e,
        -i * c,
        i * l,
        -i * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(hc.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(hc.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(hc.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const hc = new $e();
function Kp(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return !0;
  return !1;
}
function fa(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function Qg() {
  const s = fa("canvas");
  return (s.style.display = "block"), s;
}
const Rf = {};
function ko(s) {
  s in Rf || ((Rf[s] = !0), console.warn(s));
}
function e0(s, e, t) {
  return new Promise(function (n, i) {
    function r() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          i();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(r, t);
          break;
        default:
          n();
      }
    }
    setTimeout(r, t);
  });
}
function t0(s) {
  const e = s.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function n0(s) {
  const e = s.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const at = {
  enabled: !0,
  workingColorSpace: pn,
  spaces: {},
  convert: function (s, e, t) {
    return (
      this.enabled === !1 ||
        e === t ||
        !e ||
        !t ||
        (this.spaces[e].transfer === xt &&
          ((s.r = ir(s.r)), (s.g = ir(s.g)), (s.b = ir(s.b))),
        this.spaces[e].primaries !== this.spaces[t].primaries &&
          (s.applyMatrix3(this.spaces[e].toXYZ),
          s.applyMatrix3(this.spaces[t].fromXYZ)),
        this.spaces[t].transfer === xt &&
          ((s.r = js(s.r)), (s.g = js(s.g)), (s.b = js(s.b)))),
      s
    );
  },
  fromWorkingColorSpace: function (s, e) {
    return this.convert(s, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function (s, e) {
    return this.convert(s, e, this.workingColorSpace);
  },
  getPrimaries: function (s) {
    return this.spaces[s].primaries;
  },
  getTransfer: function (s) {
    return s === Mr ? Jl : this.spaces[s].transfer;
  },
  getLuminanceCoefficients: function (s, e = this.workingColorSpace) {
    return s.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function (s) {
    Object.assign(this.spaces, s);
  },
  _getMatrix: function (s, e, t) {
    return s.copy(this.spaces[e].toXYZ).multiply(this.spaces[t].fromXYZ);
  },
  _getDrawingBufferColorSpace: function (s) {
    return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function (s = this.workingColorSpace) {
    return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
  },
};
function ir(s) {
  return s < 0.04045
    ? s * 0.0773993808
    : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function js(s) {
  return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
const Cf = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
  Pf = [0.2126, 0.7152, 0.0722],
  Df = [0.3127, 0.329],
  Lf = new $e().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  If = new $e().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
at.define({
  [pn]: {
    primaries: Cf,
    whitePoint: Df,
    transfer: Jl,
    toXYZ: Lf,
    fromXYZ: If,
    luminanceCoefficients: Pf,
    workingColorSpaceConfig: { unpackColorSpace: sn },
    outputColorSpaceConfig: { drawingBufferColorSpace: sn },
  },
  [sn]: {
    primaries: Cf,
    whitePoint: Df,
    transfer: xt,
    toXYZ: Lf,
    fromXYZ: If,
    luminanceCoefficients: Pf,
    outputColorSpaceConfig: { drawingBufferColorSpace: sn },
  },
});
let Ms;
class i0 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Ms === void 0 && (Ms = fa("canvas")),
        (Ms.width = e.width),
        (Ms.height = e.height);
      const n = Ms.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = Ms);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = fa("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        r = i.data;
      for (let o = 0; o < r.length; o++) r[o] = ir(r[o] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(ir(t[n] / 255) * 255))
          : (t[n] = ir(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let r0 = 0;
class $p {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: r0++ }),
      (this.uuid = vi()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? r.push(uc(i[o].image)) : r.push(uc(i[o]));
      } else r = uc(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function uc(s) {
  return (typeof HTMLImageElement < "u" && s instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && s instanceof ImageBitmap)
    ? i0.getDataURL(s)
    : s.data
    ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let s0 = 0;
class nn extends ms {
  constructor(
    e = nn.DEFAULT_IMAGE,
    t = nn.DEFAULT_MAPPING,
    n = Ri,
    i = Ri,
    r = tn,
    o = Ci,
    a = si,
    l = or,
    c = nn.DEFAULT_ANISOTROPY,
    h = Mr
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: s0++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.source = new $p(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = r),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new De(0, 0)),
      (this.repeat = new De(1, 1)),
      (this.center = new De(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new $e()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Up) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case so:
          e.x = e.x - Math.floor(e.x);
          break;
        case Ri:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Ul:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case so:
          e.y = e.y - Math.floor(e.y);
          break;
        case Ri:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Ul:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
nn.DEFAULT_IMAGE = null;
nn.DEFAULT_MAPPING = Up;
nn.DEFAULT_ANISOTROPY = 1;
class ft {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (ft.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
      (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
      (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
      (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const l = e.elements,
      c = l[0],
      h = l[4],
      u = l[8],
      f = l[1],
      d = l[5],
      _ = l[9],
      g = l[2],
      m = l[6],
      p = l[10];
    if (
      Math.abs(h - f) < 0.01 &&
      Math.abs(u - g) < 0.01 &&
      Math.abs(_ - m) < 0.01
    ) {
      if (
        Math.abs(h + f) < 0.1 &&
        Math.abs(u + g) < 0.1 &&
        Math.abs(_ + m) < 0.1 &&
        Math.abs(c + d + p - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const S = (c + 1) / 2,
        v = (d + 1) / 2,
        C = (p + 1) / 2,
        w = (h + f) / 4,
        E = (u + g) / 4,
        A = (_ + m) / 4;
      return (
        S > v && S > C
          ? S < 0.01
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(S)), (i = w / n), (r = E / n))
          : v > C
          ? v < 0.01
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(v)), (n = w / i), (r = A / i))
          : C < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(C)), (n = E / r), (i = A / r)),
        this.set(n, i, r, t),
        this
      );
    }
    let M = Math.sqrt(
      (m - _) * (m - _) + (u - g) * (u - g) + (f - h) * (f - h)
    );
    return (
      Math.abs(M) < 0.001 && (M = 1),
      (this.x = (m - _) / M),
      (this.y = (u - g) / M),
      (this.z = (f - h) / M),
      (this.w = Math.acos((c + d + p - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class o0 extends ms {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new ft(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new ft(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: tn,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      n
    );
    const r = new nn(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace
    );
    (r.flipY = !1),
      (r.generateMipmaps = n.generateMipmaps),
      (r.internalFormat = n.internalFormat),
      (this.textures = []);
    const o = n.count;
    for (let a = 0; a < o; a++)
      (this.textures[a] = r.clone()),
        (this.textures[a].isRenderTargetTexture = !0);
    (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let i = 0, r = this.textures.length; i < r; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = n);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let n = 0, i = e.textures.length; n < i; n++)
      (this.textures[n] = e.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new $p(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class xi extends o0 {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), (this.isWebGLRenderTarget = !0);
  }
}
class Zp extends nn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = wn),
      (this.minFilter = wn),
      (this.wrapR = Ri),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class a0 extends nn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = wn),
      (this.minFilter = wn),
      (this.wrapR = Ri),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Ni {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, r, o, a) {
    let l = n[i + 0],
      c = n[i + 1],
      h = n[i + 2],
      u = n[i + 3];
    const f = r[o + 0],
      d = r[o + 1],
      _ = r[o + 2],
      g = r[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
      return;
    }
    if (a === 1) {
      (e[t + 0] = f), (e[t + 1] = d), (e[t + 2] = _), (e[t + 3] = g);
      return;
    }
    if (u !== g || l !== f || c !== d || h !== _) {
      let m = 1 - a;
      const p = l * f + c * d + h * _ + u * g,
        M = p >= 0 ? 1 : -1,
        S = 1 - p * p;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S),
          w = Math.atan2(C, p * M);
        (m = Math.sin(m * w) / C), (a = Math.sin(a * w) / C);
      }
      const v = a * M;
      if (
        ((l = l * m + f * v),
        (c = c * m + d * v),
        (h = h * m + _ * v),
        (u = u * m + g * v),
        m === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        (l *= C), (c *= C), (h *= C), (u *= C);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, o) {
    const a = n[i],
      l = n[i + 1],
      c = n[i + 2],
      h = n[i + 3],
      u = r[o],
      f = r[o + 1],
      d = r[o + 2],
      _ = r[o + 3];
    return (
      (e[t] = a * _ + h * u + l * d - c * f),
      (e[t + 1] = l * _ + h * f + c * u - a * d),
      (e[t + 2] = c * _ + h * d + a * f - l * u),
      (e[t + 3] = h * _ - a * u - l * f - c * d),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const n = e._x,
      i = e._y,
      r = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(n / 2),
      h = a(i / 2),
      u = a(r / 2),
      f = l(n / 2),
      d = l(i / 2),
      _ = l(r / 2);
    switch (o) {
      case "XYZ":
        (this._x = f * h * u + c * d * _),
          (this._y = c * d * u - f * h * _),
          (this._z = c * h * _ + f * d * u),
          (this._w = c * h * u - f * d * _);
        break;
      case "YXZ":
        (this._x = f * h * u + c * d * _),
          (this._y = c * d * u - f * h * _),
          (this._z = c * h * _ - f * d * u),
          (this._w = c * h * u + f * d * _);
        break;
      case "ZXY":
        (this._x = f * h * u - c * d * _),
          (this._y = c * d * u + f * h * _),
          (this._z = c * h * _ + f * d * u),
          (this._w = c * h * u - f * d * _);
        break;
      case "ZYX":
        (this._x = f * h * u - c * d * _),
          (this._y = c * d * u + f * h * _),
          (this._z = c * h * _ - f * d * u),
          (this._w = c * h * u + f * d * _);
        break;
      case "YZX":
        (this._x = f * h * u + c * d * _),
          (this._y = c * d * u + f * h * _),
          (this._z = c * h * _ - f * d * u),
          (this._w = c * h * u - f * d * _);
        break;
      case "XZY":
        (this._x = f * h * u - c * d * _),
          (this._y = c * d * u - f * h * _),
          (this._z = c * h * _ + f * d * u),
          (this._w = c * h * u + f * d * _);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      r = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      h = t[6],
      u = t[10],
      f = n + a + u;
    if (f > 0) {
      const d = 0.5 / Math.sqrt(f + 1);
      (this._w = 0.25 / d),
        (this._x = (h - l) * d),
        (this._y = (r - c) * d),
        (this._z = (o - i) * d);
    } else if (n > a && n > u) {
      const d = 2 * Math.sqrt(1 + n - a - u);
      (this._w = (h - l) / d),
        (this._x = 0.25 * d),
        (this._y = (i + o) / d),
        (this._z = (r + c) / d);
    } else if (a > u) {
      const d = 2 * Math.sqrt(1 + a - n - u);
      (this._w = (r - c) / d),
        (this._x = (i + o) / d),
        (this._y = 0.25 * d),
        (this._z = (l + h) / d);
    } else {
      const d = 2 * Math.sqrt(1 + u - n - a);
      (this._w = (o - i) / d),
        (this._x = (r + c) / d),
        (this._y = (l + h) / d),
        (this._z = 0.25 * d);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Qt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      r = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      h = t._w;
    return (
      (this._x = n * h + o * a + i * c - r * l),
      (this._y = i * h + o * l + r * a - n * c),
      (this._z = r * h + o * c + n * l - i * a),
      (this._w = o * h - n * a - i * l - r * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      r = this._z,
      o = this._w;
    let a = o * e._w + n * e._x + i * e._y + r * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = n), (this._y = i), (this._z = r), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const d = 1 - t;
      return (
        (this._w = d * o + t * this._w),
        (this._x = d * n + t * this._x),
        (this._y = d * i + t * this._y),
        (this._z = d * r + t * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      h = Math.atan2(c, a),
      u = Math.sin((1 - t) * h) / c,
      f = Math.sin(t * h) / c;
    return (
      (this._w = o * u + this._w * f),
      (this._x = n * u + this._x * f),
      (this._y = i * u + this._y * f),
      (this._z = r * u + this._z * f),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      n = Math.random(),
      i = Math.sqrt(1 - n),
      r = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      r * Math.sin(t),
      r * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class F {
  constructor(e = 0, t = 0, n = 0) {
    (F.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Uf.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Uf.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * n + r[6] * i),
      (this.y = r[1] * t + r[4] * n + r[7] * i),
      (this.z = r[2] * t + r[5] * n + r[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements,
      o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
      (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
      (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * i - a * n),
      h = 2 * (a * t - r * i),
      u = 2 * (r * n - o * t);
    return (
      (this.x = t + l * c + o * u - a * h),
      (this.y = n + l * h + a * c - r * u),
      (this.z = i + l * u + r * h - o * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[4] * n + r[8] * i),
      (this.y = r[1] * t + r[5] * n + r[9] * i),
      (this.z = r[2] * t + r[6] * n + r[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = i * l - r * a),
      (this.y = r * o - n * l),
      (this.z = n * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return fc.copy(this).projectOnVector(e), this.sub(fc);
  }
  reflect(e) {
    return this.sub(fc.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Qt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      n = Math.sqrt(1 - t * t);
    return (
      (this.x = n * Math.cos(e)), (this.y = t), (this.z = n * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const fc = new F(),
  Uf = new Ni();
class cr {
  constructor(
    e = new F(1 / 0, 1 / 0, 1 / 0),
    t = new F(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(ui.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(ui.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = ui.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = r.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, ui)
            : ui.fromBufferAttribute(r, o),
            ui.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ui);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Ra.copy(e.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            Ra.copy(n.boundingBox)),
          Ra.applyMatrix4(e.matrixWorld),
          this.union(Ra);
    }
    const i = e.children;
    for (let r = 0, o = i.length; r < o; r++) this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ui),
      ui.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ao),
      Ca.subVectors(this.max, Ao),
      Ss.subVectors(e.a, Ao),
      Ts.subVectors(e.b, Ao),
      Es.subVectors(e.c, Ao),
      fr.subVectors(Ts, Ss),
      dr.subVectors(Es, Ts),
      Fr.subVectors(Ss, Es);
    let t = [
      0,
      -fr.z,
      fr.y,
      0,
      -dr.z,
      dr.y,
      0,
      -Fr.z,
      Fr.y,
      fr.z,
      0,
      -fr.x,
      dr.z,
      0,
      -dr.x,
      Fr.z,
      0,
      -Fr.x,
      -fr.y,
      fr.x,
      0,
      -dr.y,
      dr.x,
      0,
      -Fr.y,
      Fr.x,
      0,
    ];
    return !dc(t, Ss, Ts, Es, Ca) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !dc(t, Ss, Ts, Es, Ca))
      ? !1
      : (Pa.crossVectors(fr, dr),
        (t = [Pa.x, Pa.y, Pa.z]),
        dc(t, Ss, Ts, Es, Ca));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ui).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(ui).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Vi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Vi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Vi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Vi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Vi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Vi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Vi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Vi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Vi),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Vi = [
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
  ],
  ui = new F(),
  Ra = new cr(),
  Ss = new F(),
  Ts = new F(),
  Es = new F(),
  fr = new F(),
  dr = new F(),
  Fr = new F(),
  Ao = new F(),
  Ca = new F(),
  Pa = new F(),
  Br = new F();
function dc(s, e, t, n, i) {
  for (let r = 0, o = s.length - 3; r <= o; r += 3) {
    Br.fromArray(s, r);
    const a =
        i.x * Math.abs(Br.x) + i.y * Math.abs(Br.y) + i.z * Math.abs(Br.z),
      l = e.dot(Br),
      c = t.dot(Br),
      h = n.dot(Br);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
  }
  return !0;
}
const l0 = new cr(),
  wo = new F(),
  pc = new F();
class Bi {
  constructor(e = new F(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : l0.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, o = e.length; r < o; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    wo.subVectors(e, this.center);
    const t = wo.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(wo, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (pc.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(wo.copy(e.center).add(pc)),
            this.expandByPoint(wo.copy(e.center).sub(pc))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Gi = new F(),
  mc = new F(),
  Da = new F(),
  pr = new F(),
  _c = new F(),
  La = new F(),
  gc = new F();
class Ta {
  constructor(e = new F(), t = new F(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Gi)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Gi.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Gi.copy(this.origin).addScaledVector(this.direction, t),
        Gi.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    mc.copy(e).add(t).multiplyScalar(0.5),
      Da.copy(t).sub(e).normalize(),
      pr.copy(this.origin).sub(mc);
    const r = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Da),
      a = pr.dot(this.direction),
      l = -pr.dot(Da),
      c = pr.lengthSq(),
      h = Math.abs(1 - o * o);
    let u, f, d, _;
    if (h > 0)
      if (((u = o * l - a), (f = o * a - l), (_ = r * h), u >= 0))
        if (f >= -_)
          if (f <= _) {
            const g = 1 / h;
            (u *= g),
              (f *= g),
              (d = u * (u + o * f + 2 * a) + f * (o * u + f + 2 * l) + c);
          } else
            (f = r),
              (u = Math.max(0, -(o * f + a))),
              (d = -u * u + f * (f + 2 * l) + c);
        else
          (f = -r),
            (u = Math.max(0, -(o * f + a))),
            (d = -u * u + f * (f + 2 * l) + c);
      else
        f <= -_
          ? ((u = Math.max(0, -(-o * r + a))),
            (f = u > 0 ? -r : Math.min(Math.max(-r, -l), r)),
            (d = -u * u + f * (f + 2 * l) + c))
          : f <= _
          ? ((u = 0),
            (f = Math.min(Math.max(-r, -l), r)),
            (d = f * (f + 2 * l) + c))
          : ((u = Math.max(0, -(o * r + a))),
            (f = u > 0 ? r : Math.min(Math.max(-r, -l), r)),
            (d = -u * u + f * (f + 2 * l) + c));
    else
      (f = o > 0 ? -r : r),
        (u = Math.max(0, -(o * f + a))),
        (d = -u * u + f * (f + 2 * l) + c);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, u),
      i && i.copy(mc).addScaledVector(Da, f),
      d
    );
  }
  intersectSphere(e, t) {
    Gi.subVectors(e.center, this.origin);
    const n = Gi.dot(this.direction),
      i = Gi.dot(Gi) - n * n,
      r = e.radius * e.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i),
      a = n - o,
      l = n + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, o, a, l;
    const c = 1 / this.direction.x,
      h = 1 / this.direction.y,
      u = 1 / this.direction.z,
      f = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - f.x) * c), (i = (e.max.x - f.x) * c))
        : ((n = (e.max.x - f.x) * c), (i = (e.min.x - f.x) * c)),
      h >= 0
        ? ((r = (e.min.y - f.y) * h), (o = (e.max.y - f.y) * h))
        : ((r = (e.max.y - f.y) * h), (o = (e.min.y - f.y) * h)),
      n > o ||
      r > i ||
      ((r > n || isNaN(n)) && (n = r),
      (o < i || isNaN(i)) && (i = o),
      u >= 0
        ? ((a = (e.min.z - f.z) * u), (l = (e.max.z - f.z) * u))
        : ((a = (e.max.z - f.z) * u), (l = (e.min.z - f.z) * u)),
      n > l || a > i) ||
      ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Gi) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    _c.subVectors(t, e), La.subVectors(n, e), gc.crossVectors(_c, La);
    let o = this.direction.dot(gc),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    pr.subVectors(this.origin, e);
    const l = a * this.direction.dot(La.crossVectors(pr, La));
    if (l < 0) return null;
    const c = a * this.direction.dot(_c.cross(pr));
    if (c < 0 || l + c > o) return null;
    const h = -a * pr.dot(gc);
    return h < 0 ? null : this.at(h / o, r);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ze {
  constructor(e, t, n, i, r, o, a, l, c, h, u, f, d, _, g, m) {
    (Ze.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, r, o, a, l, c, h, u, f, d, _, g, m);
  }
  set(e, t, n, i, r, o, a, l, c, h, u, f, d, _, g, m) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[4] = t),
      (p[8] = n),
      (p[12] = i),
      (p[1] = r),
      (p[5] = o),
      (p[9] = a),
      (p[13] = l),
      (p[2] = c),
      (p[6] = h),
      (p[10] = u),
      (p[14] = f),
      (p[3] = d),
      (p[7] = _),
      (p[11] = g),
      (p[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Ze().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / bs.setFromMatrixColumn(e, 0).length(),
      r = 1 / bs.setFromMatrixColumn(e, 1).length(),
      o = 1 / bs.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * r),
      (t[5] = n[5] * r),
      (t[6] = n[6] * r),
      (t[7] = 0),
      (t[8] = n[8] * o),
      (t[9] = n[9] * o),
      (t[10] = n[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z,
      o = Math.cos(n),
      a = Math.sin(n),
      l = Math.cos(i),
      c = Math.sin(i),
      h = Math.cos(r),
      u = Math.sin(r);
    if (e.order === "XYZ") {
      const f = o * h,
        d = o * u,
        _ = a * h,
        g = a * u;
      (t[0] = l * h),
        (t[4] = -l * u),
        (t[8] = c),
        (t[1] = d + _ * c),
        (t[5] = f - g * c),
        (t[9] = -a * l),
        (t[2] = g - f * c),
        (t[6] = _ + d * c),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const f = l * h,
        d = l * u,
        _ = c * h,
        g = c * u;
      (t[0] = f + g * a),
        (t[4] = _ * a - d),
        (t[8] = o * c),
        (t[1] = o * u),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = d * a - _),
        (t[6] = g + f * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const f = l * h,
        d = l * u,
        _ = c * h,
        g = c * u;
      (t[0] = f - g * a),
        (t[4] = -o * u),
        (t[8] = _ + d * a),
        (t[1] = d + _ * a),
        (t[5] = o * h),
        (t[9] = g - f * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const f = o * h,
        d = o * u,
        _ = a * h,
        g = a * u;
      (t[0] = l * h),
        (t[4] = _ * c - d),
        (t[8] = f * c + g),
        (t[1] = l * u),
        (t[5] = g * c + f),
        (t[9] = d * c - _),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const f = o * l,
        d = o * c,
        _ = a * l,
        g = a * c;
      (t[0] = l * h),
        (t[4] = g - f * u),
        (t[8] = _ * u + d),
        (t[1] = u),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -c * h),
        (t[6] = d * u + _),
        (t[10] = f - g * u);
    } else if (e.order === "XZY") {
      const f = o * l,
        d = o * c,
        _ = a * l,
        g = a * c;
      (t[0] = l * h),
        (t[4] = -u),
        (t[8] = c * h),
        (t[1] = f * u + g),
        (t[5] = o * h),
        (t[9] = d * u - _),
        (t[2] = _ * u - d),
        (t[6] = a * h),
        (t[10] = g * u + f);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(c0, e, h0);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      Vn.subVectors(e, t),
      Vn.lengthSq() === 0 && (Vn.z = 1),
      Vn.normalize(),
      mr.crossVectors(n, Vn),
      mr.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (Vn.x += 1e-4) : (Vn.z += 1e-4),
        Vn.normalize(),
        mr.crossVectors(n, Vn)),
      mr.normalize(),
      Ia.crossVectors(Vn, mr),
      (i[0] = mr.x),
      (i[4] = Ia.x),
      (i[8] = Vn.x),
      (i[1] = mr.y),
      (i[5] = Ia.y),
      (i[9] = Vn.y),
      (i[2] = mr.z),
      (i[6] = Ia.z),
      (i[10] = Vn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      o = n[0],
      a = n[4],
      l = n[8],
      c = n[12],
      h = n[1],
      u = n[5],
      f = n[9],
      d = n[13],
      _ = n[2],
      g = n[6],
      m = n[10],
      p = n[14],
      M = n[3],
      S = n[7],
      v = n[11],
      C = n[15],
      w = i[0],
      E = i[4],
      A = i[8],
      y = i[12],
      x = i[1],
      P = i[5],
      I = i[9],
      O = i[13],
      k = i[2],
      G = i[6],
      z = i[10],
      q = i[14],
      H = i[3],
      ee = i[7],
      D = i[11],
      oe = i[15];
    return (
      (r[0] = o * w + a * x + l * k + c * H),
      (r[4] = o * E + a * P + l * G + c * ee),
      (r[8] = o * A + a * I + l * z + c * D),
      (r[12] = o * y + a * O + l * q + c * oe),
      (r[1] = h * w + u * x + f * k + d * H),
      (r[5] = h * E + u * P + f * G + d * ee),
      (r[9] = h * A + u * I + f * z + d * D),
      (r[13] = h * y + u * O + f * q + d * oe),
      (r[2] = _ * w + g * x + m * k + p * H),
      (r[6] = _ * E + g * P + m * G + p * ee),
      (r[10] = _ * A + g * I + m * z + p * D),
      (r[14] = _ * y + g * O + m * q + p * oe),
      (r[3] = M * w + S * x + v * k + C * H),
      (r[7] = M * E + S * P + v * G + C * ee),
      (r[11] = M * A + S * I + v * z + C * D),
      (r[15] = M * y + S * O + v * q + C * oe),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      r = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      h = e[2],
      u = e[6],
      f = e[10],
      d = e[14],
      _ = e[3],
      g = e[7],
      m = e[11],
      p = e[15];
    return (
      _ *
        (+r * l * u -
          i * c * u -
          r * a * f +
          n * c * f +
          i * a * d -
          n * l * d) +
      g *
        (+t * l * d -
          t * c * f +
          r * o * f -
          i * o * d +
          i * c * h -
          r * l * h) +
      m *
        (+t * c * u -
          t * a * d -
          r * o * u +
          n * o * d +
          r * a * h -
          n * c * h) +
      p *
        (-i * a * h - t * l * u + t * a * f + i * o * u - n * o * f + n * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      u = e[9],
      f = e[10],
      d = e[11],
      _ = e[12],
      g = e[13],
      m = e[14],
      p = e[15],
      M = u * m * c - g * f * c + g * l * d - a * m * d - u * l * p + a * f * p,
      S = _ * f * c - h * m * c - _ * l * d + o * m * d + h * l * p - o * f * p,
      v = h * g * c - _ * u * c + _ * a * d - o * g * d - h * a * p + o * u * p,
      C = _ * u * l - h * g * l - _ * a * f + o * g * f + h * a * m - o * u * m,
      w = t * M + n * S + i * v + r * C;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / w;
    return (
      (e[0] = M * E),
      (e[1] =
        (g * f * r -
          u * m * r -
          g * i * d +
          n * m * d +
          u * i * p -
          n * f * p) *
        E),
      (e[2] =
        (a * m * r -
          g * l * r +
          g * i * c -
          n * m * c -
          a * i * p +
          n * l * p) *
        E),
      (e[3] =
        (u * l * r -
          a * f * r -
          u * i * c +
          n * f * c +
          a * i * d -
          n * l * d) *
        E),
      (e[4] = S * E),
      (e[5] =
        (h * m * r -
          _ * f * r +
          _ * i * d -
          t * m * d -
          h * i * p +
          t * f * p) *
        E),
      (e[6] =
        (_ * l * r -
          o * m * r -
          _ * i * c +
          t * m * c +
          o * i * p -
          t * l * p) *
        E),
      (e[7] =
        (o * f * r -
          h * l * r +
          h * i * c -
          t * f * c -
          o * i * d +
          t * l * d) *
        E),
      (e[8] = v * E),
      (e[9] =
        (_ * u * r -
          h * g * r -
          _ * n * d +
          t * g * d +
          h * n * p -
          t * u * p) *
        E),
      (e[10] =
        (o * g * r -
          _ * a * r +
          _ * n * c -
          t * g * c -
          o * n * p +
          t * a * p) *
        E),
      (e[11] =
        (h * a * r -
          o * u * r -
          h * n * c +
          t * u * c +
          o * n * d -
          t * a * d) *
        E),
      (e[12] = C * E),
      (e[13] =
        (h * g * i -
          _ * u * i +
          _ * n * f -
          t * g * f -
          h * n * m +
          t * u * m) *
        E),
      (e[14] =
        (_ * a * i -
          o * g * i -
          _ * n * l +
          t * g * l +
          o * n * m -
          t * a * m) *
        E),
      (e[15] =
        (o * u * i -
          h * a * i +
          h * n * l -
          t * u * l -
          o * n * f +
          t * a * f) *
        E),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= r),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= r),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= r),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = 1 - n,
      o = e.x,
      a = e.y,
      l = e.z,
      c = r * o,
      h = r * a;
    return (
      this.set(
        c * o + n,
        c * a - i * l,
        c * l + i * a,
        0,
        c * a + i * l,
        h * a + n,
        h * l - i * o,
        0,
        c * l - i * a,
        h * l + i * o,
        r * l * l + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, r, o) {
    return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      r = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = r + r,
      h = o + o,
      u = a + a,
      f = r * c,
      d = r * h,
      _ = r * u,
      g = o * h,
      m = o * u,
      p = a * u,
      M = l * c,
      S = l * h,
      v = l * u,
      C = n.x,
      w = n.y,
      E = n.z;
    return (
      (i[0] = (1 - (g + p)) * C),
      (i[1] = (d + v) * C),
      (i[2] = (_ - S) * C),
      (i[3] = 0),
      (i[4] = (d - v) * w),
      (i[5] = (1 - (f + p)) * w),
      (i[6] = (m + M) * w),
      (i[7] = 0),
      (i[8] = (_ + S) * E),
      (i[9] = (m - M) * E),
      (i[10] = (1 - (f + g)) * E),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = bs.set(i[0], i[1], i[2]).length();
    const o = bs.set(i[4], i[5], i[6]).length(),
      a = bs.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      fi.copy(this);
    const c = 1 / r,
      h = 1 / o,
      u = 1 / a;
    return (
      (fi.elements[0] *= c),
      (fi.elements[1] *= c),
      (fi.elements[2] *= c),
      (fi.elements[4] *= h),
      (fi.elements[5] *= h),
      (fi.elements[6] *= h),
      (fi.elements[8] *= u),
      (fi.elements[9] *= u),
      (fi.elements[10] *= u),
      t.setFromRotationMatrix(fi),
      (n.x = r),
      (n.y = o),
      (n.z = a),
      this
    );
  }
  makePerspective(e, t, n, i, r, o, a = er) {
    const l = this.elements,
      c = (2 * r) / (t - e),
      h = (2 * r) / (n - i),
      u = (t + e) / (t - e),
      f = (n + i) / (n - i);
    let d, _;
    if (a === er) (d = -(o + r) / (o - r)), (_ = (-2 * o * r) / (o - r));
    else if (a === Nl) (d = -o / (o - r)), (_ = (-o * r) / (o - r));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = u),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = h),
      (l[9] = f),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = d),
      (l[14] = _),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, r, o, a = er) {
    const l = this.elements,
      c = 1 / (t - e),
      h = 1 / (n - i),
      u = 1 / (o - r),
      f = (t + e) * c,
      d = (n + i) * h;
    let _, g;
    if (a === er) (_ = (o + r) * u), (g = -2 * u);
    else if (a === Nl) (_ = r * u), (g = -1 * u);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -f),
      (l[1] = 0),
      (l[5] = 2 * h),
      (l[9] = 0),
      (l[13] = -d),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = g),
      (l[14] = -_),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const bs = new F(),
  fi = new Ze(),
  c0 = new F(0, 0, 0),
  h0 = new F(1, 1, 1),
  mr = new F(),
  Ia = new F(),
  Vn = new F(),
  Nf = new Ze(),
  Of = new Ni();
class Oi {
  constructor(e = 0, t = 0, n = 0, i = Oi.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      r = i[0],
      o = i[4],
      a = i[8],
      l = i[1],
      c = i[5],
      h = i[9],
      u = i[2],
      f = i[6],
      d = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Qt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-o, r)))
            : ((this._x = Math.atan2(f, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Qt(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-u, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Qt(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Qt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(f, d)), (this._z = Math.atan2(l, r)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Qt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, c)), (this._y = Math.atan2(-u, r)))
            : ((this._x = 0), (this._y = Math.atan2(a, d)));
        break;
      case "XZY":
        (this._z = Math.asin(-Qt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(f, c)), (this._y = Math.atan2(a, r)))
            : ((this._x = Math.atan2(-h, d)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      Nf.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Nf, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Of.setFromEuler(this), this.setFromQuaternion(Of, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Oi.DEFAULT_ORDER = "XYZ";
class Jp {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let u0 = 0;
const Ff = new F(),
  As = new Ni(),
  Wi = new Ze(),
  Ua = new F(),
  Ro = new F(),
  f0 = new F(),
  d0 = new Ni(),
  Bf = new F(1, 0, 0),
  kf = new F(0, 1, 0),
  zf = new F(0, 0, 1),
  Hf = { type: "added" },
  p0 = { type: "removed" },
  ws = { type: "childadded", child: null },
  vc = { type: "childremoved", child: null };
class Ut extends ms {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: u0++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Ut.DEFAULT_UP.clone());
    const e = new F(),
      t = new Oi(),
      n = new Ni(),
      i = new F(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r),
      n._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Ze() },
        normalMatrix: { value: new $e() },
      }),
      (this.matrix = new Ze()),
      (this.matrixWorld = new Ze()),
      (this.matrixAutoUpdate = Ut.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Ut.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Jp()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return As.setFromAxisAngle(e, t), this.quaternion.multiply(As), this;
  }
  rotateOnWorldAxis(e, t) {
    return As.setFromAxisAngle(e, t), this.quaternion.premultiply(As), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Bf, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(kf, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(zf, e);
  }
  translateOnAxis(e, t) {
    return (
      Ff.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Ff.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Bf, e);
  }
  translateY(e) {
    return this.translateOnAxis(kf, e);
  }
  translateZ(e) {
    return this.translateOnAxis(zf, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Wi.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? Ua.copy(e) : Ua.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Ro.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Wi.lookAt(Ro, Ua, this.up)
        : Wi.lookAt(Ua, Ro, this.up),
      this.quaternion.setFromRotationMatrix(Wi),
      i &&
        (Wi.extractRotation(i.matrixWorld),
        As.setFromRotationMatrix(Wi),
        this.quaternion.premultiply(As.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Hf),
            (ws.child = e),
            this.dispatchEvent(ws),
            (ws.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(p0),
        (vc.child = e),
        this.dispatchEvent(vc),
        (vc.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Wi.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Wi.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Wi),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(Hf),
      (ws.child = e),
      this.dispatchEvent(ws),
      (ws.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let r = 0, o = i.length; r < o; r++)
      i[r].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ro, e, f0), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ro, d0, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function r(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            r(e.shapes, u);
          }
        else r(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (r(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(r(e.materials, this.material[l]));
        i.material = a;
      } else i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        h = o(e.images),
        u = o(e.shapes),
        f = o(e.skeletons),
        d = o(e.animations),
        _ = o(e.nodes);
      a.length > 0 && (n.geometries = a),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        h.length > 0 && (n.images = h),
        u.length > 0 && (n.shapes = u),
        f.length > 0 && (n.skeletons = f),
        d.length > 0 && (n.animations = d),
        _.length > 0 && (n.nodes = _);
    }
    return (n.object = i), n;
    function o(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Ut.DEFAULT_UP = new F(0, 1, 0);
Ut.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ut.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const di = new F(),
  Xi = new F(),
  xc = new F(),
  Yi = new F(),
  Rs = new F(),
  Cs = new F(),
  Vf = new F(),
  yc = new F(),
  Mc = new F(),
  Sc = new F(),
  Tc = new ft(),
  Ec = new ft(),
  bc = new ft();
class gi {
  constructor(e = new F(), t = new F(), n = new F()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), di.subVectors(e, t), i.cross(di);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, r) {
    di.subVectors(i, t), Xi.subVectors(n, t), xc.subVectors(e, t);
    const o = di.dot(di),
      a = di.dot(Xi),
      l = di.dot(xc),
      c = Xi.dot(Xi),
      h = Xi.dot(xc),
      u = o * c - a * a;
    if (u === 0) return r.set(0, 0, 0), null;
    const f = 1 / u,
      d = (c * l - a * h) * f,
      _ = (o * h - a * l) * f;
    return r.set(1 - d - _, _, d);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, Yi) === null
      ? !1
      : Yi.x >= 0 && Yi.y >= 0 && Yi.x + Yi.y <= 1;
  }
  static getInterpolation(e, t, n, i, r, o, a, l) {
    return this.getBarycoord(e, t, n, i, Yi) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(r, Yi.x),
        l.addScaledVector(o, Yi.y),
        l.addScaledVector(a, Yi.z),
        l);
  }
  static getInterpolatedAttribute(e, t, n, i, r, o) {
    return (
      Tc.setScalar(0),
      Ec.setScalar(0),
      bc.setScalar(0),
      Tc.fromBufferAttribute(e, t),
      Ec.fromBufferAttribute(e, n),
      bc.fromBufferAttribute(e, i),
      o.setScalar(0),
      o.addScaledVector(Tc, r.x),
      o.addScaledVector(Ec, r.y),
      o.addScaledVector(bc, r.z),
      o
    );
  }
  static isFrontFacing(e, t, n, i) {
    return di.subVectors(n, t), Xi.subVectors(e, t), di.cross(Xi).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      di.subVectors(this.c, this.b),
      Xi.subVectors(this.a, this.b),
      di.cross(Xi).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return gi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return gi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, r) {
    return gi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return gi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return gi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      r = this.c;
    let o, a;
    Rs.subVectors(i, n), Cs.subVectors(r, n), yc.subVectors(e, n);
    const l = Rs.dot(yc),
      c = Cs.dot(yc);
    if (l <= 0 && c <= 0) return t.copy(n);
    Mc.subVectors(e, i);
    const h = Rs.dot(Mc),
      u = Cs.dot(Mc);
    if (h >= 0 && u <= h) return t.copy(i);
    const f = l * u - h * c;
    if (f <= 0 && l >= 0 && h <= 0)
      return (o = l / (l - h)), t.copy(n).addScaledVector(Rs, o);
    Sc.subVectors(e, r);
    const d = Rs.dot(Sc),
      _ = Cs.dot(Sc);
    if (_ >= 0 && d <= _) return t.copy(r);
    const g = d * c - l * _;
    if (g <= 0 && c >= 0 && _ <= 0)
      return (a = c / (c - _)), t.copy(n).addScaledVector(Cs, a);
    const m = h * _ - d * u;
    if (m <= 0 && u - h >= 0 && d - _ >= 0)
      return (
        Vf.subVectors(r, i),
        (a = (u - h) / (u - h + (d - _))),
        t.copy(i).addScaledVector(Vf, a)
      );
    const p = 1 / (m + g + f);
    return (
      (o = g * p),
      (a = f * p),
      t.copy(n).addScaledVector(Rs, o).addScaledVector(Cs, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Qp = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  _r = { h: 0, s: 0, l: 0 },
  Na = { h: 0, s: 0, l: 0 };
function Ac(s, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? s + (e - s) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? s + (e - s) * 6 * (2 / 3 - t)
      : s
  );
}
class He {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = sn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      at.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = at.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      at.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = at.workingColorSpace) {
    if (((e = Iu(e, 1)), (t = Qt(t, 0, 1)), (n = Qt(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        o = 2 * n - r;
      (this.r = Ac(o, r, e + 1 / 3)),
        (this.g = Ac(o, r, e)),
        (this.b = Ac(o, r, e - 1 / 3));
    }
    return at.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = sn) {
    function n(r) {
      r !== void 0 &&
        parseFloat(r) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let r;
      const o = i[1],
        a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (r =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(r[4]),
              this.setRGB(
                Math.min(255, parseInt(r[1], 10)) / 255,
                Math.min(255, parseInt(r[2], 10)) / 255,
                Math.min(255, parseInt(r[3], 10)) / 255,
                t
              )
            );
          if (
            (r =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(r[4]),
              this.setRGB(
                Math.min(100, parseInt(r[1], 10)) / 100,
                Math.min(100, parseInt(r[2], 10)) / 100,
                Math.min(100, parseInt(r[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (r =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(r[4]),
              this.setHSL(
                parseFloat(r[1]) / 360,
                parseFloat(r[2]) / 100,
                parseFloat(r[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const r = i[1],
        o = r.length;
      if (o === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = sn) {
    const n = Qp[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = ir(e.r)), (this.g = ir(e.g)), (this.b = ir(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = js(e.r)), (this.g = js(e.g)), (this.b = js(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = sn) {
    return (
      at.fromWorkingColorSpace(ln.copy(this), e),
      Math.round(Qt(ln.r * 255, 0, 255)) * 65536 +
        Math.round(Qt(ln.g * 255, 0, 255)) * 256 +
        Math.round(Qt(ln.b * 255, 0, 255))
    );
  }
  getHexString(e = sn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = at.workingColorSpace) {
    at.fromWorkingColorSpace(ln.copy(this), t);
    const n = ln.r,
      i = ln.g,
      r = ln.b,
      o = Math.max(n, i, r),
      a = Math.min(n, i, r);
    let l, c;
    const h = (a + o) / 2;
    if (a === o) (l = 0), (c = 0);
    else {
      const u = o - a;
      switch (((c = h <= 0.5 ? u / (o + a) : u / (2 - o - a)), o)) {
        case n:
          l = (i - r) / u + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - n) / u + 2;
          break;
        case r:
          l = (n - i) / u + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = h), e;
  }
  getRGB(e, t = at.workingColorSpace) {
    return (
      at.fromWorkingColorSpace(ln.copy(this), t),
      (e.r = ln.r),
      (e.g = ln.g),
      (e.b = ln.b),
      e
    );
  }
  getStyle(e = sn) {
    at.fromWorkingColorSpace(ln.copy(this), e);
    const t = ln.r,
      n = ln.g,
      i = ln.b;
    return e !== sn
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(_r), this.setHSL(_r.h + e, _r.s + t, _r.l + n);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(_r), e.getHSL(Na);
    const n = Ko(_r.h, Na.h, t),
      i = Ko(_r.s, Na.s, t),
      r = Ko(_r.l, Na.l, t);
    return this.setHSL(n, i, r), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      r = e.elements;
    return (
      (this.r = r[0] * t + r[3] * n + r[6] * i),
      (this.g = r[1] * t + r[4] * n + r[7] * i),
      (this.b = r[2] * t + r[5] * n + r[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ln = new He();
He.NAMES = Qp;
let m0 = 0;
class Li extends ms {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {}
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: m0++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.blending = Ys),
      (this.side = sr),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = ch),
      (this.blendDst = hh),
      (this.blendEquation = $r),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new He(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = no),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = bf),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ys),
      (this.stencilZFail = ys),
      (this.stencilZPass = ys),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ys && (n.blending = this.blending),
      this.side !== sr && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== ch && (n.blendSrc = this.blendSrc),
      this.blendDst !== hh && (n.blendDst = this.blendDst),
      this.blendEquation !== $r && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== no && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== bf && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== ys && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== ys && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== ys && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(r) {
      const o = [];
      for (const a in r) {
        const l = r[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const r = i(e.textures),
        o = i(e.images);
      r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Sr extends Li {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.color = new He(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Oi()),
      (this.combine = Lp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Ji = _0();
function _0() {
  const s = new ArrayBuffer(4),
    e = new Float32Array(s),
    t = new Uint32Array(s),
    n = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((n[l] = 0), (n[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : c < -14
      ? ((n[l] = 1024 >> (-c - 14)),
        (n[l | 256] = (1024 >> (-c - 14)) | 32768),
        (i[l] = -c - 1),
        (i[l | 256] = -c - 1))
      : c <= 15
      ? ((n[l] = (c + 15) << 10),
        (n[l | 256] = ((c + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : c < 128
      ? ((n[l] = 31744), (n[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((n[l] = 31744), (n[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const r = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      h = 0;
    for (; !(c & 8388608); ) (c <<= 1), (h -= 8388608);
    (c &= -8388609), (h += 947912704), (r[l] = c | h);
  }
  for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: r,
    exponentTable: o,
    offsetTable: a,
  };
}
function g0(s) {
  Math.abs(s) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (s = Qt(s, -65504, 65504)),
    (Ji.floatView[0] = s);
  const e = Ji.uint32View[0],
    t = (e >> 23) & 511;
  return Ji.baseTable[t] + ((e & 8388607) >> Ji.shiftTable[t]);
}
function v0(s) {
  const e = s >> 10;
  return (
    (Ji.uint32View[0] =
      Ji.mantissaTable[Ji.offsetTable[e] + (s & 1023)] + Ji.exponentTable[e]),
    Ji.floatView[0]
  );
}
const Oa = { toHalfFloat: g0, fromHalfFloat: v0 },
  Ht = new F(),
  Fa = new De();
class Rn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = Yh),
      (this.updateRanges = []),
      (this.gpuType = Dn),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Fa.fromBufferAttribute(this, t),
          Fa.applyMatrix3(e),
          this.setXY(t, Fa.x, Fa.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Ht.fromBufferAttribute(this, t),
          Ht.applyMatrix3(e),
          this.setXYZ(t, Ht.x, Ht.y, Ht.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ht.fromBufferAttribute(this, t),
        Ht.applyMatrix4(e),
        this.setXYZ(t, Ht.x, Ht.y, Ht.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ht.fromBufferAttribute(this, t),
        Ht.applyNormalMatrix(e),
        this.setXYZ(t, Ht.x, Ht.y, Ht.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ht.fromBufferAttribute(this, t),
        Ht.transformDirection(e),
        this.setXYZ(t, Ht.x, Ht.y, Ht.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = _i(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = gt(n, this.array)),
      (this.array[e * this.itemSize + t] = n),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = gt(t, this.array)), (n = gt(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gt(t, this.array)),
        (n = gt(n, this.array)),
        (i = gt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gt(t, this.array)),
        (n = gt(n, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = r),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Yh && (e.usage = this.usage),
      e
    );
  }
}
class em extends Rn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class tm extends Rn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class yi extends Rn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let x0 = 0;
const ei = new Ze(),
  wc = new Ut(),
  Ps = new F(),
  Gn = new cr(),
  Co = new cr(),
  $t = new F();
class Mi extends ms {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: x0++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (Kp(e) ? tm : em)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new $e().getNormalMatrix(e);
      n.applyNormalMatrix(r), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return ei.makeRotationFromQuaternion(e), this.applyMatrix4(ei), this;
  }
  rotateX(e) {
    return ei.makeRotationX(e), this.applyMatrix4(ei), this;
  }
  rotateY(e) {
    return ei.makeRotationY(e), this.applyMatrix4(ei), this;
  }
  rotateZ(e) {
    return ei.makeRotationZ(e), this.applyMatrix4(ei), this;
  }
  translate(e, t, n) {
    return ei.makeTranslation(e, t, n), this.applyMatrix4(ei), this;
  }
  scale(e, t, n) {
    return ei.makeScale(e, t, n), this.applyMatrix4(ei), this;
  }
  lookAt(e) {
    return wc.lookAt(e), wc.updateMatrix(), this.applyMatrix4(wc.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ps).negate(),
      this.translate(Ps.x, Ps.y, Ps.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let i = 0, r = e.length; i < r; i++) {
        const o = e[i];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new yi(n, 3));
    } else {
      for (let n = 0, i = t.count; n < i; n++) {
        const r = e[n];
        t.setXYZ(n, r.x, r.y, r.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new cr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new F(-1 / 0, -1 / 0, -1 / 0),
          new F(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          Gn.setFromBufferAttribute(r),
            this.morphTargetsRelative
              ? ($t.addVectors(this.boundingBox.min, Gn.min),
                this.boundingBox.expandByPoint($t),
                $t.addVectors(this.boundingBox.max, Gn.max),
                this.boundingBox.expandByPoint($t))
              : (this.boundingBox.expandByPoint(Gn.min),
                this.boundingBox.expandByPoint(Gn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Bi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new F(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((Gn.setFromBufferAttribute(e), t))
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r];
          Co.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? ($t.addVectors(Gn.min, Co.min),
                Gn.expandByPoint($t),
                $t.addVectors(Gn.max, Co.max),
                Gn.expandByPoint($t))
              : (Gn.expandByPoint(Co.min), Gn.expandByPoint(Co.max));
        }
      Gn.getCenter(n);
      let i = 0;
      for (let r = 0, o = e.count; r < o; r++)
        $t.fromBufferAttribute(e, r),
          (i = Math.max(i, n.distanceToSquared($t)));
      if (t)
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r],
            l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++)
            $t.fromBufferAttribute(a, c),
              l && (Ps.fromBufferAttribute(e, c), $t.add(Ps)),
              (i = Math.max(i, n.distanceToSquared($t)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = t.position,
      i = t.normal,
      r = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Rn(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let A = 0; A < n.count; A++) (a[A] = new F()), (l[A] = new F());
    const c = new F(),
      h = new F(),
      u = new F(),
      f = new De(),
      d = new De(),
      _ = new De(),
      g = new F(),
      m = new F();
    function p(A, y, x) {
      c.fromBufferAttribute(n, A),
        h.fromBufferAttribute(n, y),
        u.fromBufferAttribute(n, x),
        f.fromBufferAttribute(r, A),
        d.fromBufferAttribute(r, y),
        _.fromBufferAttribute(r, x),
        h.sub(c),
        u.sub(c),
        d.sub(f),
        _.sub(f);
      const P = 1 / (d.x * _.y - _.x * d.y);
      isFinite(P) &&
        (g
          .copy(h)
          .multiplyScalar(_.y)
          .addScaledVector(u, -d.y)
          .multiplyScalar(P),
        m
          .copy(u)
          .multiplyScalar(d.x)
          .addScaledVector(h, -_.x)
          .multiplyScalar(P),
        a[A].add(g),
        a[y].add(g),
        a[x].add(g),
        l[A].add(m),
        l[y].add(m),
        l[x].add(m));
    }
    let M = this.groups;
    M.length === 0 && (M = [{ start: 0, count: e.count }]);
    for (let A = 0, y = M.length; A < y; ++A) {
      const x = M[A],
        P = x.start,
        I = x.count;
      for (let O = P, k = P + I; O < k; O += 3)
        p(e.getX(O + 0), e.getX(O + 1), e.getX(O + 2));
    }
    const S = new F(),
      v = new F(),
      C = new F(),
      w = new F();
    function E(A) {
      C.fromBufferAttribute(i, A), w.copy(C);
      const y = a[A];
      S.copy(y),
        S.sub(C.multiplyScalar(C.dot(y))).normalize(),
        v.crossVectors(w, y);
      const P = v.dot(l[A]) < 0 ? -1 : 1;
      o.setXYZW(A, S.x, S.y, S.z, P);
    }
    for (let A = 0, y = M.length; A < y; ++A) {
      const x = M[A],
        P = x.start,
        I = x.count;
      for (let O = P, k = P + I; O < k; O += 3)
        E(e.getX(O + 0)), E(e.getX(O + 1)), E(e.getX(O + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new Rn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let f = 0, d = n.count; f < d; f++) n.setXYZ(f, 0, 0, 0);
      const i = new F(),
        r = new F(),
        o = new F(),
        a = new F(),
        l = new F(),
        c = new F(),
        h = new F(),
        u = new F();
      if (e)
        for (let f = 0, d = e.count; f < d; f += 3) {
          const _ = e.getX(f + 0),
            g = e.getX(f + 1),
            m = e.getX(f + 2);
          i.fromBufferAttribute(t, _),
            r.fromBufferAttribute(t, g),
            o.fromBufferAttribute(t, m),
            h.subVectors(o, r),
            u.subVectors(i, r),
            h.cross(u),
            a.fromBufferAttribute(n, _),
            l.fromBufferAttribute(n, g),
            c.fromBufferAttribute(n, m),
            a.add(h),
            l.add(h),
            c.add(h),
            n.setXYZ(_, a.x, a.y, a.z),
            n.setXYZ(g, l.x, l.y, l.z),
            n.setXYZ(m, c.x, c.y, c.z);
        }
      else
        for (let f = 0, d = t.count; f < d; f += 3)
          i.fromBufferAttribute(t, f + 0),
            r.fromBufferAttribute(t, f + 1),
            o.fromBufferAttribute(t, f + 2),
            h.subVectors(o, r),
            u.subVectors(i, r),
            h.cross(u),
            n.setXYZ(f + 0, h.x, h.y, h.z),
            n.setXYZ(f + 1, h.x, h.y, h.z),
            n.setXYZ(f + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      $t.fromBufferAttribute(e, t),
        $t.normalize(),
        e.setXYZ(t, $t.x, $t.y, $t.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        h = a.itemSize,
        u = a.normalized,
        f = new c.constructor(l.length * h);
      let d = 0,
        _ = 0;
      for (let g = 0, m = l.length; g < m; g++) {
        a.isInterleavedBufferAttribute
          ? (d = l[g] * a.data.stride + a.offset)
          : (d = l[g] * h);
        for (let p = 0; p < h; p++) f[_++] = c[d++];
      }
      return new Rn(f, h, u);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Mi(),
      n = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        c = e(l, n);
      t.setAttribute(a, c);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const l = [],
        c = r[a];
      for (let h = 0, u = c.length; h < u; h++) {
        const f = c[h],
          d = e(f, n);
        l.push(d);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        h = [];
      for (let u = 0, f = c.length; u < f; u++) {
        const d = c[u];
        h.push(d.toJSON(e.data));
      }
      h.length > 0 && ((i[l] = h), (r = !0));
    }
    r &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const h = i[c];
      this.setAttribute(c, h.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const h = [],
        u = r[c];
      for (let f = 0, d = u.length; f < d; f++) h.push(u[f].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const u = o[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Gf = new Ze(),
  kr = new Ta(),
  Ba = new Bi(),
  Wf = new F(),
  ka = new F(),
  za = new F(),
  Ha = new F(),
  Rc = new F(),
  Va = new F(),
  Xf = new F(),
  Ga = new F();
class Ln extends Ut {
  constructor(e = new Mi(), t = new Sr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = r);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      r = n.morphAttributes.position,
      o = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (r && a) {
      Va.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const h = a[l],
          u = r[l];
        h !== 0 &&
          (Rc.fromBufferAttribute(u, e),
          o ? Va.addScaledVector(Rc, h) : Va.addScaledVector(Rc.sub(t), h));
      }
      t.add(Va);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ba.copy(n.boundingSphere),
      Ba.applyMatrix4(r),
      kr.copy(e.ray).recast(e.near),
      !(
        Ba.containsPoint(kr.origin) === !1 &&
        (kr.intersectSphere(Ba, Wf) === null ||
          kr.origin.distanceToSquared(Wf) > (e.far - e.near) ** 2)
      ) &&
        (Gf.copy(r).invert(),
        kr.copy(e.ray).applyMatrix4(Gf),
        !(n.boundingBox !== null && kr.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, kr)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const r = this.geometry,
      o = this.material,
      a = r.index,
      l = r.attributes.position,
      c = r.attributes.uv,
      h = r.attributes.uv1,
      u = r.attributes.normal,
      f = r.groups,
      d = r.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let _ = 0, g = f.length; _ < g; _++) {
          const m = f[_],
            p = o[m.materialIndex],
            M = Math.max(m.start, d.start),
            S = Math.min(
              a.count,
              Math.min(m.start + m.count, d.start + d.count)
            );
          for (let v = M, C = S; v < C; v += 3) {
            const w = a.getX(v),
              E = a.getX(v + 1),
              A = a.getX(v + 2);
            (i = Wa(this, p, e, n, c, h, u, w, E, A)),
              i &&
                ((i.faceIndex = Math.floor(v / 3)),
                (i.face.materialIndex = m.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, d.start),
          g = Math.min(a.count, d.start + d.count);
        for (let m = _, p = g; m < p; m += 3) {
          const M = a.getX(m),
            S = a.getX(m + 1),
            v = a.getX(m + 2);
          (i = Wa(this, o, e, n, c, h, u, M, S, v)),
            i && ((i.faceIndex = Math.floor(m / 3)), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, g = f.length; _ < g; _++) {
          const m = f[_],
            p = o[m.materialIndex],
            M = Math.max(m.start, d.start),
            S = Math.min(
              l.count,
              Math.min(m.start + m.count, d.start + d.count)
            );
          for (let v = M, C = S; v < C; v += 3) {
            const w = v,
              E = v + 1,
              A = v + 2;
            (i = Wa(this, p, e, n, c, h, u, w, E, A)),
              i &&
                ((i.faceIndex = Math.floor(v / 3)),
                (i.face.materialIndex = m.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, d.start),
          g = Math.min(l.count, d.start + d.count);
        for (let m = _, p = g; m < p; m += 3) {
          const M = m,
            S = m + 1,
            v = m + 2;
          (i = Wa(this, o, e, n, c, h, u, M, S, v)),
            i && ((i.faceIndex = Math.floor(m / 3)), t.push(i));
        }
      }
  }
}
function y0(s, e, t, n, i, r, o, a) {
  let l;
  if (
    (e.side === Un
      ? (l = n.intersectTriangle(o, r, i, !0, a))
      : (l = n.intersectTriangle(i, r, o, e.side === sr, a)),
    l === null)
  )
    return null;
  Ga.copy(a), Ga.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(Ga);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Ga.clone(), object: s };
}
function Wa(s, e, t, n, i, r, o, a, l, c) {
  s.getVertexPosition(a, ka),
    s.getVertexPosition(l, za),
    s.getVertexPosition(c, Ha);
  const h = y0(s, e, t, n, ka, za, Ha, Xf);
  if (h) {
    const u = new F();
    gi.getBarycoord(Xf, ka, za, Ha, u),
      i && (h.uv = gi.getInterpolatedAttribute(i, a, l, c, u, new De())),
      r && (h.uv1 = gi.getInterpolatedAttribute(r, a, l, c, u, new De())),
      o &&
        ((h.normal = gi.getInterpolatedAttribute(o, a, l, c, u, new F())),
        h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const f = { a, b: l, c, normal: new F(), materialIndex: 0 };
    gi.getNormal(ka, za, Ha, f.normal), (h.face = f), (h.barycoord = u);
  }
  return h;
}
class Ea extends Mi {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o,
      });
    const a = this;
    (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
    const l = [],
      c = [],
      h = [],
      u = [];
    let f = 0,
      d = 0;
    _("z", "y", "x", -1, -1, n, t, e, o, r, 0),
      _("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
      _("x", "z", "y", 1, 1, e, n, t, i, o, 2),
      _("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
      _("x", "y", "z", 1, -1, e, t, n, i, r, 4),
      _("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
      this.setIndex(l),
      this.setAttribute("position", new yi(c, 3)),
      this.setAttribute("normal", new yi(h, 3)),
      this.setAttribute("uv", new yi(u, 2));
    function _(g, m, p, M, S, v, C, w, E, A, y) {
      const x = v / E,
        P = C / A,
        I = v / 2,
        O = C / 2,
        k = w / 2,
        G = E + 1,
        z = A + 1;
      let q = 0,
        H = 0;
      const ee = new F();
      for (let D = 0; D < z; D++) {
        const oe = D * P - O;
        for (let Me = 0; Me < G; Me++) {
          const Ue = Me * x - I;
          (ee[g] = Ue * M),
            (ee[m] = oe * S),
            (ee[p] = k),
            c.push(ee.x, ee.y, ee.z),
            (ee[g] = 0),
            (ee[m] = 0),
            (ee[p] = w > 0 ? 1 : -1),
            h.push(ee.x, ee.y, ee.z),
            u.push(Me / E),
            u.push(1 - D / A),
            (q += 1);
        }
      }
      for (let D = 0; D < A; D++)
        for (let oe = 0; oe < E; oe++) {
          const Me = f + oe + G * D,
            Ue = f + oe + G * (D + 1),
            K = f + (oe + 1) + G * (D + 1),
            te = f + (oe + 1) + G * D;
          l.push(Me, Ue, te), l.push(Ue, K, te), (H += 6);
        }
      a.addGroup(d, H, y), (d += H), (f += q);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ea(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function co(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function xn(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = co(s[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function M0(s) {
  const e = [];
  for (let t = 0; t < s.length; t++) e.push(s[t].clone());
  return e;
}
function nm(s) {
  const e = s.getRenderTarget();
  return e === null
    ? s.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : at.workingColorSpace;
}
const Ol = { clone: co, merge: xn };
var S0 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  T0 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class In extends Li {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = S0),
      (this.fragmentShader = T0),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = co(e.uniforms)),
      (this.uniformsGroups = M0(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
        : (t.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class im extends Ut {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Ze()),
      (this.projectionMatrix = new Ze()),
      (this.projectionMatrixInverse = new Ze()),
      (this.coordinateSystem = er);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const gr = new F(),
  Yf = new De(),
  qf = new De();
class Tn extends im {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = lo * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(jo * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return lo * 2 * Math.atan(Math.tan(jo * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    gr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(gr.x, gr.y).multiplyScalar(-e / gr.z),
      gr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(gr.x, gr.y).multiplyScalar(-e / gr.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, Yf, qf), t.subVectors(qf, Yf);
  }
  setViewOffset(e, t, n, i, r, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(jo * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      r = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (r += (o.offsetX * i) / l),
        (t -= (o.offsetY * n) / c),
        (i *= o.width / l),
        (n *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (r += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        r,
        r + i,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Ds = -90,
  Ls = 1;
class E0 extends Ut {
  constructor(e, t, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Tn(Ds, Ls, e, t);
    (i.layers = this.layers), this.add(i);
    const r = new Tn(Ds, Ls, e, t);
    (r.layers = this.layers), this.add(r);
    const o = new Tn(Ds, Ls, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new Tn(Ds, Ls, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new Tn(Ds, Ls, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new Tn(Ds, Ls, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, i, r, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === er)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, 0, -1),
        r.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === Nl)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 0, 1),
        r.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [r, o, a, l, c, h] = this.children,
      u = e.getRenderTarget(),
      f = e.getActiveCubeFace(),
      d = e.getActiveMipmapLevel(),
      _ = e.xr.enabled;
    e.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0, i),
      e.render(t, r),
      e.setRenderTarget(n, 1, i),
      e.render(t, o),
      e.setRenderTarget(n, 2, i),
      e.render(t, a),
      e.setRenderTarget(n, 3, i),
      e.render(t, l),
      e.setRenderTarget(n, 4, i),
      e.render(t, c),
      (n.texture.generateMipmaps = g),
      e.setRenderTarget(n, 5, i),
      e.render(t, h),
      e.setRenderTarget(u, f, d),
      (e.xr.enabled = _),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class rm extends nn {
  constructor(e, t, n, i, r, o, a, l, c, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : io),
      super(e, t, n, i, r, o, a, l, c, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class b0 extends xi {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    (this.texture = new rm(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : tn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Ea(5, 5, 5),
      r = new In({
        name: "CubemapFromEquirect",
        uniforms: co(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Un,
        blending: nr,
      });
    r.uniforms.tEquirect.value = t;
    const o = new Ln(i, r),
      a = t.minFilter;
    return (
      t.minFilter === Ci && (t.minFilter = tn),
      new E0(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
const Cc = new F(),
  A0 = new F(),
  w0 = new $e();
class yr {
  constructor(e = new F(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = Cc.subVectors(n, t).cross(A0.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(Cc),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || w0.getNormalMatrix(e),
      i = this.coplanarPoint(Cc).applyMatrix4(e),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const zr = new Bi(),
  Xa = new F();
class Uu {
  constructor(
    e = new yr(),
    t = new yr(),
    n = new yr(),
    i = new yr(),
    r = new yr(),
    o = new yr()
  ) {
    this.planes = [e, t, n, i, r, o];
  }
  set(e, t, n, i, r, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(n),
      a[3].copy(i),
      a[4].copy(r),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = er) {
    const n = this.planes,
      i = e.elements,
      r = i[0],
      o = i[1],
      a = i[2],
      l = i[3],
      c = i[4],
      h = i[5],
      u = i[6],
      f = i[7],
      d = i[8],
      _ = i[9],
      g = i[10],
      m = i[11],
      p = i[12],
      M = i[13],
      S = i[14],
      v = i[15];
    if (
      (n[0].setComponents(l - r, f - c, m - d, v - p).normalize(),
      n[1].setComponents(l + r, f + c, m + d, v + p).normalize(),
      n[2].setComponents(l + o, f + h, m + _, v + M).normalize(),
      n[3].setComponents(l - o, f - h, m - _, v - M).normalize(),
      n[4].setComponents(l - a, f - u, m - g, v - S).normalize(),
      t === er)
    )
      n[5].setComponents(l + a, f + u, m + g, v + S).normalize();
    else if (t === Nl) n[5].setComponents(a, u, g, S).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        zr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        zr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(zr);
  }
  intersectsSprite(e) {
    return (
      zr.center.set(0, 0, 0),
      (zr.radius = 0.7071067811865476),
      zr.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(zr)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((Xa.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Xa.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Xa.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Xa) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function sm() {
  let s = null,
    e = !1,
    t = null,
    n = null;
  function i(r, o) {
    t(r, o), (n = s.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = s.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      s.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (r) {
      t = r;
    },
    setContext: function (r) {
      s = r;
    },
  };
}
function R0(s) {
  const e = new WeakMap();
  function t(a, l) {
    const c = a.array,
      h = a.usage,
      u = c.byteLength,
      f = s.createBuffer();
    s.bindBuffer(l, f), s.bufferData(l, c, h), a.onUploadCallback();
    let d;
    if (c instanceof Float32Array) d = s.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (d = s.HALF_FLOAT) : (d = s.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) d = s.SHORT;
    else if (c instanceof Uint32Array) d = s.UNSIGNED_INT;
    else if (c instanceof Int32Array) d = s.INT;
    else if (c instanceof Int8Array) d = s.BYTE;
    else if (c instanceof Uint8Array) d = s.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) d = s.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: f,
      type: d,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: u,
    };
  }
  function n(a, l, c) {
    const h = l.array,
      u = l.updateRanges;
    if ((s.bindBuffer(c, a), u.length === 0)) s.bufferSubData(c, 0, h);
    else {
      u.sort((d, _) => d.start - _.start);
      let f = 0;
      for (let d = 1; d < u.length; d++) {
        const _ = u[f],
          g = u[d];
        g.start <= _.start + _.count + 1
          ? (_.count = Math.max(_.count, g.start + g.count - _.start))
          : (++f, (u[f] = g));
      }
      u.length = f + 1;
      for (let d = 0, _ = u.length; d < _; d++) {
        const g = u[d];
        s.bufferSubData(c, g.start * h.BYTES_PER_ELEMENT, h, g.start, g.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function i(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function r(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (s.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const h = e.get(a);
      (!h || h.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    const c = e.get(a);
    if (c === void 0) e.set(a, t(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      n(c.buffer, a, l), (c.version = a.version);
    }
  }
  return { get: i, remove: r, update: o };
}
class Ql extends Mi {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const r = e / 2,
      o = t / 2,
      a = Math.floor(n),
      l = Math.floor(i),
      c = a + 1,
      h = l + 1,
      u = e / a,
      f = t / l,
      d = [],
      _ = [],
      g = [],
      m = [];
    for (let p = 0; p < h; p++) {
      const M = p * f - o;
      for (let S = 0; S < c; S++) {
        const v = S * u - r;
        _.push(v, -M, 0), g.push(0, 0, 1), m.push(S / a), m.push(1 - p / l);
      }
    }
    for (let p = 0; p < l; p++)
      for (let M = 0; M < a; M++) {
        const S = M + c * p,
          v = M + c * (p + 1),
          C = M + 1 + c * (p + 1),
          w = M + 1 + c * p;
        d.push(S, v, w), d.push(v, C, w);
      }
    this.setIndex(d),
      this.setAttribute("position", new yi(_, 3)),
      this.setAttribute("normal", new yi(g, 3)),
      this.setAttribute("uv", new yi(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ql(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var C0 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  P0 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  D0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  L0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  I0 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  U0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  N0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  O0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  F0 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  B0 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  k0 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  z0 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  H0 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  V0 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  G0 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  W0 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  X0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Y0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  q0 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  j0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  K0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  $0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  Z0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  J0 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  Q0 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  ev = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  tv = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  nv = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  iv = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  rv = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  sv = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  ov = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  av = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  lv = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  cv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  hv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  uv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fv = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  dv = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  pv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  mv = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  _v = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  gv = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  vv = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  xv = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  yv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Mv = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  Sv = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Tv = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  Ev = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  bv = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Av = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  wv = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Rv = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Cv = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Pv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  Dv = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Lv = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Iv = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Uv = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  Nv = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Ov = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Fv = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Bv = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  kv = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  zv = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Hv = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  Vv = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Gv = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Wv = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  Xv = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Yv = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  qv = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  jv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Kv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  $v = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Zv = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Jv = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  Qv = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  ex = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  tx = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  nx = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  ix = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  rx = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  sx = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  ox = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  ax = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  lx = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  cx = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  hx = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  ux = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  fx = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  dx = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  px = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  mx = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  _x = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  gx = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  vx = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  xx = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  yx = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  Mx = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  Sx = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  Tx = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  Ex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  bx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Ax = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  wx = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Rx = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  Cx = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Px = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Dx = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Lx = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Ix = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Ux = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  Nx = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  Ox = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Fx = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Bx = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  kx = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  zx = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Hx = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Vx = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Gx = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Wx = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Xx = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Yx = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  qx = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  jx = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Kx = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  $x = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Zx = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Jx = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  Qx = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ey = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  ty = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ny = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  iy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  ry = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  sy = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  oy = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ay = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Je = {
    alphahash_fragment: C0,
    alphahash_pars_fragment: P0,
    alphamap_fragment: D0,
    alphamap_pars_fragment: L0,
    alphatest_fragment: I0,
    alphatest_pars_fragment: U0,
    aomap_fragment: N0,
    aomap_pars_fragment: O0,
    batching_pars_vertex: F0,
    batching_vertex: B0,
    begin_vertex: k0,
    beginnormal_vertex: z0,
    bsdfs: H0,
    iridescence_fragment: V0,
    bumpmap_pars_fragment: G0,
    clipping_planes_fragment: W0,
    clipping_planes_pars_fragment: X0,
    clipping_planes_pars_vertex: Y0,
    clipping_planes_vertex: q0,
    color_fragment: j0,
    color_pars_fragment: K0,
    color_pars_vertex: $0,
    color_vertex: Z0,
    common: J0,
    cube_uv_reflection_fragment: Q0,
    defaultnormal_vertex: ev,
    displacementmap_pars_vertex: tv,
    displacementmap_vertex: nv,
    emissivemap_fragment: iv,
    emissivemap_pars_fragment: rv,
    colorspace_fragment: sv,
    colorspace_pars_fragment: ov,
    envmap_fragment: av,
    envmap_common_pars_fragment: lv,
    envmap_pars_fragment: cv,
    envmap_pars_vertex: hv,
    envmap_physical_pars_fragment: Mv,
    envmap_vertex: uv,
    fog_vertex: fv,
    fog_pars_vertex: dv,
    fog_fragment: pv,
    fog_pars_fragment: mv,
    gradientmap_pars_fragment: _v,
    lightmap_pars_fragment: gv,
    lights_lambert_fragment: vv,
    lights_lambert_pars_fragment: xv,
    lights_pars_begin: yv,
    lights_toon_fragment: Sv,
    lights_toon_pars_fragment: Tv,
    lights_phong_fragment: Ev,
    lights_phong_pars_fragment: bv,
    lights_physical_fragment: Av,
    lights_physical_pars_fragment: wv,
    lights_fragment_begin: Rv,
    lights_fragment_maps: Cv,
    lights_fragment_end: Pv,
    logdepthbuf_fragment: Dv,
    logdepthbuf_pars_fragment: Lv,
    logdepthbuf_pars_vertex: Iv,
    logdepthbuf_vertex: Uv,
    map_fragment: Nv,
    map_pars_fragment: Ov,
    map_particle_fragment: Fv,
    map_particle_pars_fragment: Bv,
    metalnessmap_fragment: kv,
    metalnessmap_pars_fragment: zv,
    morphinstance_vertex: Hv,
    morphcolor_vertex: Vv,
    morphnormal_vertex: Gv,
    morphtarget_pars_vertex: Wv,
    morphtarget_vertex: Xv,
    normal_fragment_begin: Yv,
    normal_fragment_maps: qv,
    normal_pars_fragment: jv,
    normal_pars_vertex: Kv,
    normal_vertex: $v,
    normalmap_pars_fragment: Zv,
    clearcoat_normal_fragment_begin: Jv,
    clearcoat_normal_fragment_maps: Qv,
    clearcoat_pars_fragment: ex,
    iridescence_pars_fragment: tx,
    opaque_fragment: nx,
    packing: ix,
    premultiplied_alpha_fragment: rx,
    project_vertex: sx,
    dithering_fragment: ox,
    dithering_pars_fragment: ax,
    roughnessmap_fragment: lx,
    roughnessmap_pars_fragment: cx,
    shadowmap_pars_fragment: hx,
    shadowmap_pars_vertex: ux,
    shadowmap_vertex: fx,
    shadowmask_pars_fragment: dx,
    skinbase_vertex: px,
    skinning_pars_vertex: mx,
    skinning_vertex: _x,
    skinnormal_vertex: gx,
    specularmap_fragment: vx,
    specularmap_pars_fragment: xx,
    tonemapping_fragment: yx,
    tonemapping_pars_fragment: Mx,
    transmission_fragment: Sx,
    transmission_pars_fragment: Tx,
    uv_pars_fragment: Ex,
    uv_pars_vertex: bx,
    uv_vertex: Ax,
    worldpos_vertex: wx,
    background_vert: Rx,
    background_frag: Cx,
    backgroundCube_vert: Px,
    backgroundCube_frag: Dx,
    cube_vert: Lx,
    cube_frag: Ix,
    depth_vert: Ux,
    depth_frag: Nx,
    distanceRGBA_vert: Ox,
    distanceRGBA_frag: Fx,
    equirect_vert: Bx,
    equirect_frag: kx,
    linedashed_vert: zx,
    linedashed_frag: Hx,
    meshbasic_vert: Vx,
    meshbasic_frag: Gx,
    meshlambert_vert: Wx,
    meshlambert_frag: Xx,
    meshmatcap_vert: Yx,
    meshmatcap_frag: qx,
    meshnormal_vert: jx,
    meshnormal_frag: Kx,
    meshphong_vert: $x,
    meshphong_frag: Zx,
    meshphysical_vert: Jx,
    meshphysical_frag: Qx,
    meshtoon_vert: ey,
    meshtoon_frag: ty,
    points_vert: ny,
    points_frag: iy,
    shadow_vert: ry,
    shadow_frag: sy,
    sprite_vert: oy,
    sprite_frag: ay,
  },
  _e = {
    common: {
      diffuse: { value: new He(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new $e() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new $e() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new $e() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new $e() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new $e() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new $e() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new $e() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new $e() },
      normalScale: { value: new De(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new $e() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new $e() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new $e() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new $e() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new He(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new He(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new $e() },
      alphaTest: { value: 0 },
      uvTransform: { value: new $e() },
    },
    sprite: {
      diffuse: { value: new He(16777215) },
      opacity: { value: 1 },
      center: { value: new De(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new $e() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new $e() },
      alphaTest: { value: 0 },
    },
  },
  bi = {
    basic: {
      uniforms: xn([
        _e.common,
        _e.specularmap,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.fog,
      ]),
      vertexShader: Je.meshbasic_vert,
      fragmentShader: Je.meshbasic_frag,
    },
    lambert: {
      uniforms: xn([
        _e.common,
        _e.specularmap,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.fog,
        _e.lights,
        { emissive: { value: new He(0) } },
      ]),
      vertexShader: Je.meshlambert_vert,
      fragmentShader: Je.meshlambert_frag,
    },
    phong: {
      uniforms: xn([
        _e.common,
        _e.specularmap,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.fog,
        _e.lights,
        {
          emissive: { value: new He(0) },
          specular: { value: new He(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Je.meshphong_vert,
      fragmentShader: Je.meshphong_frag,
    },
    standard: {
      uniforms: xn([
        _e.common,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.roughnessmap,
        _e.metalnessmap,
        _e.fog,
        _e.lights,
        {
          emissive: { value: new He(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Je.meshphysical_vert,
      fragmentShader: Je.meshphysical_frag,
    },
    toon: {
      uniforms: xn([
        _e.common,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.gradientmap,
        _e.fog,
        _e.lights,
        { emissive: { value: new He(0) } },
      ]),
      vertexShader: Je.meshtoon_vert,
      fragmentShader: Je.meshtoon_frag,
    },
    matcap: {
      uniforms: xn([
        _e.common,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Je.meshmatcap_vert,
      fragmentShader: Je.meshmatcap_frag,
    },
    points: {
      uniforms: xn([_e.points, _e.fog]),
      vertexShader: Je.points_vert,
      fragmentShader: Je.points_frag,
    },
    dashed: {
      uniforms: xn([
        _e.common,
        _e.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Je.linedashed_vert,
      fragmentShader: Je.linedashed_frag,
    },
    depth: {
      uniforms: xn([_e.common, _e.displacementmap]),
      vertexShader: Je.depth_vert,
      fragmentShader: Je.depth_frag,
    },
    normal: {
      uniforms: xn([
        _e.common,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Je.meshnormal_vert,
      fragmentShader: Je.meshnormal_frag,
    },
    sprite: {
      uniforms: xn([_e.sprite, _e.fog]),
      vertexShader: Je.sprite_vert,
      fragmentShader: Je.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new $e() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Je.background_vert,
      fragmentShader: Je.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new $e() },
      },
      vertexShader: Je.backgroundCube_vert,
      fragmentShader: Je.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Je.cube_vert,
      fragmentShader: Je.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Je.equirect_vert,
      fragmentShader: Je.equirect_frag,
    },
    distanceRGBA: {
      uniforms: xn([
        _e.common,
        _e.displacementmap,
        {
          referencePosition: { value: new F() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Je.distanceRGBA_vert,
      fragmentShader: Je.distanceRGBA_frag,
    },
    shadow: {
      uniforms: xn([
        _e.lights,
        _e.fog,
        { color: { value: new He(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Je.shadow_vert,
      fragmentShader: Je.shadow_frag,
    },
  };
bi.physical = {
  uniforms: xn([
    bi.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new $e() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new $e() },
      clearcoatNormalScale: { value: new De(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new $e() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new $e() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new $e() },
      sheen: { value: 0 },
      sheenColor: { value: new He(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new $e() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new $e() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new $e() },
      transmissionSamplerSize: { value: new De() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new $e() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new He(0) },
      specularColor: { value: new He(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new $e() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new $e() },
      anisotropyVector: { value: new De() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new $e() },
    },
  ]),
  vertexShader: Je.meshphysical_vert,
  fragmentShader: Je.meshphysical_frag,
};
const Ya = { r: 0, b: 0, g: 0 },
  Hr = new Oi(),
  ly = new Ze();
function cy(s, e, t, n, i, r, o) {
  const a = new He(0);
  let l = r === !0 ? 0 : 1,
    c,
    h,
    u = null,
    f = 0,
    d = null;
  function _(M) {
    let S = M.isScene === !0 ? M.background : null;
    return (
      S && S.isTexture && (S = (M.backgroundBlurriness > 0 ? t : e).get(S)), S
    );
  }
  function g(M) {
    let S = !1;
    const v = _(M);
    v === null ? p(a, l) : v && v.isColor && (p(v, 1), (S = !0));
    const C = s.xr.getEnvironmentBlendMode();
    C === "additive"
      ? n.buffers.color.setClear(0, 0, 0, 1, o)
      : C === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
      (s.autoClear || S) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function m(M, S) {
    const v = _(S);
    v && (v.isCubeTexture || v.mapping === Zl)
      ? (h === void 0 &&
          ((h = new Ln(
            new Ea(1, 1, 1),
            new In({
              name: "BackgroundCubeMaterial",
              uniforms: co(bi.backgroundCube.uniforms),
              vertexShader: bi.backgroundCube.vertexShader,
              fragmentShader: bi.backgroundCube.fragmentShader,
              side: Un,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          h.geometry.deleteAttribute("normal"),
          h.geometry.deleteAttribute("uv"),
          (h.onBeforeRender = function (C, w, E) {
            this.matrixWorld.copyPosition(E.matrixWorld);
          }),
          Object.defineProperty(h.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(h)),
        Hr.copy(S.backgroundRotation),
        (Hr.x *= -1),
        (Hr.y *= -1),
        (Hr.z *= -1),
        v.isCubeTexture &&
          v.isRenderTargetTexture === !1 &&
          ((Hr.y *= -1), (Hr.z *= -1)),
        (h.material.uniforms.envMap.value = v),
        (h.material.uniforms.flipEnvMap.value =
          v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
        (h.material.uniforms.backgroundBlurriness.value =
          S.backgroundBlurriness),
        (h.material.uniforms.backgroundIntensity.value = S.backgroundIntensity),
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(
          ly.makeRotationFromEuler(Hr)
        ),
        (h.material.toneMapped = at.getTransfer(v.colorSpace) !== xt),
        (u !== v || f !== v.version || d !== s.toneMapping) &&
          ((h.material.needsUpdate = !0),
          (u = v),
          (f = v.version),
          (d = s.toneMapping)),
        h.layers.enableAll(),
        M.unshift(h, h.geometry, h.material, 0, 0, null))
      : v &&
        v.isTexture &&
        (c === void 0 &&
          ((c = new Ln(
            new Ql(2, 2),
            new In({
              name: "BackgroundMaterial",
              uniforms: co(bi.background.uniforms),
              vertexShader: bi.background.vertexShader,
              fragmentShader: bi.background.fragmentShader,
              side: sr,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(c)),
        (c.material.uniforms.t2D.value = v),
        (c.material.uniforms.backgroundIntensity.value = S.backgroundIntensity),
        (c.material.toneMapped = at.getTransfer(v.colorSpace) !== xt),
        v.matrixAutoUpdate === !0 && v.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(v.matrix),
        (u !== v || f !== v.version || d !== s.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (u = v),
          (f = v.version),
          (d = s.toneMapping)),
        c.layers.enableAll(),
        M.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function p(M, S) {
    M.getRGB(Ya, nm(s)), n.buffers.color.setClear(Ya.r, Ya.g, Ya.b, S, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (M, S = 1) {
      a.set(M), (l = S), p(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (M) {
      (l = M), p(a, l);
    },
    render: g,
    addToRenderList: m,
  };
}
function hy(s, e) {
  const t = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    n = {},
    i = f(null);
  let r = i,
    o = !1;
  function a(x, P, I, O, k) {
    let G = !1;
    const z = u(O, I, P);
    r !== z && ((r = z), c(r.object)),
      (G = d(x, O, I, k)),
      G && _(x, O, I, k),
      k !== null && e.update(k, s.ELEMENT_ARRAY_BUFFER),
      (G || o) &&
        ((o = !1),
        v(x, P, I, O),
        k !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(k).buffer));
  }
  function l() {
    return s.createVertexArray();
  }
  function c(x) {
    return s.bindVertexArray(x);
  }
  function h(x) {
    return s.deleteVertexArray(x);
  }
  function u(x, P, I) {
    const O = I.wireframe === !0;
    let k = n[x.id];
    k === void 0 && ((k = {}), (n[x.id] = k));
    let G = k[P.id];
    G === void 0 && ((G = {}), (k[P.id] = G));
    let z = G[O];
    return z === void 0 && ((z = f(l())), (G[O] = z)), z;
  }
  function f(x) {
    const P = [],
      I = [],
      O = [];
    for (let k = 0; k < t; k++) (P[k] = 0), (I[k] = 0), (O[k] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: P,
      enabledAttributes: I,
      attributeDivisors: O,
      object: x,
      attributes: {},
      index: null,
    };
  }
  function d(x, P, I, O) {
    const k = r.attributes,
      G = P.attributes;
    let z = 0;
    const q = I.getAttributes();
    for (const H in q)
      if (q[H].location >= 0) {
        const D = k[H];
        let oe = G[H];
        if (
          (oe === void 0 &&
            (H === "instanceMatrix" &&
              x.instanceMatrix &&
              (oe = x.instanceMatrix),
            H === "instanceColor" && x.instanceColor && (oe = x.instanceColor)),
          D === void 0 || D.attribute !== oe || (oe && D.data !== oe.data))
        )
          return !0;
        z++;
      }
    return r.attributesNum !== z || r.index !== O;
  }
  function _(x, P, I, O) {
    const k = {},
      G = P.attributes;
    let z = 0;
    const q = I.getAttributes();
    for (const H in q)
      if (q[H].location >= 0) {
        let D = G[H];
        D === void 0 &&
          (H === "instanceMatrix" && x.instanceMatrix && (D = x.instanceMatrix),
          H === "instanceColor" && x.instanceColor && (D = x.instanceColor));
        const oe = {};
        (oe.attribute = D), D && D.data && (oe.data = D.data), (k[H] = oe), z++;
      }
    (r.attributes = k), (r.attributesNum = z), (r.index = O);
  }
  function g() {
    const x = r.newAttributes;
    for (let P = 0, I = x.length; P < I; P++) x[P] = 0;
  }
  function m(x) {
    p(x, 0);
  }
  function p(x, P) {
    const I = r.newAttributes,
      O = r.enabledAttributes,
      k = r.attributeDivisors;
    (I[x] = 1),
      O[x] === 0 && (s.enableVertexAttribArray(x), (O[x] = 1)),
      k[x] !== P && (s.vertexAttribDivisor(x, P), (k[x] = P));
  }
  function M() {
    const x = r.newAttributes,
      P = r.enabledAttributes;
    for (let I = 0, O = P.length; I < O; I++)
      P[I] !== x[I] && (s.disableVertexAttribArray(I), (P[I] = 0));
  }
  function S(x, P, I, O, k, G, z) {
    z === !0
      ? s.vertexAttribIPointer(x, P, I, k, G)
      : s.vertexAttribPointer(x, P, I, O, k, G);
  }
  function v(x, P, I, O) {
    g();
    const k = O.attributes,
      G = I.getAttributes(),
      z = P.defaultAttributeValues;
    for (const q in G) {
      const H = G[q];
      if (H.location >= 0) {
        let ee = k[q];
        if (
          (ee === void 0 &&
            (q === "instanceMatrix" &&
              x.instanceMatrix &&
              (ee = x.instanceMatrix),
            q === "instanceColor" && x.instanceColor && (ee = x.instanceColor)),
          ee !== void 0)
        ) {
          const D = ee.normalized,
            oe = ee.itemSize,
            Me = e.get(ee);
          if (Me === void 0) continue;
          const Ue = Me.buffer,
            K = Me.type,
            te = Me.bytesPerElement,
            ge = K === s.INT || K === s.UNSIGNED_INT || ee.gpuType === Au;
          if (ee.isInterleavedBufferAttribute) {
            const ne = ee.data,
              Ee = ne.stride,
              we = ee.offset;
            if (ne.isInstancedInterleavedBuffer) {
              for (let Ve = 0; Ve < H.locationSize; Ve++)
                p(H.location + Ve, ne.meshPerAttribute);
              x.isInstancedMesh !== !0 &&
                O._maxInstanceCount === void 0 &&
                (O._maxInstanceCount = ne.meshPerAttribute * ne.count);
            } else
              for (let Ve = 0; Ve < H.locationSize; Ve++) m(H.location + Ve);
            s.bindBuffer(s.ARRAY_BUFFER, Ue);
            for (let Ve = 0; Ve < H.locationSize; Ve++)
              S(
                H.location + Ve,
                oe / H.locationSize,
                K,
                D,
                Ee * te,
                (we + (oe / H.locationSize) * Ve) * te,
                ge
              );
          } else {
            if (ee.isInstancedBufferAttribute) {
              for (let ne = 0; ne < H.locationSize; ne++)
                p(H.location + ne, ee.meshPerAttribute);
              x.isInstancedMesh !== !0 &&
                O._maxInstanceCount === void 0 &&
                (O._maxInstanceCount = ee.meshPerAttribute * ee.count);
            } else
              for (let ne = 0; ne < H.locationSize; ne++) m(H.location + ne);
            s.bindBuffer(s.ARRAY_BUFFER, Ue);
            for (let ne = 0; ne < H.locationSize; ne++)
              S(
                H.location + ne,
                oe / H.locationSize,
                K,
                D,
                oe * te,
                (oe / H.locationSize) * ne * te,
                ge
              );
          }
        } else if (z !== void 0) {
          const D = z[q];
          if (D !== void 0)
            switch (D.length) {
              case 2:
                s.vertexAttrib2fv(H.location, D);
                break;
              case 3:
                s.vertexAttrib3fv(H.location, D);
                break;
              case 4:
                s.vertexAttrib4fv(H.location, D);
                break;
              default:
                s.vertexAttrib1fv(H.location, D);
            }
        }
      }
    }
    M();
  }
  function C() {
    A();
    for (const x in n) {
      const P = n[x];
      for (const I in P) {
        const O = P[I];
        for (const k in O) h(O[k].object), delete O[k];
        delete P[I];
      }
      delete n[x];
    }
  }
  function w(x) {
    if (n[x.id] === void 0) return;
    const P = n[x.id];
    for (const I in P) {
      const O = P[I];
      for (const k in O) h(O[k].object), delete O[k];
      delete P[I];
    }
    delete n[x.id];
  }
  function E(x) {
    for (const P in n) {
      const I = n[P];
      if (I[x.id] === void 0) continue;
      const O = I[x.id];
      for (const k in O) h(O[k].object), delete O[k];
      delete I[x.id];
    }
  }
  function A() {
    y(), (o = !0), r !== i && ((r = i), c(r.object));
  }
  function y() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: a,
    reset: A,
    resetDefaultState: y,
    dispose: C,
    releaseStatesOfGeometry: w,
    releaseStatesOfProgram: E,
    initAttributes: g,
    enableAttribute: m,
    disableUnusedAttributes: M,
  };
}
function uy(s, e, t) {
  let n;
  function i(c) {
    n = c;
  }
  function r(c, h) {
    s.drawArrays(n, c, h), t.update(h, n, 1);
  }
  function o(c, h, u) {
    u !== 0 && (s.drawArraysInstanced(n, c, h, u), t.update(h, n, u));
  }
  function a(c, h, u) {
    if (u === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, u);
    let d = 0;
    for (let _ = 0; _ < u; _++) d += h[_];
    t.update(d, n, 1);
  }
  function l(c, h, u, f) {
    if (u === 0) return;
    const d = e.get("WEBGL_multi_draw");
    if (d === null) for (let _ = 0; _ < c.length; _++) o(c[_], h[_], f[_]);
    else {
      d.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, f, 0, u);
      let _ = 0;
      for (let g = 0; g < u; g++) _ += h[g] * f[g];
      t.update(_, n, 1);
    }
  }
  (this.setMode = i),
    (this.render = r),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l);
}
function fy(s, e, t, n) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const E = e.get("EXT_texture_filter_anisotropic");
      i = s.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function o(E) {
    return !(
      E !== si &&
      n.convert(E) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(E) {
    const A =
      E === Kn &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      E !== or &&
      n.convert(E) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) &&
      E !== Dn &&
      !A
    );
  }
  function l(E) {
    if (E === "highp") {
      if (
        s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision >
          0 &&
        s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      E = "mediump";
    }
    return E === "mediump" &&
      s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision >
        0 &&
      s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const h = l(c);
  h !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      h,
      "instead."
    ),
    (c = h));
  const u = t.logarithmicDepthBuffer === !0,
    f = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    d = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
    _ = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    g = s.getParameter(s.MAX_TEXTURE_SIZE),
    m = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
    p = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    M = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
    S = s.getParameter(s.MAX_VARYING_VECTORS),
    v = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
    C = _ > 0,
    w = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: r,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: u,
    reverseDepthBuffer: f,
    maxTextures: d,
    maxVertexTextures: _,
    maxTextureSize: g,
    maxCubemapSize: m,
    maxAttributes: p,
    maxVertexUniforms: M,
    maxVaryings: S,
    maxFragmentUniforms: v,
    vertexTextures: C,
    maxSamples: w,
  };
}
function dy(s) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    r = !1;
  const o = new yr(),
    a = new $e(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (u, f) {
      const d = u.length !== 0 || f || n !== 0 || i;
      return (i = f), (n = u.length), d;
    }),
    (this.beginShadows = function () {
      (r = !0), h(null);
    }),
    (this.endShadows = function () {
      r = !1;
    }),
    (this.setGlobalState = function (u, f) {
      t = h(u, f, 0);
    }),
    (this.setState = function (u, f, d) {
      const _ = u.clippingPlanes,
        g = u.clipIntersection,
        m = u.clipShadows,
        p = s.get(u);
      if (!i || _ === null || _.length === 0 || (r && !m)) r ? h(null) : c();
      else {
        const M = r ? 0 : n,
          S = M * 4;
        let v = p.clippingState || null;
        (l.value = v), (v = h(_, f, S, d));
        for (let C = 0; C !== S; ++C) v[C] = t[C];
        (p.clippingState = v),
          (this.numIntersection = g ? this.numPlanes : 0),
          (this.numPlanes += M);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function h(u, f, d, _) {
    const g = u !== null ? u.length : 0;
    let m = null;
    if (g !== 0) {
      if (((m = l.value), _ !== !0 || m === null)) {
        const p = d + g * 4,
          M = f.matrixWorldInverse;
        a.getNormalMatrix(M),
          (m === null || m.length < p) && (m = new Float32Array(p));
        for (let S = 0, v = d; S !== g; ++S, v += 4)
          o.copy(u[S]).applyMatrix4(M, a),
            o.normal.toArray(m, v),
            (m[v + 3] = o.constant);
      }
      (l.value = m), (l.needsUpdate = !0);
    }
    return (e.numPlanes = g), (e.numIntersection = 0), m;
  }
}
function py(s) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Il ? (o.mapping = io) : a === vh && (o.mapping = ro), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Il || a === vh)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new b0(l.height);
            return (
              c.fromEquirectangularTexture(s, o),
              e.set(o, c),
              o.addEventListener("dispose", i),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function r() {
    e = new WeakMap();
  }
  return { get: n, dispose: r };
}
class ec extends im {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = r),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, r, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let r = n - e,
      o = n + e,
      a = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += c * this.view.offsetX),
        (o = r + c * this.view.width),
        (a -= h * this.view.offsetY),
        (l = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      r,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const Hs = 4,
  jf = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Zr = 20,
  Pc = new ec(),
  Kf = new He();
let Dc = null,
  Lc = 0,
  Ic = 0,
  Uc = !1;
const Yr = (1 + Math.sqrt(5)) / 2,
  Is = 1 / Yr,
  $f = [
    new F(-Yr, Is, 0),
    new F(Yr, Is, 0),
    new F(-Is, 0, Yr),
    new F(Is, 0, Yr),
    new F(0, Yr, -Is),
    new F(0, Yr, Is),
    new F(-1, 1, -1),
    new F(1, 1, -1),
    new F(-1, 1, 1),
    new F(1, 1, 1),
  ];
class Zf {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (Dc = this._renderer.getRenderTarget()),
      (Lc = this._renderer.getActiveCubeFace()),
      (Ic = this._renderer.getActiveMipmapLevel()),
      (Uc = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const r = this._allocateTargets();
    return (
      (r.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, r),
      t > 0 && this._blur(r, 0, 0, t),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = ed()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Qf()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Dc, Lc, Ic),
      (this._renderer.xr.enabled = Uc),
      (e.scissorTest = !1),
      qa(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === io || e.mapping === ro
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Dc = this._renderer.getRenderTarget()),
      (Lc = this._renderer.getActiveCubeFace()),
      (Ic = this._renderer.getActiveMipmapLevel()),
      (Uc = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: tn,
        minFilter: tn,
        generateMipmaps: !1,
        type: Kn,
        format: si,
        colorSpace: pn,
        depthBuffer: !1,
      },
      i = Jf(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Jf(e, t, n));
      const { _lodMax: r } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = my(r)),
        (this._blurMaterial = _y(r, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Ln(this._lodPlanes[0], e);
    this._renderer.compile(t, Pc);
  }
  _sceneToCubeUV(e, t, n, i) {
    const a = new Tn(90, 1, t, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      u = h.autoClear,
      f = h.toneMapping;
    h.getClearColor(Kf), (h.toneMapping = Cr), (h.autoClear = !1);
    const d = new Sr({
        name: "PMREM.Background",
        side: Un,
        depthWrite: !1,
        depthTest: !1,
      }),
      _ = new Ln(new Ea(), d);
    let g = !1;
    const m = e.background;
    m
      ? m.isColor && (d.color.copy(m), (e.background = null), (g = !0))
      : (d.color.copy(Kf), (g = !0));
    for (let p = 0; p < 6; p++) {
      const M = p % 3;
      M === 0
        ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0))
        : M === 1
        ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0))
        : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
      const S = this._cubeSize;
      qa(i, M * S, p > 2 ? S : 0, S, S),
        h.setRenderTarget(i),
        g && h.render(_, a),
        h.render(e, a);
    }
    _.geometry.dispose(),
      _.material.dispose(),
      (h.toneMapping = f),
      (h.autoClear = u),
      (e.background = m);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === io || e.mapping === ro;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = ed()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Qf());
    const r = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new Ln(this._lodPlanes[0], r),
      a = r.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    qa(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, Pc);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let r = 1; r < i; r++) {
      const o = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        a = $f[(i - r - 1) % $f.length];
      this._blur(e, r - 1, r, o, a);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, n, i, "latitudinal", r),
      this._halfBlur(o, e, n, n, i, "longitudinal", r);
  }
  _halfBlur(e, t, n, i, r, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      u = new Ln(this._lodPlanes[i], c),
      f = c.uniforms,
      d = this._sizeLods[n] - 1,
      _ = isFinite(r) ? Math.PI / (2 * d) : (2 * Math.PI) / (2 * Zr - 1),
      g = r / _,
      m = isFinite(r) ? 1 + Math.floor(h * g) : Zr;
    m > Zr &&
      console.warn(
        `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Zr}`
      );
    const p = [];
    let M = 0;
    for (let E = 0; E < Zr; ++E) {
      const A = E / g,
        y = Math.exp((-A * A) / 2);
      p.push(y), E === 0 ? (M += y) : E < m && (M += 2 * y);
    }
    for (let E = 0; E < p.length; E++) p[E] = p[E] / M;
    (f.envMap.value = e.texture),
      (f.samples.value = m),
      (f.weights.value = p),
      (f.latitudinal.value = o === "latitudinal"),
      a && (f.poleAxis.value = a);
    const { _lodMax: S } = this;
    (f.dTheta.value = _), (f.mipInt.value = S - n);
    const v = this._sizeLods[i],
      C = 3 * v * (i > S - Hs ? i - S + Hs : 0),
      w = 4 * (this._cubeSize - v);
    qa(t, C, w, 3 * v, 2 * v), l.setRenderTarget(t), l.render(u, Pc);
  }
}
function my(s) {
  const e = [],
    t = [],
    n = [];
  let i = s;
  const r = s - Hs + 1 + jf.length;
  for (let o = 0; o < r; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let l = 1 / a;
    o > s - Hs ? (l = jf[o - s + Hs - 1]) : o === 0 && (l = 0), n.push(l);
    const c = 1 / (a - 2),
      h = -c,
      u = 1 + c,
      f = [h, h, u, h, u, u, h, h, u, u, h, u],
      d = 6,
      _ = 6,
      g = 3,
      m = 2,
      p = 1,
      M = new Float32Array(g * _ * d),
      S = new Float32Array(m * _ * d),
      v = new Float32Array(p * _ * d);
    for (let w = 0; w < d; w++) {
      const E = ((w % 3) * 2) / 3 - 1,
        A = w > 2 ? 0 : -1,
        y = [
          E,
          A,
          0,
          E + 2 / 3,
          A,
          0,
          E + 2 / 3,
          A + 1,
          0,
          E,
          A,
          0,
          E + 2 / 3,
          A + 1,
          0,
          E,
          A + 1,
          0,
        ];
      M.set(y, g * _ * w), S.set(f, m * _ * w);
      const x = [w, w, w, w, w, w];
      v.set(x, p * _ * w);
    }
    const C = new Mi();
    C.setAttribute("position", new Rn(M, g)),
      C.setAttribute("uv", new Rn(S, m)),
      C.setAttribute("faceIndex", new Rn(v, p)),
      e.push(C),
      i > Hs && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Jf(s, e, t) {
  const n = new xi(s, e, t);
  return (
    (n.texture.mapping = Zl),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function qa(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function _y(s, e, t) {
  const n = new Float32Array(Zr),
    i = new F(0, 1, 0);
  return new In({
    name: "SphericalGaussianBlur",
    defines: {
      n: Zr,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Nu(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: nr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Qf() {
  return new In({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Nu(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: nr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ed() {
  return new In({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Nu(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: nr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Nu() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function gy(s) {
  let e = new WeakMap(),
    t = null;
  function n(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === Il || l === vh,
        h = l === io || l === ro;
      if (c || h) {
        let u = e.get(a);
        const f = u !== void 0 ? u.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== f)
          return (
            t === null && (t = new Zf(s)),
            (u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u)),
            (u.texture.pmremVersion = a.pmremVersion),
            e.set(a, u),
            u.texture
          );
        if (u !== void 0) return u.texture;
        {
          const d = a.image;
          return (c && d && d.height > 0) || (h && d && i(d))
            ? (t === null && (t = new Zf(s)),
              (u = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (u.texture.pmremVersion = a.pmremVersion),
              e.set(a, u),
              a.addEventListener("dispose", r),
              u.texture)
            : null;
        }
      }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
    return l === c;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: o };
}
function vy(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          s.getExtension("WEBGL_depth_texture") ||
          s.getExtension("MOZ_WEBGL_depth_texture") ||
          s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          s.getExtension("EXT_texture_filter_anisotropic") ||
          s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          s.getExtension("WEBGL_compressed_texture_s3tc") ||
          s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          s.getExtension("WEBGL_compressed_texture_pvrtc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          ko("THREE.WebGLRenderer: " + n + " extension not supported."),
        i
      );
    },
  };
}
function xy(s, e, t, n) {
  const i = {},
    r = new WeakMap();
  function o(u) {
    const f = u.target;
    f.index !== null && e.remove(f.index);
    for (const _ in f.attributes) e.remove(f.attributes[_]);
    for (const _ in f.morphAttributes) {
      const g = f.morphAttributes[_];
      for (let m = 0, p = g.length; m < p; m++) e.remove(g[m]);
    }
    f.removeEventListener("dispose", o), delete i[f.id];
    const d = r.get(f);
    d && (e.remove(d), r.delete(f)),
      n.releaseStatesOfGeometry(f),
      f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(u, f) {
    return (
      i[f.id] === !0 ||
        (f.addEventListener("dispose", o),
        (i[f.id] = !0),
        t.memory.geometries++),
      f
    );
  }
  function l(u) {
    const f = u.attributes;
    for (const _ in f) e.update(f[_], s.ARRAY_BUFFER);
    const d = u.morphAttributes;
    for (const _ in d) {
      const g = d[_];
      for (let m = 0, p = g.length; m < p; m++) e.update(g[m], s.ARRAY_BUFFER);
    }
  }
  function c(u) {
    const f = [],
      d = u.index,
      _ = u.attributes.position;
    let g = 0;
    if (d !== null) {
      const M = d.array;
      g = d.version;
      for (let S = 0, v = M.length; S < v; S += 3) {
        const C = M[S + 0],
          w = M[S + 1],
          E = M[S + 2];
        f.push(C, w, w, E, E, C);
      }
    } else if (_ !== void 0) {
      const M = _.array;
      g = _.version;
      for (let S = 0, v = M.length / 3 - 1; S < v; S += 3) {
        const C = S + 0,
          w = S + 1,
          E = S + 2;
        f.push(C, w, w, E, E, C);
      }
    } else return;
    const m = new (Kp(f) ? tm : em)(f, 1);
    m.version = g;
    const p = r.get(u);
    p && e.remove(p), r.set(u, m);
  }
  function h(u) {
    const f = r.get(u);
    if (f) {
      const d = u.index;
      d !== null && f.version < d.version && c(u);
    } else c(u);
    return r.get(u);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function yy(s, e, t) {
  let n;
  function i(f) {
    n = f;
  }
  let r, o;
  function a(f) {
    (r = f.type), (o = f.bytesPerElement);
  }
  function l(f, d) {
    s.drawElements(n, d, r, f * o), t.update(d, n, 1);
  }
  function c(f, d, _) {
    _ !== 0 && (s.drawElementsInstanced(n, d, r, f * o, _), t.update(d, n, _));
  }
  function h(f, d, _) {
    if (_ === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, d, 0, r, f, 0, _);
    let m = 0;
    for (let p = 0; p < _; p++) m += d[p];
    t.update(m, n, 1);
  }
  function u(f, d, _, g) {
    if (_ === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let p = 0; p < f.length; p++) c(f[p] / o, d[p], g[p]);
    else {
      m.multiDrawElementsInstancedWEBGL(n, d, 0, r, f, 0, g, 0, _);
      let p = 0;
      for (let M = 0; M < _; M++) p += d[M] * g[M];
      t.update(p, n, 1);
    }
  }
  (this.setMode = i),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = h),
    (this.renderMultiDrawInstances = u);
}
function My(s) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(r, o, a) {
    switch ((t.calls++, o)) {
      case s.TRIANGLES:
        t.triangles += a * (r / 3);
        break;
      case s.LINES:
        t.lines += a * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += a * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += a * r;
        break;
      case s.POINTS:
        t.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function Sy(s, e, t) {
  const n = new WeakMap(),
    i = new ft();
  function r(o, a, l) {
    const c = o.morphTargetInfluences,
      h =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      u = h !== void 0 ? h.length : 0;
    let f = n.get(a);
    if (f === void 0 || f.count !== u) {
      let x = function () {
        A.dispose(), n.delete(a), a.removeEventListener("dispose", x);
      };
      var d = x;
      f !== void 0 && f.texture.dispose();
      const _ = a.morphAttributes.position !== void 0,
        g = a.morphAttributes.normal !== void 0,
        m = a.morphAttributes.color !== void 0,
        p = a.morphAttributes.position || [],
        M = a.morphAttributes.normal || [],
        S = a.morphAttributes.color || [];
      let v = 0;
      _ === !0 && (v = 1), g === !0 && (v = 2), m === !0 && (v = 3);
      let C = a.attributes.position.count * v,
        w = 1;
      C > e.maxTextureSize &&
        ((w = Math.ceil(C / e.maxTextureSize)), (C = e.maxTextureSize));
      const E = new Float32Array(C * w * 4 * u),
        A = new Zp(E, C, w, u);
      (A.type = Dn), (A.needsUpdate = !0);
      const y = v * 4;
      for (let P = 0; P < u; P++) {
        const I = p[P],
          O = M[P],
          k = S[P],
          G = C * w * 4 * P;
        for (let z = 0; z < I.count; z++) {
          const q = z * y;
          _ === !0 &&
            (i.fromBufferAttribute(I, z),
            (E[G + q + 0] = i.x),
            (E[G + q + 1] = i.y),
            (E[G + q + 2] = i.z),
            (E[G + q + 3] = 0)),
            g === !0 &&
              (i.fromBufferAttribute(O, z),
              (E[G + q + 4] = i.x),
              (E[G + q + 5] = i.y),
              (E[G + q + 6] = i.z),
              (E[G + q + 7] = 0)),
            m === !0 &&
              (i.fromBufferAttribute(k, z),
              (E[G + q + 8] = i.x),
              (E[G + q + 9] = i.y),
              (E[G + q + 10] = i.z),
              (E[G + q + 11] = k.itemSize === 4 ? i.w : 1));
        }
      }
      (f = { count: u, texture: A, size: new De(C, w) }),
        n.set(a, f),
        a.addEventListener("dispose", x);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
    else {
      let _ = 0;
      for (let m = 0; m < c.length; m++) _ += c[m];
      const g = a.morphTargetsRelative ? 1 : 1 - _;
      l.getUniforms().setValue(s, "morphTargetBaseInfluence", g),
        l.getUniforms().setValue(s, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(s, "morphTargetsTexture", f.texture, t),
      l.getUniforms().setValue(s, "morphTargetsTextureSize", f.size);
  }
  return { update: r };
}
function Ty(s, e, t, n) {
  let i = new WeakMap();
  function r(l) {
    const c = n.render.frame,
      h = l.geometry,
      u = e.get(l, h);
    if (
      (i.get(u) !== c && (e.update(u), i.set(u, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        i.get(l) !== c &&
          (t.update(l.instanceMatrix, s.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER),
          i.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const f = l.skeleton;
      i.get(f) !== c && (f.update(), i.set(f, c));
    }
    return u;
  }
  function o() {
    i = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: r, dispose: o };
}
class om extends nn {
  constructor(e, t, n, i, r, o, a, l, c, h = qs) {
    if (h !== qs && h !== ao)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && h === qs && (n = cs),
      n === void 0 && h === ao && (n = oo),
      super(null, i, r, o, a, l, h, n, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : wn),
      (this.minFilter = l !== void 0 ? l : wn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const am = new nn(),
  td = new om(1, 1),
  lm = new Zp(),
  cm = new a0(),
  hm = new rm(),
  nd = [],
  id = [],
  rd = new Float32Array(16),
  sd = new Float32Array(9),
  od = new Float32Array(4);
function Mo(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0) return s;
  const i = e * t;
  let r = nd[i];
  if ((r === void 0 && ((r = new Float32Array(i)), (nd[i] = r)), e !== 0)) {
    n.toArray(r, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), s[o].toArray(r, a);
  }
  return r;
}
function jt(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
  return !0;
}
function Kt(s, e) {
  for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
}
function tc(s, e) {
  let t = id[e];
  t === void 0 && ((t = new Int32Array(e)), (id[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
  return t;
}
function Ey(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
}
function by(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (jt(t, e)) return;
    s.uniform2fv(this.addr, e), Kt(t, e);
  }
}
function Ay(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (s.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (jt(t, e)) return;
    s.uniform3fv(this.addr, e), Kt(t, e);
  }
}
function wy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (jt(t, e)) return;
    s.uniform4fv(this.addr, e), Kt(t, e);
  }
}
function Ry(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (jt(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), Kt(t, e);
  } else {
    if (jt(t, n)) return;
    od.set(n), s.uniformMatrix2fv(this.addr, !1, od), Kt(t, n);
  }
}
function Cy(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (jt(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), Kt(t, e);
  } else {
    if (jt(t, n)) return;
    sd.set(n), s.uniformMatrix3fv(this.addr, !1, sd), Kt(t, n);
  }
}
function Py(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (jt(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), Kt(t, e);
  } else {
    if (jt(t, n)) return;
    rd.set(n), s.uniformMatrix4fv(this.addr, !1, rd), Kt(t, n);
  }
}
function Dy(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
}
function Ly(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (jt(t, e)) return;
    s.uniform2iv(this.addr, e), Kt(t, e);
  }
}
function Iy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (jt(t, e)) return;
    s.uniform3iv(this.addr, e), Kt(t, e);
  }
}
function Uy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (jt(t, e)) return;
    s.uniform4iv(this.addr, e), Kt(t, e);
  }
}
function Ny(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
}
function Oy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (jt(t, e)) return;
    s.uniform2uiv(this.addr, e), Kt(t, e);
  }
}
function Fy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (jt(t, e)) return;
    s.uniform3uiv(this.addr, e), Kt(t, e);
  }
}
function By(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (jt(t, e)) return;
    s.uniform4uiv(this.addr, e), Kt(t, e);
  }
}
function ky(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i));
  let r;
  this.type === s.SAMPLER_2D_SHADOW
    ? ((td.compareFunction = qp), (r = td))
    : (r = am),
    t.setTexture2D(e || r, i);
}
function zy(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || cm, i);
}
function Hy(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || hm, i);
}
function Vy(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || lm, i);
}
function Gy(s) {
  switch (s) {
    case 5126:
      return Ey;
    case 35664:
      return by;
    case 35665:
      return Ay;
    case 35666:
      return wy;
    case 35674:
      return Ry;
    case 35675:
      return Cy;
    case 35676:
      return Py;
    case 5124:
    case 35670:
      return Dy;
    case 35667:
    case 35671:
      return Ly;
    case 35668:
    case 35672:
      return Iy;
    case 35669:
    case 35673:
      return Uy;
    case 5125:
      return Ny;
    case 36294:
      return Oy;
    case 36295:
      return Fy;
    case 36296:
      return By;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return ky;
    case 35679:
    case 36299:
    case 36307:
      return zy;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Hy;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Vy;
  }
}
function Wy(s, e) {
  s.uniform1fv(this.addr, e);
}
function Xy(s, e) {
  const t = Mo(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function Yy(s, e) {
  const t = Mo(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function qy(s, e) {
  const t = Mo(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function jy(s, e) {
  const t = Mo(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function Ky(s, e) {
  const t = Mo(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function $y(s, e) {
  const t = Mo(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function Zy(s, e) {
  s.uniform1iv(this.addr, e);
}
function Jy(s, e) {
  s.uniform2iv(this.addr, e);
}
function Qy(s, e) {
  s.uniform3iv(this.addr, e);
}
function eM(s, e) {
  s.uniform4iv(this.addr, e);
}
function tM(s, e) {
  s.uniform1uiv(this.addr, e);
}
function nM(s, e) {
  s.uniform2uiv(this.addr, e);
}
function iM(s, e) {
  s.uniform3uiv(this.addr, e);
}
function rM(s, e) {
  s.uniform4uiv(this.addr, e);
}
function sM(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = tc(t, i);
  jt(n, r) || (s.uniform1iv(this.addr, r), Kt(n, r));
  for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || am, r[o]);
}
function oM(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = tc(t, i);
  jt(n, r) || (s.uniform1iv(this.addr, r), Kt(n, r));
  for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || cm, r[o]);
}
function aM(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = tc(t, i);
  jt(n, r) || (s.uniform1iv(this.addr, r), Kt(n, r));
  for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || hm, r[o]);
}
function lM(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = tc(t, i);
  jt(n, r) || (s.uniform1iv(this.addr, r), Kt(n, r));
  for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || lm, r[o]);
}
function cM(s) {
  switch (s) {
    case 5126:
      return Wy;
    case 35664:
      return Xy;
    case 35665:
      return Yy;
    case 35666:
      return qy;
    case 35674:
      return jy;
    case 35675:
      return Ky;
    case 35676:
      return $y;
    case 5124:
    case 35670:
      return Zy;
    case 35667:
    case 35671:
      return Jy;
    case 35668:
    case 35672:
      return Qy;
    case 35669:
    case 35673:
      return eM;
    case 5125:
      return tM;
    case 36294:
      return nM;
    case 36295:
      return iM;
    case 36296:
      return rM;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return sM;
    case 35679:
    case 36299:
    case 36307:
      return oM;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return aM;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return lM;
  }
}
class hM {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = Gy(t.type));
  }
}
class uM {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = cM(t.type));
  }
}
class fM {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let r = 0, o = i.length; r !== o; ++r) {
      const a = i[r];
      a.setValue(e, t[a.id], n);
    }
  }
}
const Nc = /(\w+)(\])?(\[|\.)?/g;
function ad(s, e) {
  s.seq.push(e), (s.map[e.id] = e);
}
function dM(s, e, t) {
  const n = s.name,
    i = n.length;
  for (Nc.lastIndex = 0; ; ) {
    const r = Nc.exec(n),
      o = Nc.lastIndex;
    let a = r[1];
    const l = r[2] === "]",
      c = r[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
      ad(t, c === void 0 ? new hM(a, s, e) : new uM(a, s, e));
      break;
    } else {
      let u = t.map[a];
      u === void 0 && ((u = new fM(a)), ad(t, u)), (t = u);
    }
  }
}
class Tl {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const r = e.getActiveUniform(t, i),
        o = e.getUniformLocation(t, r.name);
      dM(r, o, this);
    }
  }
  setValue(e, t, n, i) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let r = 0, o = t.length; r !== o; ++r) {
      const a = t[r],
        l = n[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const o = e[i];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function ld(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
const pM = 37297;
let mM = 0;
function _M(s, e) {
  const t = s.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    r = Math.min(e + 6, t.length);
  for (let o = i; o < r; o++) {
    const a = o + 1;
    n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return n.join(`
`);
}
const cd = new $e();
function gM(s) {
  at._getMatrix(cd, at.workingColorSpace, s);
  const e = `mat3( ${cd.elements.map((t) => t.toFixed(4))} )`;
  switch (at.getTransfer(s)) {
    case Jl:
      return [e, "LinearTransferOETF"];
    case xt:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", s),
        [e, "LinearTransferOETF"]
      );
  }
}
function hd(s, e, t) {
  const n = s.getShaderParameter(e, s.COMPILE_STATUS),
    i = s.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(i);
  if (r) {
    const o = parseInt(r[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      _M(s.getShaderSource(e), o)
    );
  } else return i;
}
function vM(s, e) {
  const t = gM(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function xM(s, e) {
  let t;
  switch (e) {
    case vg:
      t = "Linear";
      break;
    case xg:
      t = "Reinhard";
      break;
    case yg:
      t = "Cineon";
      break;
    case Ip:
      t = "ACESFilmic";
      break;
    case Sg:
      t = "AgX";
      break;
    case Tg:
      t = "Neutral";
      break;
    case Mg:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const ja = new F();
function yM() {
  at.getLuminanceCoefficients(ja);
  const s = ja.x.toFixed(4),
    e = ja.y.toFixed(4),
    t = ja.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function MM(s) {
  return [
    s.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(zo).join(`
`);
}
function SM(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function TM(s, e) {
  const t = {},
    n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i),
      o = r.name;
    let a = 1;
    r.type === s.FLOAT_MAT2 && (a = 2),
      r.type === s.FLOAT_MAT3 && (a = 3),
      r.type === s.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: r.type,
        location: s.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function zo(s) {
  return s !== "";
}
function ud(s, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function fd(s, e) {
  return s
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const EM = /^[ \t]*#include +<([\w\d./]+)>/gm;
function qh(s) {
  return s.replace(EM, AM);
}
const bM = new Map();
function AM(s, e) {
  let t = Je[e];
  if (t === void 0) {
    const n = bM.get(e);
    if (n !== void 0)
      (t = Je[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return qh(t);
}
const wM =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function dd(s) {
  return s.replace(wM, RM);
}
function RM(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function pd(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return (
    s.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : s.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : s.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function CM(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    s.shadowMapType === Dp
      ? (e = "SHADOWMAP_TYPE_PCF")
      : s.shadowMapType === Z_
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : s.shadowMapType === ji && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function PM(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case io:
      case ro:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Zl:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function DM(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case ro:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function LM(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case Lp:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case _g:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case gg:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function IM(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function UM(s, e, t, n) {
  const i = s.getContext(),
    r = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = CM(t),
    c = PM(t),
    h = DM(t),
    u = LM(t),
    f = IM(t),
    d = MM(t),
    _ = SM(r),
    g = i.createProgram();
  let m,
    p,
    M = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((m = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(zo).join(`
`)),
      m.length > 0 &&
        (m += `
`),
      (p = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(zo).join(`
`)),
      p.length > 0 &&
        (p += `
`))
    : ((m = [
        pd(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(zo).join(`
`)),
      (p = [
        pd(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + u : "",
        f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
        f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
        f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Cr ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Cr ? Je.tonemapping_pars_fragment : "",
        t.toneMapping !== Cr ? xM("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Je.colorspace_pars_fragment,
        vM("linearToOutputTexel", t.outputColorSpace),
        yM(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(zo).join(`
`))),
    (o = qh(o)),
    (o = ud(o, t)),
    (o = fd(o, t)),
    (a = qh(a)),
    (a = ud(a, t)),
    (a = fd(a, t)),
    (o = dd(o)),
    (a = dd(a)),
    t.isRawShaderMaterial !== !0 &&
      ((M = `#version 300 es
`),
      (m =
        [
          d,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        m),
      (p =
        [
          "#define varying in",
          t.glslVersion === Af
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Af ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        p));
  const S = M + m + o,
    v = M + p + a,
    C = ld(i, i.VERTEX_SHADER, S),
    w = ld(i, i.FRAGMENT_SHADER, v);
  i.attachShader(g, C),
    i.attachShader(g, w),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(g, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(g, 0, "position"),
    i.linkProgram(g);
  function E(P) {
    if (s.debug.checkShaderErrors) {
      const I = i.getProgramInfoLog(g).trim(),
        O = i.getShaderInfoLog(C).trim(),
        k = i.getShaderInfoLog(w).trim();
      let G = !0,
        z = !0;
      if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
        if (((G = !1), typeof s.debug.onShaderError == "function"))
          s.debug.onShaderError(i, g, C, w);
        else {
          const q = hd(i, C, "vertex"),
            H = hd(i, w, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(g, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              P.name +
              `
Material Type: ` +
              P.type +
              `

Program Info Log: ` +
              I +
              `
` +
              q +
              `
` +
              H
          );
        }
      else
        I !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", I)
          : (O === "" || k === "") && (z = !1);
      z &&
        (P.diagnostics = {
          runnable: G,
          programLog: I,
          vertexShader: { log: O, prefix: m },
          fragmentShader: { log: k, prefix: p },
        });
    }
    i.deleteShader(C), i.deleteShader(w), (A = new Tl(i, g)), (y = TM(i, g));
  }
  let A;
  this.getUniforms = function () {
    return A === void 0 && E(this), A;
  };
  let y;
  this.getAttributes = function () {
    return y === void 0 && E(this), y;
  };
  let x = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return x === !1 && (x = i.getProgramParameter(g, pM)), x;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(g),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = mM++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = C),
    (this.fragmentShader = w),
    this
  );
}
let NM = 0;
class OM {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      r = this._getShaderStage(n),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new FM(e)), t.set(e, n)), n;
  }
}
class FM {
  constructor(e) {
    (this.id = NM++), (this.code = e), (this.usedTimes = 0);
  }
}
function BM(s, e, t, n, i, r, o) {
  const a = new Jp(),
    l = new OM(),
    c = new Set(),
    h = [],
    u = i.logarithmicDepthBuffer,
    f = i.vertexTextures;
  let d = i.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function g(y) {
    return c.add(y), y === 0 ? "uv" : `uv${y}`;
  }
  function m(y, x, P, I, O) {
    const k = I.fog,
      G = O.geometry,
      z = y.isMeshStandardMaterial ? I.environment : null,
      q = (y.isMeshStandardMaterial ? t : e).get(y.envMap || z),
      H = q && q.mapping === Zl ? q.image.height : null,
      ee = _[y.type];
    y.precision !== null &&
      ((d = i.getMaxPrecision(y.precision)),
      d !== y.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          y.precision,
          "not supported, using",
          d,
          "instead."
        ));
    const D =
        G.morphAttributes.position ||
        G.morphAttributes.normal ||
        G.morphAttributes.color,
      oe = D !== void 0 ? D.length : 0;
    let Me = 0;
    G.morphAttributes.position !== void 0 && (Me = 1),
      G.morphAttributes.normal !== void 0 && (Me = 2),
      G.morphAttributes.color !== void 0 && (Me = 3);
    let Ue, K, te, ge;
    if (ee) {
      const ve = bi[ee];
      (Ue = ve.vertexShader), (K = ve.fragmentShader);
    } else
      (Ue = y.vertexShader),
        (K = y.fragmentShader),
        l.update(y),
        (te = l.getVertexShaderID(y)),
        (ge = l.getFragmentShaderID(y));
    const ne = s.getRenderTarget(),
      Ee = s.state.buffers.depth.getReversed(),
      we = O.isInstancedMesh === !0,
      Ve = O.isBatchedMesh === !0,
      Qe = !!y.map,
      Ge = !!y.matcap,
      Le = !!q,
      U = !!y.aoMap,
      Mt = !!y.lightMap,
      Fe = !!y.bumpMap,
      V = !!y.normalMap,
      be = !!y.displacementMap,
      st = !!y.emissiveMap,
      Re = !!y.metalnessMap,
      R = !!y.roughnessMap,
      T = y.anisotropy > 0,
      Y = y.clearcoat > 0,
      Q = y.dispersion > 0,
      J = y.iridescence > 0,
      $ = y.sheen > 0,
      ue = y.transmission > 0,
      le = T && !!y.anisotropyMap,
      pe = Y && !!y.clearcoatMap,
      Ye = Y && !!y.clearcoatNormalMap,
      ie = Y && !!y.clearcoatRoughnessMap,
      ae = J && !!y.iridescenceMap,
      Ne = J && !!y.iridescenceThicknessMap,
      Ie = $ && !!y.sheenColorMap,
      xe = $ && !!y.sheenRoughnessMap,
      je = !!y.specularMap,
      Oe = !!y.specularColorMap,
      ct = !!y.specularIntensityMap,
      L = ue && !!y.transmissionMap,
      he = ue && !!y.thicknessMap,
      j = !!y.gradientMap,
      Z = !!y.alphaMap,
      ce = y.alphaTest > 0,
      fe = !!y.alphaHash,
      Be = !!y.extensions;
    let ht = Cr;
    y.toneMapped &&
      (ne === null || ne.isXRRenderTarget === !0) &&
      (ht = s.toneMapping);
    const Nt = {
      shaderID: ee,
      shaderType: y.type,
      shaderName: y.name,
      vertexShader: Ue,
      fragmentShader: K,
      defines: y.defines,
      customVertexShaderID: te,
      customFragmentShaderID: ge,
      isRawShaderMaterial: y.isRawShaderMaterial === !0,
      glslVersion: y.glslVersion,
      precision: d,
      batching: Ve,
      batchingColor: Ve && O._colorsTexture !== null,
      instancing: we,
      instancingColor: we && O.instanceColor !== null,
      instancingMorph: we && O.morphTexture !== null,
      supportsVertexTextures: f,
      outputColorSpace:
        ne === null
          ? s.outputColorSpace
          : ne.isXRRenderTarget === !0
          ? ne.texture.colorSpace
          : pn,
      alphaToCoverage: !!y.alphaToCoverage,
      map: Qe,
      matcap: Ge,
      envMap: Le,
      envMapMode: Le && q.mapping,
      envMapCubeUVHeight: H,
      aoMap: U,
      lightMap: Mt,
      bumpMap: Fe,
      normalMap: V,
      displacementMap: f && be,
      emissiveMap: st,
      normalMapObjectSpace: V && y.normalMapType === Cg,
      normalMapTangentSpace: V && y.normalMapType === Yp,
      metalnessMap: Re,
      roughnessMap: R,
      anisotropy: T,
      anisotropyMap: le,
      clearcoat: Y,
      clearcoatMap: pe,
      clearcoatNormalMap: Ye,
      clearcoatRoughnessMap: ie,
      dispersion: Q,
      iridescence: J,
      iridescenceMap: ae,
      iridescenceThicknessMap: Ne,
      sheen: $,
      sheenColorMap: Ie,
      sheenRoughnessMap: xe,
      specularMap: je,
      specularColorMap: Oe,
      specularIntensityMap: ct,
      transmission: ue,
      transmissionMap: L,
      thicknessMap: he,
      gradientMap: j,
      opaque:
        y.transparent === !1 && y.blending === Ys && y.alphaToCoverage === !1,
      alphaMap: Z,
      alphaTest: ce,
      alphaHash: fe,
      combine: y.combine,
      mapUv: Qe && g(y.map.channel),
      aoMapUv: U && g(y.aoMap.channel),
      lightMapUv: Mt && g(y.lightMap.channel),
      bumpMapUv: Fe && g(y.bumpMap.channel),
      normalMapUv: V && g(y.normalMap.channel),
      displacementMapUv: be && g(y.displacementMap.channel),
      emissiveMapUv: st && g(y.emissiveMap.channel),
      metalnessMapUv: Re && g(y.metalnessMap.channel),
      roughnessMapUv: R && g(y.roughnessMap.channel),
      anisotropyMapUv: le && g(y.anisotropyMap.channel),
      clearcoatMapUv: pe && g(y.clearcoatMap.channel),
      clearcoatNormalMapUv: Ye && g(y.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ie && g(y.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ae && g(y.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ne && g(y.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ie && g(y.sheenColorMap.channel),
      sheenRoughnessMapUv: xe && g(y.sheenRoughnessMap.channel),
      specularMapUv: je && g(y.specularMap.channel),
      specularColorMapUv: Oe && g(y.specularColorMap.channel),
      specularIntensityMapUv: ct && g(y.specularIntensityMap.channel),
      transmissionMapUv: L && g(y.transmissionMap.channel),
      thicknessMapUv: he && g(y.thicknessMap.channel),
      alphaMapUv: Z && g(y.alphaMap.channel),
      vertexTangents: !!G.attributes.tangent && (V || T),
      vertexColors: y.vertexColors,
      vertexAlphas:
        y.vertexColors === !0 &&
        !!G.attributes.color &&
        G.attributes.color.itemSize === 4,
      pointsUvs: O.isPoints === !0 && !!G.attributes.uv && (Qe || Z),
      fog: !!k,
      useFog: y.fog === !0,
      fogExp2: !!k && k.isFogExp2,
      flatShading: y.flatShading === !0,
      sizeAttenuation: y.sizeAttenuation === !0,
      logarithmicDepthBuffer: u,
      reverseDepthBuffer: Ee,
      skinning: O.isSkinnedMesh === !0,
      morphTargets: G.morphAttributes.position !== void 0,
      morphNormals: G.morphAttributes.normal !== void 0,
      morphColors: G.morphAttributes.color !== void 0,
      morphTargetsCount: oe,
      morphTextureStride: Me,
      numDirLights: x.directional.length,
      numPointLights: x.point.length,
      numSpotLights: x.spot.length,
      numSpotLightMaps: x.spotLightMap.length,
      numRectAreaLights: x.rectArea.length,
      numHemiLights: x.hemi.length,
      numDirLightShadows: x.directionalShadowMap.length,
      numPointLightShadows: x.pointShadowMap.length,
      numSpotLightShadows: x.spotShadowMap.length,
      numSpotLightShadowsWithMaps: x.numSpotLightShadowsWithMaps,
      numLightProbes: x.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: y.dithering,
      shadowMapEnabled: s.shadowMap.enabled && P.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: ht,
      decodeVideoTexture:
        Qe &&
        y.map.isVideoTexture === !0 &&
        at.getTransfer(y.map.colorSpace) === xt,
      decodeVideoTextureEmissive:
        st &&
        y.emissiveMap.isVideoTexture === !0 &&
        at.getTransfer(y.emissiveMap.colorSpace) === xt,
      premultipliedAlpha: y.premultipliedAlpha,
      doubleSided: y.side === Ai,
      flipSided: y.side === Un,
      useDepthPacking: y.depthPacking >= 0,
      depthPacking: y.depthPacking || 0,
      index0AttributeName: y.index0AttributeName,
      extensionClipCullDistance:
        Be &&
        y.extensions.clipCullDistance === !0 &&
        n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((Be && y.extensions.multiDraw === !0) || Ve) &&
        n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: y.customProgramCacheKey(),
    };
    return (
      (Nt.vertexUv1s = c.has(1)),
      (Nt.vertexUv2s = c.has(2)),
      (Nt.vertexUv3s = c.has(3)),
      c.clear(),
      Nt
    );
  }
  function p(y) {
    const x = [];
    if (
      (y.shaderID
        ? x.push(y.shaderID)
        : (x.push(y.customVertexShaderID), x.push(y.customFragmentShaderID)),
      y.defines !== void 0)
    )
      for (const P in y.defines) x.push(P), x.push(y.defines[P]);
    return (
      y.isRawShaderMaterial === !1 &&
        (M(x, y), S(x, y), x.push(s.outputColorSpace)),
      x.push(y.customProgramCacheKey),
      x.join()
    );
  }
  function M(y, x) {
    y.push(x.precision),
      y.push(x.outputColorSpace),
      y.push(x.envMapMode),
      y.push(x.envMapCubeUVHeight),
      y.push(x.mapUv),
      y.push(x.alphaMapUv),
      y.push(x.lightMapUv),
      y.push(x.aoMapUv),
      y.push(x.bumpMapUv),
      y.push(x.normalMapUv),
      y.push(x.displacementMapUv),
      y.push(x.emissiveMapUv),
      y.push(x.metalnessMapUv),
      y.push(x.roughnessMapUv),
      y.push(x.anisotropyMapUv),
      y.push(x.clearcoatMapUv),
      y.push(x.clearcoatNormalMapUv),
      y.push(x.clearcoatRoughnessMapUv),
      y.push(x.iridescenceMapUv),
      y.push(x.iridescenceThicknessMapUv),
      y.push(x.sheenColorMapUv),
      y.push(x.sheenRoughnessMapUv),
      y.push(x.specularMapUv),
      y.push(x.specularColorMapUv),
      y.push(x.specularIntensityMapUv),
      y.push(x.transmissionMapUv),
      y.push(x.thicknessMapUv),
      y.push(x.combine),
      y.push(x.fogExp2),
      y.push(x.sizeAttenuation),
      y.push(x.morphTargetsCount),
      y.push(x.morphAttributeCount),
      y.push(x.numDirLights),
      y.push(x.numPointLights),
      y.push(x.numSpotLights),
      y.push(x.numSpotLightMaps),
      y.push(x.numHemiLights),
      y.push(x.numRectAreaLights),
      y.push(x.numDirLightShadows),
      y.push(x.numPointLightShadows),
      y.push(x.numSpotLightShadows),
      y.push(x.numSpotLightShadowsWithMaps),
      y.push(x.numLightProbes),
      y.push(x.shadowMapType),
      y.push(x.toneMapping),
      y.push(x.numClippingPlanes),
      y.push(x.numClipIntersection),
      y.push(x.depthPacking);
  }
  function S(y, x) {
    a.disableAll(),
      x.supportsVertexTextures && a.enable(0),
      x.instancing && a.enable(1),
      x.instancingColor && a.enable(2),
      x.instancingMorph && a.enable(3),
      x.matcap && a.enable(4),
      x.envMap && a.enable(5),
      x.normalMapObjectSpace && a.enable(6),
      x.normalMapTangentSpace && a.enable(7),
      x.clearcoat && a.enable(8),
      x.iridescence && a.enable(9),
      x.alphaTest && a.enable(10),
      x.vertexColors && a.enable(11),
      x.vertexAlphas && a.enable(12),
      x.vertexUv1s && a.enable(13),
      x.vertexUv2s && a.enable(14),
      x.vertexUv3s && a.enable(15),
      x.vertexTangents && a.enable(16),
      x.anisotropy && a.enable(17),
      x.alphaHash && a.enable(18),
      x.batching && a.enable(19),
      x.dispersion && a.enable(20),
      x.batchingColor && a.enable(21),
      y.push(a.mask),
      a.disableAll(),
      x.fog && a.enable(0),
      x.useFog && a.enable(1),
      x.flatShading && a.enable(2),
      x.logarithmicDepthBuffer && a.enable(3),
      x.reverseDepthBuffer && a.enable(4),
      x.skinning && a.enable(5),
      x.morphTargets && a.enable(6),
      x.morphNormals && a.enable(7),
      x.morphColors && a.enable(8),
      x.premultipliedAlpha && a.enable(9),
      x.shadowMapEnabled && a.enable(10),
      x.doubleSided && a.enable(11),
      x.flipSided && a.enable(12),
      x.useDepthPacking && a.enable(13),
      x.dithering && a.enable(14),
      x.transmission && a.enable(15),
      x.sheen && a.enable(16),
      x.opaque && a.enable(17),
      x.pointsUvs && a.enable(18),
      x.decodeVideoTexture && a.enable(19),
      x.decodeVideoTextureEmissive && a.enable(20),
      x.alphaToCoverage && a.enable(21),
      y.push(a.mask);
  }
  function v(y) {
    const x = _[y.type];
    let P;
    if (x) {
      const I = bi[x];
      P = Ol.clone(I.uniforms);
    } else P = y.uniforms;
    return P;
  }
  function C(y, x) {
    let P;
    for (let I = 0, O = h.length; I < O; I++) {
      const k = h[I];
      if (k.cacheKey === x) {
        (P = k), ++P.usedTimes;
        break;
      }
    }
    return P === void 0 && ((P = new UM(s, x, y, r)), h.push(P)), P;
  }
  function w(y) {
    if (--y.usedTimes === 0) {
      const x = h.indexOf(y);
      (h[x] = h[h.length - 1]), h.pop(), y.destroy();
    }
  }
  function E(y) {
    l.remove(y);
  }
  function A() {
    l.dispose();
  }
  return {
    getParameters: m,
    getProgramCacheKey: p,
    getUniforms: v,
    acquireProgram: C,
    releaseProgram: w,
    releaseShaderCache: E,
    programs: h,
    dispose: A,
  };
}
function kM() {
  let s = new WeakMap();
  function e(o) {
    return s.has(o);
  }
  function t(o) {
    let a = s.get(o);
    return a === void 0 && ((a = {}), s.set(o, a)), a;
  }
  function n(o) {
    s.delete(o);
  }
  function i(o, a, l) {
    s.get(o)[a] = l;
  }
  function r() {
    s = new WeakMap();
  }
  return { has: e, get: t, remove: n, update: i, dispose: r };
}
function zM(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.material.id !== e.material.id
    ? s.material.id - e.material.id
    : s.z !== e.z
    ? s.z - e.z
    : s.id - e.id;
}
function md(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.z !== e.z
    ? e.z - s.z
    : s.id - e.id;
}
function _d() {
  const s = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function r() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function o(u, f, d, _, g, m) {
    let p = s[e];
    return (
      p === void 0
        ? ((p = {
            id: u.id,
            object: u,
            geometry: f,
            material: d,
            groupOrder: _,
            renderOrder: u.renderOrder,
            z: g,
            group: m,
          }),
          (s[e] = p))
        : ((p.id = u.id),
          (p.object = u),
          (p.geometry = f),
          (p.material = d),
          (p.groupOrder = _),
          (p.renderOrder = u.renderOrder),
          (p.z = g),
          (p.group = m)),
      e++,
      p
    );
  }
  function a(u, f, d, _, g, m) {
    const p = o(u, f, d, _, g, m);
    d.transmission > 0
      ? n.push(p)
      : d.transparent === !0
      ? i.push(p)
      : t.push(p);
  }
  function l(u, f, d, _, g, m) {
    const p = o(u, f, d, _, g, m);
    d.transmission > 0
      ? n.unshift(p)
      : d.transparent === !0
      ? i.unshift(p)
      : t.unshift(p);
  }
  function c(u, f) {
    t.length > 1 && t.sort(u || zM),
      n.length > 1 && n.sort(f || md),
      i.length > 1 && i.sort(f || md);
  }
  function h() {
    for (let u = e, f = s.length; u < f; u++) {
      const d = s[u];
      if (d.id === null) break;
      (d.id = null),
        (d.object = null),
        (d.geometry = null),
        (d.material = null),
        (d.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: a,
    unshift: l,
    finish: h,
    sort: c,
  };
}
function HM() {
  let s = new WeakMap();
  function e(n, i) {
    const r = s.get(n);
    let o;
    return (
      r === void 0
        ? ((o = new _d()), s.set(n, [o]))
        : i >= r.length
        ? ((o = new _d()), r.push(o))
        : (o = r[i]),
      o
    );
  }
  function t() {
    s = new WeakMap();
  }
  return { get: e, dispose: t };
}
function VM() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new F(), color: new He() };
          break;
        case "SpotLight":
          t = {
            position: new F(),
            direction: new F(),
            color: new He(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new F(), color: new He(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new F(), skyColor: new He(), groundColor: new He() };
          break;
        case "RectAreaLight":
          t = {
            color: new He(),
            position: new F(),
            halfWidth: new F(),
            halfHeight: new F(),
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
function GM() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new De(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new De(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new De(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
let WM = 0;
function XM(s, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (s.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (s.map ? 1 : 0)
  );
}
function YM(s) {
  const e = new VM(),
    t = GM(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) n.probe.push(new F());
  const i = new F(),
    r = new Ze(),
    o = new Ze();
  function a(c) {
    let h = 0,
      u = 0,
      f = 0;
    for (let y = 0; y < 9; y++) n.probe[y].set(0, 0, 0);
    let d = 0,
      _ = 0,
      g = 0,
      m = 0,
      p = 0,
      M = 0,
      S = 0,
      v = 0,
      C = 0,
      w = 0,
      E = 0;
    c.sort(XM);
    for (let y = 0, x = c.length; y < x; y++) {
      const P = c[y],
        I = P.color,
        O = P.intensity,
        k = P.distance,
        G = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
      if (P.isAmbientLight) (h += I.r * O), (u += I.g * O), (f += I.b * O);
      else if (P.isLightProbe) {
        for (let z = 0; z < 9; z++)
          n.probe[z].addScaledVector(P.sh.coefficients[z], O);
        E++;
      } else if (P.isDirectionalLight) {
        const z = e.get(P);
        if ((z.color.copy(P.color).multiplyScalar(P.intensity), P.castShadow)) {
          const q = P.shadow,
            H = t.get(P);
          (H.shadowIntensity = q.intensity),
            (H.shadowBias = q.bias),
            (H.shadowNormalBias = q.normalBias),
            (H.shadowRadius = q.radius),
            (H.shadowMapSize = q.mapSize),
            (n.directionalShadow[d] = H),
            (n.directionalShadowMap[d] = G),
            (n.directionalShadowMatrix[d] = P.shadow.matrix),
            M++;
        }
        (n.directional[d] = z), d++;
      } else if (P.isSpotLight) {
        const z = e.get(P);
        z.position.setFromMatrixPosition(P.matrixWorld),
          z.color.copy(I).multiplyScalar(O),
          (z.distance = k),
          (z.coneCos = Math.cos(P.angle)),
          (z.penumbraCos = Math.cos(P.angle * (1 - P.penumbra))),
          (z.decay = P.decay),
          (n.spot[g] = z);
        const q = P.shadow;
        if (
          (P.map &&
            ((n.spotLightMap[C] = P.map),
            C++,
            q.updateMatrices(P),
            P.castShadow && w++),
          (n.spotLightMatrix[g] = q.matrix),
          P.castShadow)
        ) {
          const H = t.get(P);
          (H.shadowIntensity = q.intensity),
            (H.shadowBias = q.bias),
            (H.shadowNormalBias = q.normalBias),
            (H.shadowRadius = q.radius),
            (H.shadowMapSize = q.mapSize),
            (n.spotShadow[g] = H),
            (n.spotShadowMap[g] = G),
            v++;
        }
        g++;
      } else if (P.isRectAreaLight) {
        const z = e.get(P);
        z.color.copy(I).multiplyScalar(O),
          z.halfWidth.set(P.width * 0.5, 0, 0),
          z.halfHeight.set(0, P.height * 0.5, 0),
          (n.rectArea[m] = z),
          m++;
      } else if (P.isPointLight) {
        const z = e.get(P);
        if (
          (z.color.copy(P.color).multiplyScalar(P.intensity),
          (z.distance = P.distance),
          (z.decay = P.decay),
          P.castShadow)
        ) {
          const q = P.shadow,
            H = t.get(P);
          (H.shadowIntensity = q.intensity),
            (H.shadowBias = q.bias),
            (H.shadowNormalBias = q.normalBias),
            (H.shadowRadius = q.radius),
            (H.shadowMapSize = q.mapSize),
            (H.shadowCameraNear = q.camera.near),
            (H.shadowCameraFar = q.camera.far),
            (n.pointShadow[_] = H),
            (n.pointShadowMap[_] = G),
            (n.pointShadowMatrix[_] = P.shadow.matrix),
            S++;
        }
        (n.point[_] = z), _++;
      } else if (P.isHemisphereLight) {
        const z = e.get(P);
        z.skyColor.copy(P.color).multiplyScalar(O),
          z.groundColor.copy(P.groundColor).multiplyScalar(O),
          (n.hemi[p] = z),
          p++;
      }
    }
    m > 0 &&
      (s.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = _e.LTC_FLOAT_1), (n.rectAreaLTC2 = _e.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = _e.LTC_HALF_1), (n.rectAreaLTC2 = _e.LTC_HALF_2))),
      (n.ambient[0] = h),
      (n.ambient[1] = u),
      (n.ambient[2] = f);
    const A = n.hash;
    (A.directionalLength !== d ||
      A.pointLength !== _ ||
      A.spotLength !== g ||
      A.rectAreaLength !== m ||
      A.hemiLength !== p ||
      A.numDirectionalShadows !== M ||
      A.numPointShadows !== S ||
      A.numSpotShadows !== v ||
      A.numSpotMaps !== C ||
      A.numLightProbes !== E) &&
      ((n.directional.length = d),
      (n.spot.length = g),
      (n.rectArea.length = m),
      (n.point.length = _),
      (n.hemi.length = p),
      (n.directionalShadow.length = M),
      (n.directionalShadowMap.length = M),
      (n.pointShadow.length = S),
      (n.pointShadowMap.length = S),
      (n.spotShadow.length = v),
      (n.spotShadowMap.length = v),
      (n.directionalShadowMatrix.length = M),
      (n.pointShadowMatrix.length = S),
      (n.spotLightMatrix.length = v + C - w),
      (n.spotLightMap.length = C),
      (n.numSpotLightShadowsWithMaps = w),
      (n.numLightProbes = E),
      (A.directionalLength = d),
      (A.pointLength = _),
      (A.spotLength = g),
      (A.rectAreaLength = m),
      (A.hemiLength = p),
      (A.numDirectionalShadows = M),
      (A.numPointShadows = S),
      (A.numSpotShadows = v),
      (A.numSpotMaps = C),
      (A.numLightProbes = E),
      (n.version = WM++));
  }
  function l(c, h) {
    let u = 0,
      f = 0,
      d = 0,
      _ = 0,
      g = 0;
    const m = h.matrixWorldInverse;
    for (let p = 0, M = c.length; p < M; p++) {
      const S = c[p];
      if (S.isDirectionalLight) {
        const v = n.directional[u];
        v.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          v.direction.sub(i),
          v.direction.transformDirection(m),
          u++;
      } else if (S.isSpotLight) {
        const v = n.spot[d];
        v.position.setFromMatrixPosition(S.matrixWorld),
          v.position.applyMatrix4(m),
          v.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          v.direction.sub(i),
          v.direction.transformDirection(m),
          d++;
      } else if (S.isRectAreaLight) {
        const v = n.rectArea[_];
        v.position.setFromMatrixPosition(S.matrixWorld),
          v.position.applyMatrix4(m),
          o.identity(),
          r.copy(S.matrixWorld),
          r.premultiply(m),
          o.extractRotation(r),
          v.halfWidth.set(S.width * 0.5, 0, 0),
          v.halfHeight.set(0, S.height * 0.5, 0),
          v.halfWidth.applyMatrix4(o),
          v.halfHeight.applyMatrix4(o),
          _++;
      } else if (S.isPointLight) {
        const v = n.point[f];
        v.position.setFromMatrixPosition(S.matrixWorld),
          v.position.applyMatrix4(m),
          f++;
      } else if (S.isHemisphereLight) {
        const v = n.hemi[g];
        v.direction.setFromMatrixPosition(S.matrixWorld),
          v.direction.transformDirection(m),
          g++;
      }
    }
  }
  return { setup: a, setupView: l, state: n };
}
function gd(s) {
  const e = new YM(s),
    t = [],
    n = [];
  function i(h) {
    (c.camera = h), (t.length = 0), (n.length = 0);
  }
  function r(h) {
    t.push(h);
  }
  function o(h) {
    n.push(h);
  }
  function a() {
    e.setup(t);
  }
  function l(h) {
    e.setupView(t, h);
  }
  const c = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: r,
    pushShadow: o,
  };
}
function qM(s) {
  let e = new WeakMap();
  function t(i, r = 0) {
    const o = e.get(i);
    let a;
    return (
      o === void 0
        ? ((a = new gd(s)), e.set(i, [a]))
        : r >= o.length
        ? ((a = new gd(s)), o.push(a))
        : (a = o[r]),
      a
    );
  }
  function n() {
    e = new WeakMap();
  }
  return { get: t, dispose: n };
}
class jM extends Li {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.depthPacking = wg),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class KM extends Li {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const $M = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  ZM = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function JM(s, e, t) {
  let n = new Uu();
  const i = new De(),
    r = new De(),
    o = new ft(),
    a = new jM({ depthPacking: Rg }),
    l = new KM(),
    c = {},
    h = t.maxTextureSize,
    u = { [sr]: Un, [Un]: sr, [Ai]: Ai },
    f = new In({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new De() },
        radius: { value: 4 },
      },
      vertexShader: $M,
      fragmentShader: ZM,
    }),
    d = f.clone();
  d.defines.HORIZONTAL_PASS = 1;
  const _ = new Mi();
  _.setAttribute(
    "position",
    new Rn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const g = new Ln(_, f),
    m = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Dp);
  let p = this.type;
  this.render = function (w, E, A) {
    if (
      m.enabled === !1 ||
      (m.autoUpdate === !1 && m.needsUpdate === !1) ||
      w.length === 0
    )
      return;
    const y = s.getRenderTarget(),
      x = s.getActiveCubeFace(),
      P = s.getActiveMipmapLevel(),
      I = s.state;
    I.setBlending(nr),
      I.buffers.color.setClear(1, 1, 1, 1),
      I.buffers.depth.setTest(!0),
      I.setScissorTest(!1);
    const O = p !== ji && this.type === ji,
      k = p === ji && this.type !== ji;
    for (let G = 0, z = w.length; G < z; G++) {
      const q = w[G],
        H = q.shadow;
      if (H === void 0) {
        console.warn("THREE.WebGLShadowMap:", q, "has no shadow.");
        continue;
      }
      if (H.autoUpdate === !1 && H.needsUpdate === !1) continue;
      i.copy(H.mapSize);
      const ee = H.getFrameExtents();
      if (
        (i.multiply(ee),
        r.copy(H.mapSize),
        (i.x > h || i.y > h) &&
          (i.x > h &&
            ((r.x = Math.floor(h / ee.x)),
            (i.x = r.x * ee.x),
            (H.mapSize.x = r.x)),
          i.y > h &&
            ((r.y = Math.floor(h / ee.y)),
            (i.y = r.y * ee.y),
            (H.mapSize.y = r.y))),
        H.map === null || O === !0 || k === !0)
      ) {
        const oe = this.type !== ji ? { minFilter: wn, magFilter: wn } : {};
        H.map !== null && H.map.dispose(),
          (H.map = new xi(i.x, i.y, oe)),
          (H.map.texture.name = q.name + ".shadowMap"),
          H.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(H.map), s.clear();
      const D = H.getViewportCount();
      for (let oe = 0; oe < D; oe++) {
        const Me = H.getViewport(oe);
        o.set(r.x * Me.x, r.y * Me.y, r.x * Me.z, r.y * Me.w),
          I.viewport(o),
          H.updateMatrices(q, oe),
          (n = H.getFrustum()),
          v(E, A, H.camera, q, this.type);
      }
      H.isPointLightShadow !== !0 && this.type === ji && M(H, A),
        (H.needsUpdate = !1);
    }
    (p = this.type), (m.needsUpdate = !1), s.setRenderTarget(y, x, P);
  };
  function M(w, E) {
    const A = e.update(g);
    f.defines.VSM_SAMPLES !== w.blurSamples &&
      ((f.defines.VSM_SAMPLES = w.blurSamples),
      (d.defines.VSM_SAMPLES = w.blurSamples),
      (f.needsUpdate = !0),
      (d.needsUpdate = !0)),
      w.mapPass === null && (w.mapPass = new xi(i.x, i.y)),
      (f.uniforms.shadow_pass.value = w.map.texture),
      (f.uniforms.resolution.value = w.mapSize),
      (f.uniforms.radius.value = w.radius),
      s.setRenderTarget(w.mapPass),
      s.clear(),
      s.renderBufferDirect(E, null, A, f, g, null),
      (d.uniforms.shadow_pass.value = w.mapPass.texture),
      (d.uniforms.resolution.value = w.mapSize),
      (d.uniforms.radius.value = w.radius),
      s.setRenderTarget(w.map),
      s.clear(),
      s.renderBufferDirect(E, null, A, d, g, null);
  }
  function S(w, E, A, y) {
    let x = null;
    const P =
      A.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
    if (P !== void 0) x = P;
    else if (
      ((x = A.isPointLight === !0 ? l : a),
      (s.localClippingEnabled &&
        E.clipShadows === !0 &&
        Array.isArray(E.clippingPlanes) &&
        E.clippingPlanes.length !== 0) ||
        (E.displacementMap && E.displacementScale !== 0) ||
        (E.alphaMap && E.alphaTest > 0) ||
        (E.map && E.alphaTest > 0))
    ) {
      const I = x.uuid,
        O = E.uuid;
      let k = c[I];
      k === void 0 && ((k = {}), (c[I] = k));
      let G = k[O];
      G === void 0 &&
        ((G = x.clone()), (k[O] = G), E.addEventListener("dispose", C)),
        (x = G);
    }
    if (
      ((x.visible = E.visible),
      (x.wireframe = E.wireframe),
      y === ji
        ? (x.side = E.shadowSide !== null ? E.shadowSide : E.side)
        : (x.side = E.shadowSide !== null ? E.shadowSide : u[E.side]),
      (x.alphaMap = E.alphaMap),
      (x.alphaTest = E.alphaTest),
      (x.map = E.map),
      (x.clipShadows = E.clipShadows),
      (x.clippingPlanes = E.clippingPlanes),
      (x.clipIntersection = E.clipIntersection),
      (x.displacementMap = E.displacementMap),
      (x.displacementScale = E.displacementScale),
      (x.displacementBias = E.displacementBias),
      (x.wireframeLinewidth = E.wireframeLinewidth),
      (x.linewidth = E.linewidth),
      A.isPointLight === !0 && x.isMeshDistanceMaterial === !0)
    ) {
      const I = s.properties.get(x);
      I.light = A;
    }
    return x;
  }
  function v(w, E, A, y, x) {
    if (w.visible === !1) return;
    if (
      w.layers.test(E.layers) &&
      (w.isMesh || w.isLine || w.isPoints) &&
      (w.castShadow || (w.receiveShadow && x === ji)) &&
      (!w.frustumCulled || n.intersectsObject(w))
    ) {
      w.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, w.matrixWorld);
      const O = e.update(w),
        k = w.material;
      if (Array.isArray(k)) {
        const G = O.groups;
        for (let z = 0, q = G.length; z < q; z++) {
          const H = G[z],
            ee = k[H.materialIndex];
          if (ee && ee.visible) {
            const D = S(w, ee, y, x);
            w.onBeforeShadow(s, w, E, A, O, D, H),
              s.renderBufferDirect(A, null, O, D, w, H),
              w.onAfterShadow(s, w, E, A, O, D, H);
          }
        }
      } else if (k.visible) {
        const G = S(w, k, y, x);
        w.onBeforeShadow(s, w, E, A, O, G, null),
          s.renderBufferDirect(A, null, O, G, w, null),
          w.onAfterShadow(s, w, E, A, O, G, null);
      }
    }
    const I = w.children;
    for (let O = 0, k = I.length; O < k; O++) v(I[O], E, A, y, x);
  }
  function C(w) {
    w.target.removeEventListener("dispose", C);
    for (const A in c) {
      const y = c[A],
        x = w.target.uuid;
      x in y && (y[x].dispose(), delete y[x]);
    }
  }
}
const QM = {
  [uh]: fh,
  [dh]: _h,
  [ph]: gh,
  [no]: mh,
  [fh]: uh,
  [_h]: dh,
  [gh]: ph,
  [mh]: no,
};
function eS(s, e) {
  function t() {
    let L = !1;
    const he = new ft();
    let j = null;
    const Z = new ft(0, 0, 0, 0);
    return {
      setMask: function (ce) {
        j !== ce && !L && (s.colorMask(ce, ce, ce, ce), (j = ce));
      },
      setLocked: function (ce) {
        L = ce;
      },
      setClear: function (ce, fe, Be, ht, Nt) {
        Nt === !0 && ((ce *= ht), (fe *= ht), (Be *= ht)),
          he.set(ce, fe, Be, ht),
          Z.equals(he) === !1 && (s.clearColor(ce, fe, Be, ht), Z.copy(he));
      },
      reset: function () {
        (L = !1), (j = null), Z.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let L = !1,
      he = !1,
      j = null,
      Z = null,
      ce = null;
    return {
      setReversed: function (fe) {
        if (he !== fe) {
          const Be = e.get("EXT_clip_control");
          he
            ? Be.clipControlEXT(Be.LOWER_LEFT_EXT, Be.ZERO_TO_ONE_EXT)
            : Be.clipControlEXT(Be.LOWER_LEFT_EXT, Be.NEGATIVE_ONE_TO_ONE_EXT);
          const ht = ce;
          (ce = null), this.setClear(ht);
        }
        he = fe;
      },
      getReversed: function () {
        return he;
      },
      setTest: function (fe) {
        fe ? ne(s.DEPTH_TEST) : Ee(s.DEPTH_TEST);
      },
      setMask: function (fe) {
        j !== fe && !L && (s.depthMask(fe), (j = fe));
      },
      setFunc: function (fe) {
        if ((he && (fe = QM[fe]), Z !== fe)) {
          switch (fe) {
            case uh:
              s.depthFunc(s.NEVER);
              break;
            case fh:
              s.depthFunc(s.ALWAYS);
              break;
            case dh:
              s.depthFunc(s.LESS);
              break;
            case no:
              s.depthFunc(s.LEQUAL);
              break;
            case ph:
              s.depthFunc(s.EQUAL);
              break;
            case mh:
              s.depthFunc(s.GEQUAL);
              break;
            case _h:
              s.depthFunc(s.GREATER);
              break;
            case gh:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Z = fe;
        }
      },
      setLocked: function (fe) {
        L = fe;
      },
      setClear: function (fe) {
        ce !== fe && (he && (fe = 1 - fe), s.clearDepth(fe), (ce = fe));
      },
      reset: function () {
        (L = !1), (j = null), (Z = null), (ce = null), (he = !1);
      },
    };
  }
  function i() {
    let L = !1,
      he = null,
      j = null,
      Z = null,
      ce = null,
      fe = null,
      Be = null,
      ht = null,
      Nt = null;
    return {
      setTest: function (ve) {
        L || (ve ? ne(s.STENCIL_TEST) : Ee(s.STENCIL_TEST));
      },
      setMask: function (ve) {
        he !== ve && !L && (s.stencilMask(ve), (he = ve));
      },
      setFunc: function (ve, Ae, Ke) {
        (j !== ve || Z !== Ae || ce !== Ke) &&
          (s.stencilFunc(ve, Ae, Ke), (j = ve), (Z = Ae), (ce = Ke));
      },
      setOp: function (ve, Ae, Ke) {
        (fe !== ve || Be !== Ae || ht !== Ke) &&
          (s.stencilOp(ve, Ae, Ke), (fe = ve), (Be = Ae), (ht = Ke));
      },
      setLocked: function (ve) {
        L = ve;
      },
      setClear: function (ve) {
        Nt !== ve && (s.clearStencil(ve), (Nt = ve));
      },
      reset: function () {
        (L = !1),
          (he = null),
          (j = null),
          (Z = null),
          (ce = null),
          (fe = null),
          (Be = null),
          (ht = null),
          (Nt = null);
      },
    };
  }
  const r = new t(),
    o = new n(),
    a = new i(),
    l = new WeakMap(),
    c = new WeakMap();
  let h = {},
    u = {},
    f = new WeakMap(),
    d = [],
    _ = null,
    g = !1,
    m = null,
    p = null,
    M = null,
    S = null,
    v = null,
    C = null,
    w = null,
    E = new He(0, 0, 0),
    A = 0,
    y = !1,
    x = null,
    P = null,
    I = null,
    O = null,
    k = null;
  const G = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let z = !1,
    q = 0;
  const H = s.getParameter(s.VERSION);
  H.indexOf("WebGL") !== -1
    ? ((q = parseFloat(/^WebGL (\d)/.exec(H)[1])), (z = q >= 1))
    : H.indexOf("OpenGL ES") !== -1 &&
      ((q = parseFloat(/^OpenGL ES (\d)/.exec(H)[1])), (z = q >= 2));
  let ee = null,
    D = {};
  const oe = s.getParameter(s.SCISSOR_BOX),
    Me = s.getParameter(s.VIEWPORT),
    Ue = new ft().fromArray(oe),
    K = new ft().fromArray(Me);
  function te(L, he, j, Z) {
    const ce = new Uint8Array(4),
      fe = s.createTexture();
    s.bindTexture(L, fe),
      s.texParameteri(L, s.TEXTURE_MIN_FILTER, s.NEAREST),
      s.texParameteri(L, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let Be = 0; Be < j; Be++)
      L === s.TEXTURE_3D || L === s.TEXTURE_2D_ARRAY
        ? s.texImage3D(he, 0, s.RGBA, 1, 1, Z, 0, s.RGBA, s.UNSIGNED_BYTE, ce)
        : s.texImage2D(
            he + Be,
            0,
            s.RGBA,
            1,
            1,
            0,
            s.RGBA,
            s.UNSIGNED_BYTE,
            ce
          );
    return fe;
  }
  const ge = {};
  (ge[s.TEXTURE_2D] = te(s.TEXTURE_2D, s.TEXTURE_2D, 1)),
    (ge[s.TEXTURE_CUBE_MAP] = te(
      s.TEXTURE_CUBE_MAP,
      s.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (ge[s.TEXTURE_2D_ARRAY] = te(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1)),
    (ge[s.TEXTURE_3D] = te(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)),
    r.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    ne(s.DEPTH_TEST),
    o.setFunc(no),
    Fe(!1),
    V(vf),
    ne(s.CULL_FACE),
    U(nr);
  function ne(L) {
    h[L] !== !0 && (s.enable(L), (h[L] = !0));
  }
  function Ee(L) {
    h[L] !== !1 && (s.disable(L), (h[L] = !1));
  }
  function we(L, he) {
    return u[L] !== he
      ? (s.bindFramebuffer(L, he),
        (u[L] = he),
        L === s.DRAW_FRAMEBUFFER && (u[s.FRAMEBUFFER] = he),
        L === s.FRAMEBUFFER && (u[s.DRAW_FRAMEBUFFER] = he),
        !0)
      : !1;
  }
  function Ve(L, he) {
    let j = d,
      Z = !1;
    if (L) {
      (j = f.get(he)), j === void 0 && ((j = []), f.set(he, j));
      const ce = L.textures;
      if (j.length !== ce.length || j[0] !== s.COLOR_ATTACHMENT0) {
        for (let fe = 0, Be = ce.length; fe < Be; fe++)
          j[fe] = s.COLOR_ATTACHMENT0 + fe;
        (j.length = ce.length), (Z = !0);
      }
    } else j[0] !== s.BACK && ((j[0] = s.BACK), (Z = !0));
    Z && s.drawBuffers(j);
  }
  function Qe(L) {
    return _ !== L ? (s.useProgram(L), (_ = L), !0) : !1;
  }
  const Ge = {
    [$r]: s.FUNC_ADD,
    [Q_]: s.FUNC_SUBTRACT,
    [eg]: s.FUNC_REVERSE_SUBTRACT,
  };
  (Ge[tg] = s.MIN), (Ge[ng] = s.MAX);
  const Le = {
    [ig]: s.ZERO,
    [rg]: s.ONE,
    [sg]: s.SRC_COLOR,
    [ch]: s.SRC_ALPHA,
    [ug]: s.SRC_ALPHA_SATURATE,
    [cg]: s.DST_COLOR,
    [ag]: s.DST_ALPHA,
    [og]: s.ONE_MINUS_SRC_COLOR,
    [hh]: s.ONE_MINUS_SRC_ALPHA,
    [hg]: s.ONE_MINUS_DST_COLOR,
    [lg]: s.ONE_MINUS_DST_ALPHA,
    [fg]: s.CONSTANT_COLOR,
    [dg]: s.ONE_MINUS_CONSTANT_COLOR,
    [pg]: s.CONSTANT_ALPHA,
    [mg]: s.ONE_MINUS_CONSTANT_ALPHA,
  };
  function U(L, he, j, Z, ce, fe, Be, ht, Nt, ve) {
    if (L === nr) {
      g === !0 && (Ee(s.BLEND), (g = !1));
      return;
    }
    if ((g === !1 && (ne(s.BLEND), (g = !0)), L !== J_)) {
      if (L !== m || ve !== y) {
        if (
          ((p !== $r || v !== $r) &&
            (s.blendEquation(s.FUNC_ADD), (p = $r), (v = $r)),
          ve)
        )
          switch (L) {
            case Ys:
              s.blendFuncSeparate(
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              );
              break;
            case lh:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case xf:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case yf:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", L);
              break;
          }
        else
          switch (L) {
            case Ys:
              s.blendFuncSeparate(
                s.SRC_ALPHA,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              );
              break;
            case lh:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case xf:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case yf:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", L);
              break;
          }
        (M = null),
          (S = null),
          (C = null),
          (w = null),
          E.set(0, 0, 0),
          (A = 0),
          (m = L),
          (y = ve);
      }
      return;
    }
    (ce = ce || he),
      (fe = fe || j),
      (Be = Be || Z),
      (he !== p || ce !== v) &&
        (s.blendEquationSeparate(Ge[he], Ge[ce]), (p = he), (v = ce)),
      (j !== M || Z !== S || fe !== C || Be !== w) &&
        (s.blendFuncSeparate(Le[j], Le[Z], Le[fe], Le[Be]),
        (M = j),
        (S = Z),
        (C = fe),
        (w = Be)),
      (ht.equals(E) === !1 || Nt !== A) &&
        (s.blendColor(ht.r, ht.g, ht.b, Nt), E.copy(ht), (A = Nt)),
      (m = L),
      (y = !1);
  }
  function Mt(L, he) {
    L.side === Ai ? Ee(s.CULL_FACE) : ne(s.CULL_FACE);
    let j = L.side === Un;
    he && (j = !j),
      Fe(j),
      L.blending === Ys && L.transparent === !1
        ? U(nr)
        : U(
            L.blending,
            L.blendEquation,
            L.blendSrc,
            L.blendDst,
            L.blendEquationAlpha,
            L.blendSrcAlpha,
            L.blendDstAlpha,
            L.blendColor,
            L.blendAlpha,
            L.premultipliedAlpha
          ),
      o.setFunc(L.depthFunc),
      o.setTest(L.depthTest),
      o.setMask(L.depthWrite),
      r.setMask(L.colorWrite);
    const Z = L.stencilWrite;
    a.setTest(Z),
      Z &&
        (a.setMask(L.stencilWriteMask),
        a.setFunc(L.stencilFunc, L.stencilRef, L.stencilFuncMask),
        a.setOp(L.stencilFail, L.stencilZFail, L.stencilZPass)),
      st(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits),
      L.alphaToCoverage === !0
        ? ne(s.SAMPLE_ALPHA_TO_COVERAGE)
        : Ee(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Fe(L) {
    x !== L && (L ? s.frontFace(s.CW) : s.frontFace(s.CCW), (x = L));
  }
  function V(L) {
    L !== K_
      ? (ne(s.CULL_FACE),
        L !== P &&
          (L === vf
            ? s.cullFace(s.BACK)
            : L === $_
            ? s.cullFace(s.FRONT)
            : s.cullFace(s.FRONT_AND_BACK)))
      : Ee(s.CULL_FACE),
      (P = L);
  }
  function be(L) {
    L !== I && (z && s.lineWidth(L), (I = L));
  }
  function st(L, he, j) {
    L
      ? (ne(s.POLYGON_OFFSET_FILL),
        (O !== he || k !== j) && (s.polygonOffset(he, j), (O = he), (k = j)))
      : Ee(s.POLYGON_OFFSET_FILL);
  }
  function Re(L) {
    L ? ne(s.SCISSOR_TEST) : Ee(s.SCISSOR_TEST);
  }
  function R(L) {
    L === void 0 && (L = s.TEXTURE0 + G - 1),
      ee !== L && (s.activeTexture(L), (ee = L));
  }
  function T(L, he, j) {
    j === void 0 && (ee === null ? (j = s.TEXTURE0 + G - 1) : (j = ee));
    let Z = D[j];
    Z === void 0 && ((Z = { type: void 0, texture: void 0 }), (D[j] = Z)),
      (Z.type !== L || Z.texture !== he) &&
        (ee !== j && (s.activeTexture(j), (ee = j)),
        s.bindTexture(L, he || ge[L]),
        (Z.type = L),
        (Z.texture = he));
  }
  function Y() {
    const L = D[ee];
    L !== void 0 &&
      L.type !== void 0 &&
      (s.bindTexture(L.type, null), (L.type = void 0), (L.texture = void 0));
  }
  function Q() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function J() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function $() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function ue() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function le() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function pe() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function Ye() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function ie() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function ae() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function Ne() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function Ie(L) {
    Ue.equals(L) === !1 && (s.scissor(L.x, L.y, L.z, L.w), Ue.copy(L));
  }
  function xe(L) {
    K.equals(L) === !1 && (s.viewport(L.x, L.y, L.z, L.w), K.copy(L));
  }
  function je(L, he) {
    let j = c.get(he);
    j === void 0 && ((j = new WeakMap()), c.set(he, j));
    let Z = j.get(L);
    Z === void 0 && ((Z = s.getUniformBlockIndex(he, L.name)), j.set(L, Z));
  }
  function Oe(L, he) {
    const Z = c.get(he).get(L);
    l.get(he) !== Z &&
      (s.uniformBlockBinding(he, Z, L.__bindingPointIndex), l.set(he, Z));
  }
  function ct() {
    s.disable(s.BLEND),
      s.disable(s.CULL_FACE),
      s.disable(s.DEPTH_TEST),
      s.disable(s.POLYGON_OFFSET_FILL),
      s.disable(s.SCISSOR_TEST),
      s.disable(s.STENCIL_TEST),
      s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
      s.blendEquation(s.FUNC_ADD),
      s.blendFunc(s.ONE, s.ZERO),
      s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
      s.blendColor(0, 0, 0, 0),
      s.colorMask(!0, !0, !0, !0),
      s.clearColor(0, 0, 0, 0),
      s.depthMask(!0),
      s.depthFunc(s.LESS),
      o.setReversed(!1),
      s.clearDepth(1),
      s.stencilMask(4294967295),
      s.stencilFunc(s.ALWAYS, 0, 4294967295),
      s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
      s.clearStencil(0),
      s.cullFace(s.BACK),
      s.frontFace(s.CCW),
      s.polygonOffset(0, 0),
      s.activeTexture(s.TEXTURE0),
      s.bindFramebuffer(s.FRAMEBUFFER, null),
      s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
      s.bindFramebuffer(s.READ_FRAMEBUFFER, null),
      s.useProgram(null),
      s.lineWidth(1),
      s.scissor(0, 0, s.canvas.width, s.canvas.height),
      s.viewport(0, 0, s.canvas.width, s.canvas.height),
      (h = {}),
      (ee = null),
      (D = {}),
      (u = {}),
      (f = new WeakMap()),
      (d = []),
      (_ = null),
      (g = !1),
      (m = null),
      (p = null),
      (M = null),
      (S = null),
      (v = null),
      (C = null),
      (w = null),
      (E = new He(0, 0, 0)),
      (A = 0),
      (y = !1),
      (x = null),
      (P = null),
      (I = null),
      (O = null),
      (k = null),
      Ue.set(0, 0, s.canvas.width, s.canvas.height),
      K.set(0, 0, s.canvas.width, s.canvas.height),
      r.reset(),
      o.reset(),
      a.reset();
  }
  return {
    buffers: { color: r, depth: o, stencil: a },
    enable: ne,
    disable: Ee,
    bindFramebuffer: we,
    drawBuffers: Ve,
    useProgram: Qe,
    setBlending: U,
    setMaterial: Mt,
    setFlipSided: Fe,
    setCullFace: V,
    setLineWidth: be,
    setPolygonOffset: st,
    setScissorTest: Re,
    activeTexture: R,
    bindTexture: T,
    unbindTexture: Y,
    compressedTexImage2D: Q,
    compressedTexImage3D: J,
    texImage2D: ae,
    texImage3D: Ne,
    updateUBOMapping: je,
    uniformBlockBinding: Oe,
    texStorage2D: Ye,
    texStorage3D: ie,
    texSubImage2D: $,
    texSubImage3D: ue,
    compressedTexSubImage2D: le,
    compressedTexSubImage3D: pe,
    scissor: Ie,
    viewport: xe,
    reset: ct,
  };
}
function vd(s, e, t, n) {
  const i = tS(n);
  switch (t) {
    case kp:
      return s * e;
    case Hp:
      return s * e;
    case Vp:
      return s * e * 2;
    case Cu:
      return ((s * e) / i.components) * i.byteLength;
    case Pu:
      return ((s * e) / i.components) * i.byteLength;
    case Gp:
      return ((s * e * 2) / i.components) * i.byteLength;
    case Du:
      return ((s * e * 2) / i.components) * i.byteLength;
    case zp:
      return ((s * e * 3) / i.components) * i.byteLength;
    case si:
      return ((s * e * 4) / i.components) * i.byteLength;
    case Lu:
      return ((s * e * 4) / i.components) * i.byteLength;
    case vl:
    case xl:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case yl:
    case Ml:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case yh:
    case Sh:
      return (Math.max(s, 16) * Math.max(e, 8)) / 4;
    case xh:
    case Mh:
      return (Math.max(s, 8) * Math.max(e, 8)) / 2;
    case Th:
    case Eh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case bh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ah:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case wh:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Rh:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Ch:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Ph:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Dh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Lh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Ih:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Uh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Nh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Oh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Fh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Bh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case kh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Sl:
    case zh:
    case Hh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case Wp:
    case Vh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case Gh:
    case Wh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function tS(s) {
  switch (s) {
    case or:
    case Op:
      return { byteLength: 1, components: 1 };
    case ca:
    case Fp:
    case Kn:
      return { byteLength: 2, components: 1 };
    case wu:
    case Ru:
      return { byteLength: 2, components: 4 };
    case cs:
    case Au:
    case Dn:
      return { byteLength: 4, components: 1 };
    case Bp:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
function nS(s, e, t, n, i, r, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new De(),
    h = new WeakMap();
  let u;
  const f = new WeakMap();
  let d = !1;
  try {
    d =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function _(R, T) {
    return d ? new OffscreenCanvas(R, T) : fa("canvas");
  }
  function g(R, T, Y) {
    let Q = 1;
    const J = Re(R);
    if (
      ((J.width > Y || J.height > Y) && (Q = Y / Math.max(J.width, J.height)),
      Q < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && R instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && R instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && R instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && R instanceof VideoFrame)
      ) {
        const $ = Math.floor(Q * J.width),
          ue = Math.floor(Q * J.height);
        u === void 0 && (u = _($, ue));
        const le = T ? _($, ue) : u;
        return (
          (le.width = $),
          (le.height = ue),
          le.getContext("2d").drawImage(R, 0, 0, $, ue),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              J.width +
              "x" +
              J.height +
              ") to (" +
              $ +
              "x" +
              ue +
              ")."
          ),
          le
        );
      } else
        return (
          "data" in R &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                J.width +
                "x" +
                J.height +
                ")."
            ),
          R
        );
    return R;
  }
  function m(R) {
    return R.generateMipmaps;
  }
  function p(R) {
    s.generateMipmap(R);
  }
  function M(R) {
    return R.isWebGLCubeRenderTarget
      ? s.TEXTURE_CUBE_MAP
      : R.isWebGL3DRenderTarget
      ? s.TEXTURE_3D
      : R.isWebGLArrayRenderTarget || R.isCompressedArrayTexture
      ? s.TEXTURE_2D_ARRAY
      : s.TEXTURE_2D;
  }
  function S(R, T, Y, Q, J = !1) {
    if (R !== null) {
      if (s[R] !== void 0) return s[R];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          R +
          "'"
      );
    }
    let $ = T;
    if (
      (T === s.RED &&
        (Y === s.FLOAT && ($ = s.R32F),
        Y === s.HALF_FLOAT && ($ = s.R16F),
        Y === s.UNSIGNED_BYTE && ($ = s.R8)),
      T === s.RED_INTEGER &&
        (Y === s.UNSIGNED_BYTE && ($ = s.R8UI),
        Y === s.UNSIGNED_SHORT && ($ = s.R16UI),
        Y === s.UNSIGNED_INT && ($ = s.R32UI),
        Y === s.BYTE && ($ = s.R8I),
        Y === s.SHORT && ($ = s.R16I),
        Y === s.INT && ($ = s.R32I)),
      T === s.RG &&
        (Y === s.FLOAT && ($ = s.RG32F),
        Y === s.HALF_FLOAT && ($ = s.RG16F),
        Y === s.UNSIGNED_BYTE && ($ = s.RG8)),
      T === s.RG_INTEGER &&
        (Y === s.UNSIGNED_BYTE && ($ = s.RG8UI),
        Y === s.UNSIGNED_SHORT && ($ = s.RG16UI),
        Y === s.UNSIGNED_INT && ($ = s.RG32UI),
        Y === s.BYTE && ($ = s.RG8I),
        Y === s.SHORT && ($ = s.RG16I),
        Y === s.INT && ($ = s.RG32I)),
      T === s.RGB_INTEGER &&
        (Y === s.UNSIGNED_BYTE && ($ = s.RGB8UI),
        Y === s.UNSIGNED_SHORT && ($ = s.RGB16UI),
        Y === s.UNSIGNED_INT && ($ = s.RGB32UI),
        Y === s.BYTE && ($ = s.RGB8I),
        Y === s.SHORT && ($ = s.RGB16I),
        Y === s.INT && ($ = s.RGB32I)),
      T === s.RGBA_INTEGER &&
        (Y === s.UNSIGNED_BYTE && ($ = s.RGBA8UI),
        Y === s.UNSIGNED_SHORT && ($ = s.RGBA16UI),
        Y === s.UNSIGNED_INT && ($ = s.RGBA32UI),
        Y === s.BYTE && ($ = s.RGBA8I),
        Y === s.SHORT && ($ = s.RGBA16I),
        Y === s.INT && ($ = s.RGBA32I)),
      T === s.RGB && Y === s.UNSIGNED_INT_5_9_9_9_REV && ($ = s.RGB9_E5),
      T === s.RGBA)
    ) {
      const ue = J ? Jl : at.getTransfer(Q);
      Y === s.FLOAT && ($ = s.RGBA32F),
        Y === s.HALF_FLOAT && ($ = s.RGBA16F),
        Y === s.UNSIGNED_BYTE && ($ = ue === xt ? s.SRGB8_ALPHA8 : s.RGBA8),
        Y === s.UNSIGNED_SHORT_4_4_4_4 && ($ = s.RGBA4),
        Y === s.UNSIGNED_SHORT_5_5_5_1 && ($ = s.RGB5_A1);
    }
    return (
      ($ === s.R16F ||
        $ === s.R32F ||
        $ === s.RG16F ||
        $ === s.RG32F ||
        $ === s.RGBA16F ||
        $ === s.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      $
    );
  }
  function v(R, T) {
    let Y;
    return (
      R
        ? T === null || T === cs || T === oo
          ? (Y = s.DEPTH24_STENCIL8)
          : T === Dn
          ? (Y = s.DEPTH32F_STENCIL8)
          : T === ca &&
            ((Y = s.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : T === null || T === cs || T === oo
        ? (Y = s.DEPTH_COMPONENT24)
        : T === Dn
        ? (Y = s.DEPTH_COMPONENT32F)
        : T === ca && (Y = s.DEPTH_COMPONENT16),
      Y
    );
  }
  function C(R, T) {
    return m(R) === !0 ||
      (R.isFramebufferTexture && R.minFilter !== wn && R.minFilter !== tn)
      ? Math.log2(Math.max(T.width, T.height)) + 1
      : R.mipmaps !== void 0 && R.mipmaps.length > 0
      ? R.mipmaps.length
      : R.isCompressedTexture && Array.isArray(R.image)
      ? T.mipmaps.length
      : 1;
  }
  function w(R) {
    const T = R.target;
    T.removeEventListener("dispose", w), A(T), T.isVideoTexture && h.delete(T);
  }
  function E(R) {
    const T = R.target;
    T.removeEventListener("dispose", E), x(T);
  }
  function A(R) {
    const T = n.get(R);
    if (T.__webglInit === void 0) return;
    const Y = R.source,
      Q = f.get(Y);
    if (Q) {
      const J = Q[T.__cacheKey];
      J.usedTimes--,
        J.usedTimes === 0 && y(R),
        Object.keys(Q).length === 0 && f.delete(Y);
    }
    n.remove(R);
  }
  function y(R) {
    const T = n.get(R);
    s.deleteTexture(T.__webglTexture);
    const Y = R.source,
      Q = f.get(Y);
    delete Q[T.__cacheKey], o.memory.textures--;
  }
  function x(R) {
    const T = n.get(R);
    if (
      (R.depthTexture && (R.depthTexture.dispose(), n.remove(R.depthTexture)),
      R.isWebGLCubeRenderTarget)
    )
      for (let Q = 0; Q < 6; Q++) {
        if (Array.isArray(T.__webglFramebuffer[Q]))
          for (let J = 0; J < T.__webglFramebuffer[Q].length; J++)
            s.deleteFramebuffer(T.__webglFramebuffer[Q][J]);
        else s.deleteFramebuffer(T.__webglFramebuffer[Q]);
        T.__webglDepthbuffer && s.deleteRenderbuffer(T.__webglDepthbuffer[Q]);
      }
    else {
      if (Array.isArray(T.__webglFramebuffer))
        for (let Q = 0; Q < T.__webglFramebuffer.length; Q++)
          s.deleteFramebuffer(T.__webglFramebuffer[Q]);
      else s.deleteFramebuffer(T.__webglFramebuffer);
      if (
        (T.__webglDepthbuffer && s.deleteRenderbuffer(T.__webglDepthbuffer),
        T.__webglMultisampledFramebuffer &&
          s.deleteFramebuffer(T.__webglMultisampledFramebuffer),
        T.__webglColorRenderbuffer)
      )
        for (let Q = 0; Q < T.__webglColorRenderbuffer.length; Q++)
          T.__webglColorRenderbuffer[Q] &&
            s.deleteRenderbuffer(T.__webglColorRenderbuffer[Q]);
      T.__webglDepthRenderbuffer &&
        s.deleteRenderbuffer(T.__webglDepthRenderbuffer);
    }
    const Y = R.textures;
    for (let Q = 0, J = Y.length; Q < J; Q++) {
      const $ = n.get(Y[Q]);
      $.__webglTexture &&
        (s.deleteTexture($.__webglTexture), o.memory.textures--),
        n.remove(Y[Q]);
    }
    n.remove(R);
  }
  let P = 0;
  function I() {
    P = 0;
  }
  function O() {
    const R = P;
    return (
      R >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            R +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (P += 1),
      R
    );
  }
  function k(R) {
    const T = [];
    return (
      T.push(R.wrapS),
      T.push(R.wrapT),
      T.push(R.wrapR || 0),
      T.push(R.magFilter),
      T.push(R.minFilter),
      T.push(R.anisotropy),
      T.push(R.internalFormat),
      T.push(R.format),
      T.push(R.type),
      T.push(R.generateMipmaps),
      T.push(R.premultiplyAlpha),
      T.push(R.flipY),
      T.push(R.unpackAlignment),
      T.push(R.colorSpace),
      T.join()
    );
  }
  function G(R, T) {
    const Y = n.get(R);
    if (
      (R.isVideoTexture && be(R),
      R.isRenderTargetTexture === !1 &&
        R.version > 0 &&
        Y.__version !== R.version)
    ) {
      const Q = R.image;
      if (Q === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Q.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        K(Y, R, T);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, Y.__webglTexture, s.TEXTURE0 + T);
  }
  function z(R, T) {
    const Y = n.get(R);
    if (R.version > 0 && Y.__version !== R.version) {
      K(Y, R, T);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, Y.__webglTexture, s.TEXTURE0 + T);
  }
  function q(R, T) {
    const Y = n.get(R);
    if (R.version > 0 && Y.__version !== R.version) {
      K(Y, R, T);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, Y.__webglTexture, s.TEXTURE0 + T);
  }
  function H(R, T) {
    const Y = n.get(R);
    if (R.version > 0 && Y.__version !== R.version) {
      te(Y, R, T);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, Y.__webglTexture, s.TEXTURE0 + T);
  }
  const ee = { [so]: s.REPEAT, [Ri]: s.CLAMP_TO_EDGE, [Ul]: s.MIRRORED_REPEAT },
    D = {
      [wn]: s.NEAREST,
      [Np]: s.NEAREST_MIPMAP_NEAREST,
      [Bo]: s.NEAREST_MIPMAP_LINEAR,
      [tn]: s.LINEAR,
      [gl]: s.LINEAR_MIPMAP_NEAREST,
      [Ci]: s.LINEAR_MIPMAP_LINEAR,
    },
    oe = {
      [Pg]: s.NEVER,
      [Og]: s.ALWAYS,
      [Dg]: s.LESS,
      [qp]: s.LEQUAL,
      [Lg]: s.EQUAL,
      [Ng]: s.GEQUAL,
      [Ig]: s.GREATER,
      [Ug]: s.NOTEQUAL,
    };
  function Me(R, T) {
    if (
      (T.type === Dn &&
        e.has("OES_texture_float_linear") === !1 &&
        (T.magFilter === tn ||
          T.magFilter === gl ||
          T.magFilter === Bo ||
          T.magFilter === Ci ||
          T.minFilter === tn ||
          T.minFilter === gl ||
          T.minFilter === Bo ||
          T.minFilter === Ci) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      s.texParameteri(R, s.TEXTURE_WRAP_S, ee[T.wrapS]),
      s.texParameteri(R, s.TEXTURE_WRAP_T, ee[T.wrapT]),
      (R === s.TEXTURE_3D || R === s.TEXTURE_2D_ARRAY) &&
        s.texParameteri(R, s.TEXTURE_WRAP_R, ee[T.wrapR]),
      s.texParameteri(R, s.TEXTURE_MAG_FILTER, D[T.magFilter]),
      s.texParameteri(R, s.TEXTURE_MIN_FILTER, D[T.minFilter]),
      T.compareFunction &&
        (s.texParameteri(R, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(R, s.TEXTURE_COMPARE_FUNC, oe[T.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        T.magFilter === wn ||
        (T.minFilter !== Bo && T.minFilter !== Ci) ||
        (T.type === Dn && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (T.anisotropy > 1 || n.get(T).__currentAnisotropy) {
        const Y = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(
          R,
          Y.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(T.anisotropy, i.getMaxAnisotropy())
        ),
          (n.get(T).__currentAnisotropy = T.anisotropy);
      }
    }
  }
  function Ue(R, T) {
    let Y = !1;
    R.__webglInit === void 0 &&
      ((R.__webglInit = !0), T.addEventListener("dispose", w));
    const Q = T.source;
    let J = f.get(Q);
    J === void 0 && ((J = {}), f.set(Q, J));
    const $ = k(T);
    if ($ !== R.__cacheKey) {
      J[$] === void 0 &&
        ((J[$] = { texture: s.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (Y = !0)),
        J[$].usedTimes++;
      const ue = J[R.__cacheKey];
      ue !== void 0 &&
        (J[R.__cacheKey].usedTimes--, ue.usedTimes === 0 && y(T)),
        (R.__cacheKey = $),
        (R.__webglTexture = J[$].texture);
    }
    return Y;
  }
  function K(R, T, Y) {
    let Q = s.TEXTURE_2D;
    (T.isDataArrayTexture || T.isCompressedArrayTexture) &&
      (Q = s.TEXTURE_2D_ARRAY),
      T.isData3DTexture && (Q = s.TEXTURE_3D);
    const J = Ue(R, T),
      $ = T.source;
    t.bindTexture(Q, R.__webglTexture, s.TEXTURE0 + Y);
    const ue = n.get($);
    if ($.version !== ue.__version || J === !0) {
      t.activeTexture(s.TEXTURE0 + Y);
      const le = at.getPrimaries(at.workingColorSpace),
        pe = T.colorSpace === Mr ? null : at.getPrimaries(T.colorSpace),
        Ye =
          T.colorSpace === Mr || le === pe ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, T.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, T.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ye);
      let ie = g(T.image, !1, i.maxTextureSize);
      ie = st(T, ie);
      const ae = r.convert(T.format, T.colorSpace),
        Ne = r.convert(T.type);
      let Ie = S(T.internalFormat, ae, Ne, T.colorSpace, T.isVideoTexture);
      Me(Q, T);
      let xe;
      const je = T.mipmaps,
        Oe = T.isVideoTexture !== !0,
        ct = ue.__version === void 0 || J === !0,
        L = $.dataReady,
        he = C(T, ie);
      if (T.isDepthTexture)
        (Ie = v(T.format === ao, T.type)),
          ct &&
            (Oe
              ? t.texStorage2D(s.TEXTURE_2D, 1, Ie, ie.width, ie.height)
              : t.texImage2D(
                  s.TEXTURE_2D,
                  0,
                  Ie,
                  ie.width,
                  ie.height,
                  0,
                  ae,
                  Ne,
                  null
                ));
      else if (T.isDataTexture)
        if (je.length > 0) {
          Oe &&
            ct &&
            t.texStorage2D(s.TEXTURE_2D, he, Ie, je[0].width, je[0].height);
          for (let j = 0, Z = je.length; j < Z; j++)
            (xe = je[j]),
              Oe
                ? L &&
                  t.texSubImage2D(
                    s.TEXTURE_2D,
                    j,
                    0,
                    0,
                    xe.width,
                    xe.height,
                    ae,
                    Ne,
                    xe.data
                  )
                : t.texImage2D(
                    s.TEXTURE_2D,
                    j,
                    Ie,
                    xe.width,
                    xe.height,
                    0,
                    ae,
                    Ne,
                    xe.data
                  );
          T.generateMipmaps = !1;
        } else
          Oe
            ? (ct && t.texStorage2D(s.TEXTURE_2D, he, Ie, ie.width, ie.height),
              L &&
                t.texSubImage2D(
                  s.TEXTURE_2D,
                  0,
                  0,
                  0,
                  ie.width,
                  ie.height,
                  ae,
                  Ne,
                  ie.data
                ))
            : t.texImage2D(
                s.TEXTURE_2D,
                0,
                Ie,
                ie.width,
                ie.height,
                0,
                ae,
                Ne,
                ie.data
              );
      else if (T.isCompressedTexture)
        if (T.isCompressedArrayTexture) {
          Oe &&
            ct &&
            t.texStorage3D(
              s.TEXTURE_2D_ARRAY,
              he,
              Ie,
              je[0].width,
              je[0].height,
              ie.depth
            );
          for (let j = 0, Z = je.length; j < Z; j++)
            if (((xe = je[j]), T.format !== si))
              if (ae !== null)
                if (Oe) {
                  if (L)
                    if (T.layerUpdates.size > 0) {
                      const ce = vd(xe.width, xe.height, T.format, T.type);
                      for (const fe of T.layerUpdates) {
                        const Be = xe.data.subarray(
                          (fe * ce) / xe.data.BYTES_PER_ELEMENT,
                          ((fe + 1) * ce) / xe.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          s.TEXTURE_2D_ARRAY,
                          j,
                          0,
                          0,
                          fe,
                          xe.width,
                          xe.height,
                          1,
                          ae,
                          Be
                        );
                      }
                      T.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        s.TEXTURE_2D_ARRAY,
                        j,
                        0,
                        0,
                        0,
                        xe.width,
                        xe.height,
                        ie.depth,
                        ae,
                        xe.data
                      );
                } else
                  t.compressedTexImage3D(
                    s.TEXTURE_2D_ARRAY,
                    j,
                    Ie,
                    xe.width,
                    xe.height,
                    ie.depth,
                    0,
                    xe.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              Oe
                ? L &&
                  t.texSubImage3D(
                    s.TEXTURE_2D_ARRAY,
                    j,
                    0,
                    0,
                    0,
                    xe.width,
                    xe.height,
                    ie.depth,
                    ae,
                    Ne,
                    xe.data
                  )
                : t.texImage3D(
                    s.TEXTURE_2D_ARRAY,
                    j,
                    Ie,
                    xe.width,
                    xe.height,
                    ie.depth,
                    0,
                    ae,
                    Ne,
                    xe.data
                  );
        } else {
          Oe &&
            ct &&
            t.texStorage2D(s.TEXTURE_2D, he, Ie, je[0].width, je[0].height);
          for (let j = 0, Z = je.length; j < Z; j++)
            (xe = je[j]),
              T.format !== si
                ? ae !== null
                  ? Oe
                    ? L &&
                      t.compressedTexSubImage2D(
                        s.TEXTURE_2D,
                        j,
                        0,
                        0,
                        xe.width,
                        xe.height,
                        ae,
                        xe.data
                      )
                    : t.compressedTexImage2D(
                        s.TEXTURE_2D,
                        j,
                        Ie,
                        xe.width,
                        xe.height,
                        0,
                        xe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Oe
                ? L &&
                  t.texSubImage2D(
                    s.TEXTURE_2D,
                    j,
                    0,
                    0,
                    xe.width,
                    xe.height,
                    ae,
                    Ne,
                    xe.data
                  )
                : t.texImage2D(
                    s.TEXTURE_2D,
                    j,
                    Ie,
                    xe.width,
                    xe.height,
                    0,
                    ae,
                    Ne,
                    xe.data
                  );
        }
      else if (T.isDataArrayTexture)
        if (Oe) {
          if (
            (ct &&
              t.texStorage3D(
                s.TEXTURE_2D_ARRAY,
                he,
                Ie,
                ie.width,
                ie.height,
                ie.depth
              ),
            L)
          )
            if (T.layerUpdates.size > 0) {
              const j = vd(ie.width, ie.height, T.format, T.type);
              for (const Z of T.layerUpdates) {
                const ce = ie.data.subarray(
                  (Z * j) / ie.data.BYTES_PER_ELEMENT,
                  ((Z + 1) * j) / ie.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  s.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Z,
                  ie.width,
                  ie.height,
                  1,
                  ae,
                  Ne,
                  ce
                );
              }
              T.clearLayerUpdates();
            } else
              t.texSubImage3D(
                s.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                ie.width,
                ie.height,
                ie.depth,
                ae,
                Ne,
                ie.data
              );
        } else
          t.texImage3D(
            s.TEXTURE_2D_ARRAY,
            0,
            Ie,
            ie.width,
            ie.height,
            ie.depth,
            0,
            ae,
            Ne,
            ie.data
          );
      else if (T.isData3DTexture)
        Oe
          ? (ct &&
              t.texStorage3D(
                s.TEXTURE_3D,
                he,
                Ie,
                ie.width,
                ie.height,
                ie.depth
              ),
            L &&
              t.texSubImage3D(
                s.TEXTURE_3D,
                0,
                0,
                0,
                0,
                ie.width,
                ie.height,
                ie.depth,
                ae,
                Ne,
                ie.data
              ))
          : t.texImage3D(
              s.TEXTURE_3D,
              0,
              Ie,
              ie.width,
              ie.height,
              ie.depth,
              0,
              ae,
              Ne,
              ie.data
            );
      else if (T.isFramebufferTexture) {
        if (ct)
          if (Oe) t.texStorage2D(s.TEXTURE_2D, he, Ie, ie.width, ie.height);
          else {
            let j = ie.width,
              Z = ie.height;
            for (let ce = 0; ce < he; ce++)
              t.texImage2D(s.TEXTURE_2D, ce, Ie, j, Z, 0, ae, Ne, null),
                (j >>= 1),
                (Z >>= 1);
          }
      } else if (je.length > 0) {
        if (Oe && ct) {
          const j = Re(je[0]);
          t.texStorage2D(s.TEXTURE_2D, he, Ie, j.width, j.height);
        }
        for (let j = 0, Z = je.length; j < Z; j++)
          (xe = je[j]),
            Oe
              ? L && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, ae, Ne, xe)
              : t.texImage2D(s.TEXTURE_2D, j, Ie, ae, Ne, xe);
        T.generateMipmaps = !1;
      } else if (Oe) {
        if (ct) {
          const j = Re(ie);
          t.texStorage2D(s.TEXTURE_2D, he, Ie, j.width, j.height);
        }
        L && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ae, Ne, ie);
      } else t.texImage2D(s.TEXTURE_2D, 0, Ie, ae, Ne, ie);
      m(T) && p(Q), (ue.__version = $.version), T.onUpdate && T.onUpdate(T);
    }
    R.__version = T.version;
  }
  function te(R, T, Y) {
    if (T.image.length !== 6) return;
    const Q = Ue(R, T),
      J = T.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, R.__webglTexture, s.TEXTURE0 + Y);
    const $ = n.get(J);
    if (J.version !== $.__version || Q === !0) {
      t.activeTexture(s.TEXTURE0 + Y);
      const ue = at.getPrimaries(at.workingColorSpace),
        le = T.colorSpace === Mr ? null : at.getPrimaries(T.colorSpace),
        pe =
          T.colorSpace === Mr || ue === le ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, T.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, T.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, pe);
      const Ye = T.isCompressedTexture || T.image[0].isCompressedTexture,
        ie = T.image[0] && T.image[0].isDataTexture,
        ae = [];
      for (let Z = 0; Z < 6; Z++)
        !Ye && !ie
          ? (ae[Z] = g(T.image[Z], !0, i.maxCubemapSize))
          : (ae[Z] = ie ? T.image[Z].image : T.image[Z]),
          (ae[Z] = st(T, ae[Z]));
      const Ne = ae[0],
        Ie = r.convert(T.format, T.colorSpace),
        xe = r.convert(T.type),
        je = S(T.internalFormat, Ie, xe, T.colorSpace),
        Oe = T.isVideoTexture !== !0,
        ct = $.__version === void 0 || Q === !0,
        L = J.dataReady;
      let he = C(T, Ne);
      Me(s.TEXTURE_CUBE_MAP, T);
      let j;
      if (Ye) {
        Oe &&
          ct &&
          t.texStorage2D(s.TEXTURE_CUBE_MAP, he, je, Ne.width, Ne.height);
        for (let Z = 0; Z < 6; Z++) {
          j = ae[Z].mipmaps;
          for (let ce = 0; ce < j.length; ce++) {
            const fe = j[ce];
            T.format !== si
              ? Ie !== null
                ? Oe
                  ? L &&
                    t.compressedTexSubImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                      ce,
                      0,
                      0,
                      fe.width,
                      fe.height,
                      Ie,
                      fe.data
                    )
                  : t.compressedTexImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                      ce,
                      je,
                      fe.width,
                      fe.height,
                      0,
                      fe.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Oe
              ? L &&
                t.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                  ce,
                  0,
                  0,
                  fe.width,
                  fe.height,
                  Ie,
                  xe,
                  fe.data
                )
              : t.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                  ce,
                  je,
                  fe.width,
                  fe.height,
                  0,
                  Ie,
                  xe,
                  fe.data
                );
          }
        }
      } else {
        if (((j = T.mipmaps), Oe && ct)) {
          j.length > 0 && he++;
          const Z = Re(ae[0]);
          t.texStorage2D(s.TEXTURE_CUBE_MAP, he, je, Z.width, Z.height);
        }
        for (let Z = 0; Z < 6; Z++)
          if (ie) {
            Oe
              ? L &&
                t.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                  0,
                  0,
                  0,
                  ae[Z].width,
                  ae[Z].height,
                  Ie,
                  xe,
                  ae[Z].data
                )
              : t.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                  0,
                  je,
                  ae[Z].width,
                  ae[Z].height,
                  0,
                  Ie,
                  xe,
                  ae[Z].data
                );
            for (let ce = 0; ce < j.length; ce++) {
              const Be = j[ce].image[Z].image;
              Oe
                ? L &&
                  t.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                    ce + 1,
                    0,
                    0,
                    Be.width,
                    Be.height,
                    Ie,
                    xe,
                    Be.data
                  )
                : t.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                    ce + 1,
                    je,
                    Be.width,
                    Be.height,
                    0,
                    Ie,
                    xe,
                    Be.data
                  );
            }
          } else {
            Oe
              ? L &&
                t.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                  0,
                  0,
                  0,
                  Ie,
                  xe,
                  ae[Z]
                )
              : t.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                  0,
                  je,
                  Ie,
                  xe,
                  ae[Z]
                );
            for (let ce = 0; ce < j.length; ce++) {
              const fe = j[ce];
              Oe
                ? L &&
                  t.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                    ce + 1,
                    0,
                    0,
                    Ie,
                    xe,
                    fe.image[Z]
                  )
                : t.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Z,
                    ce + 1,
                    je,
                    Ie,
                    xe,
                    fe.image[Z]
                  );
            }
          }
      }
      m(T) && p(s.TEXTURE_CUBE_MAP),
        ($.__version = J.version),
        T.onUpdate && T.onUpdate(T);
    }
    R.__version = T.version;
  }
  function ge(R, T, Y, Q, J, $) {
    const ue = r.convert(Y.format, Y.colorSpace),
      le = r.convert(Y.type),
      pe = S(Y.internalFormat, ue, le, Y.colorSpace),
      Ye = n.get(T),
      ie = n.get(Y);
    if (((ie.__renderTarget = T), !Ye.__hasExternalTextures)) {
      const ae = Math.max(1, T.width >> $),
        Ne = Math.max(1, T.height >> $);
      J === s.TEXTURE_3D || J === s.TEXTURE_2D_ARRAY
        ? t.texImage3D(J, $, pe, ae, Ne, T.depth, 0, ue, le, null)
        : t.texImage2D(J, $, pe, ae, Ne, 0, ue, le, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, R),
      V(T)
        ? a.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            Q,
            J,
            ie.__webglTexture,
            0,
            Fe(T)
          )
        : (J === s.TEXTURE_2D ||
            (J >= s.TEXTURE_CUBE_MAP_POSITIVE_X &&
              J <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          s.framebufferTexture2D(s.FRAMEBUFFER, Q, J, ie.__webglTexture, $),
      t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function ne(R, T, Y) {
    if ((s.bindRenderbuffer(s.RENDERBUFFER, R), T.depthBuffer)) {
      const Q = T.depthTexture,
        J = Q && Q.isDepthTexture ? Q.type : null,
        $ = v(T.stencilBuffer, J),
        ue = T.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT,
        le = Fe(T);
      V(T)
        ? a.renderbufferStorageMultisampleEXT(
            s.RENDERBUFFER,
            le,
            $,
            T.width,
            T.height
          )
        : Y
        ? s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            le,
            $,
            T.width,
            T.height
          )
        : s.renderbufferStorage(s.RENDERBUFFER, $, T.width, T.height),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, ue, s.RENDERBUFFER, R);
    } else {
      const Q = T.textures;
      for (let J = 0; J < Q.length; J++) {
        const $ = Q[J],
          ue = r.convert($.format, $.colorSpace),
          le = r.convert($.type),
          pe = S($.internalFormat, ue, le, $.colorSpace),
          Ye = Fe(T);
        Y && V(T) === !1
          ? s.renderbufferStorageMultisample(
              s.RENDERBUFFER,
              Ye,
              pe,
              T.width,
              T.height
            )
          : V(T)
          ? a.renderbufferStorageMultisampleEXT(
              s.RENDERBUFFER,
              Ye,
              pe,
              T.width,
              T.height
            )
          : s.renderbufferStorage(s.RENDERBUFFER, pe, T.width, T.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Ee(R, T) {
    if (T && T.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(s.FRAMEBUFFER, R),
      !(T.depthTexture && T.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const Q = n.get(T.depthTexture);
    (Q.__renderTarget = T),
      (!Q.__webglTexture ||
        T.depthTexture.image.width !== T.width ||
        T.depthTexture.image.height !== T.height) &&
        ((T.depthTexture.image.width = T.width),
        (T.depthTexture.image.height = T.height),
        (T.depthTexture.needsUpdate = !0)),
      G(T.depthTexture, 0);
    const J = Q.__webglTexture,
      $ = Fe(T);
    if (T.depthTexture.format === qs)
      V(T)
        ? a.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            J,
            0,
            $
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            J,
            0
          );
    else if (T.depthTexture.format === ao)
      V(T)
        ? a.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            J,
            0,
            $
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            J,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function we(R) {
    const T = n.get(R),
      Y = R.isWebGLCubeRenderTarget === !0;
    if (T.__boundDepthTexture !== R.depthTexture) {
      const Q = R.depthTexture;
      if ((T.__depthDisposeCallback && T.__depthDisposeCallback(), Q)) {
        const J = () => {
          delete T.__boundDepthTexture,
            delete T.__depthDisposeCallback,
            Q.removeEventListener("dispose", J);
        };
        Q.addEventListener("dispose", J), (T.__depthDisposeCallback = J);
      }
      T.__boundDepthTexture = Q;
    }
    if (R.depthTexture && !T.__autoAllocateDepthBuffer) {
      if (Y)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Ee(T.__webglFramebuffer, R);
    } else if (Y) {
      T.__webglDepthbuffer = [];
      for (let Q = 0; Q < 6; Q++)
        if (
          (t.bindFramebuffer(s.FRAMEBUFFER, T.__webglFramebuffer[Q]),
          T.__webglDepthbuffer[Q] === void 0)
        )
          (T.__webglDepthbuffer[Q] = s.createRenderbuffer()),
            ne(T.__webglDepthbuffer[Q], R, !1);
        else {
          const J = R.stencilBuffer
              ? s.DEPTH_STENCIL_ATTACHMENT
              : s.DEPTH_ATTACHMENT,
            $ = T.__webglDepthbuffer[Q];
          s.bindRenderbuffer(s.RENDERBUFFER, $),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, J, s.RENDERBUFFER, $);
        }
    } else if (
      (t.bindFramebuffer(s.FRAMEBUFFER, T.__webglFramebuffer),
      T.__webglDepthbuffer === void 0)
    )
      (T.__webglDepthbuffer = s.createRenderbuffer()),
        ne(T.__webglDepthbuffer, R, !1);
    else {
      const Q = R.stencilBuffer
          ? s.DEPTH_STENCIL_ATTACHMENT
          : s.DEPTH_ATTACHMENT,
        J = T.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, J),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, Q, s.RENDERBUFFER, J);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Ve(R, T, Y) {
    const Q = n.get(R);
    T !== void 0 &&
      ge(
        Q.__webglFramebuffer,
        R,
        R.texture,
        s.COLOR_ATTACHMENT0,
        s.TEXTURE_2D,
        0
      ),
      Y !== void 0 && we(R);
  }
  function Qe(R) {
    const T = R.texture,
      Y = n.get(R),
      Q = n.get(T);
    R.addEventListener("dispose", E);
    const J = R.textures,
      $ = R.isWebGLCubeRenderTarget === !0,
      ue = J.length > 1;
    if (
      (ue ||
        (Q.__webglTexture === void 0 && (Q.__webglTexture = s.createTexture()),
        (Q.__version = T.version),
        o.memory.textures++),
      $)
    ) {
      Y.__webglFramebuffer = [];
      for (let le = 0; le < 6; le++)
        if (T.mipmaps && T.mipmaps.length > 0) {
          Y.__webglFramebuffer[le] = [];
          for (let pe = 0; pe < T.mipmaps.length; pe++)
            Y.__webglFramebuffer[le][pe] = s.createFramebuffer();
        } else Y.__webglFramebuffer[le] = s.createFramebuffer();
    } else {
      if (T.mipmaps && T.mipmaps.length > 0) {
        Y.__webglFramebuffer = [];
        for (let le = 0; le < T.mipmaps.length; le++)
          Y.__webglFramebuffer[le] = s.createFramebuffer();
      } else Y.__webglFramebuffer = s.createFramebuffer();
      if (ue)
        for (let le = 0, pe = J.length; le < pe; le++) {
          const Ye = n.get(J[le]);
          Ye.__webglTexture === void 0 &&
            ((Ye.__webglTexture = s.createTexture()), o.memory.textures++);
        }
      if (R.samples > 0 && V(R) === !1) {
        (Y.__webglMultisampledFramebuffer = s.createFramebuffer()),
          (Y.__webglColorRenderbuffer = []),
          t.bindFramebuffer(s.FRAMEBUFFER, Y.__webglMultisampledFramebuffer);
        for (let le = 0; le < J.length; le++) {
          const pe = J[le];
          (Y.__webglColorRenderbuffer[le] = s.createRenderbuffer()),
            s.bindRenderbuffer(s.RENDERBUFFER, Y.__webglColorRenderbuffer[le]);
          const Ye = r.convert(pe.format, pe.colorSpace),
            ie = r.convert(pe.type),
            ae = S(
              pe.internalFormat,
              Ye,
              ie,
              pe.colorSpace,
              R.isXRRenderTarget === !0
            ),
            Ne = Fe(R);
          s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            Ne,
            ae,
            R.width,
            R.height
          ),
            s.framebufferRenderbuffer(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + le,
              s.RENDERBUFFER,
              Y.__webglColorRenderbuffer[le]
            );
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null),
          R.depthBuffer &&
            ((Y.__webglDepthRenderbuffer = s.createRenderbuffer()),
            ne(Y.__webglDepthRenderbuffer, R, !0)),
          t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if ($) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, Q.__webglTexture),
        Me(s.TEXTURE_CUBE_MAP, T);
      for (let le = 0; le < 6; le++)
        if (T.mipmaps && T.mipmaps.length > 0)
          for (let pe = 0; pe < T.mipmaps.length; pe++)
            ge(
              Y.__webglFramebuffer[le][pe],
              R,
              T,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_CUBE_MAP_POSITIVE_X + le,
              pe
            );
        else
          ge(
            Y.__webglFramebuffer[le],
            R,
            T,
            s.COLOR_ATTACHMENT0,
            s.TEXTURE_CUBE_MAP_POSITIVE_X + le,
            0
          );
      m(T) && p(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ue) {
      for (let le = 0, pe = J.length; le < pe; le++) {
        const Ye = J[le],
          ie = n.get(Ye);
        t.bindTexture(s.TEXTURE_2D, ie.__webglTexture),
          Me(s.TEXTURE_2D, Ye),
          ge(
            Y.__webglFramebuffer,
            R,
            Ye,
            s.COLOR_ATTACHMENT0 + le,
            s.TEXTURE_2D,
            0
          ),
          m(Ye) && p(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let le = s.TEXTURE_2D;
      if (
        ((R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) &&
          (le = R.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
        t.bindTexture(le, Q.__webglTexture),
        Me(le, T),
        T.mipmaps && T.mipmaps.length > 0)
      )
        for (let pe = 0; pe < T.mipmaps.length; pe++)
          ge(Y.__webglFramebuffer[pe], R, T, s.COLOR_ATTACHMENT0, le, pe);
      else ge(Y.__webglFramebuffer, R, T, s.COLOR_ATTACHMENT0, le, 0);
      m(T) && p(le), t.unbindTexture();
    }
    R.depthBuffer && we(R);
  }
  function Ge(R) {
    const T = R.textures;
    for (let Y = 0, Q = T.length; Y < Q; Y++) {
      const J = T[Y];
      if (m(J)) {
        const $ = M(R),
          ue = n.get(J).__webglTexture;
        t.bindTexture($, ue), p($), t.unbindTexture();
      }
    }
  }
  const Le = [],
    U = [];
  function Mt(R) {
    if (R.samples > 0) {
      if (V(R) === !1) {
        const T = R.textures,
          Y = R.width,
          Q = R.height;
        let J = s.COLOR_BUFFER_BIT;
        const $ = R.stencilBuffer
            ? s.DEPTH_STENCIL_ATTACHMENT
            : s.DEPTH_ATTACHMENT,
          ue = n.get(R),
          le = T.length > 1;
        if (le)
          for (let pe = 0; pe < T.length; pe++)
            t.bindFramebuffer(s.FRAMEBUFFER, ue.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + pe,
                s.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(s.FRAMEBUFFER, ue.__webglFramebuffer),
              s.framebufferTexture2D(
                s.DRAW_FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + pe,
                s.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          s.READ_FRAMEBUFFER,
          ue.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(s.DRAW_FRAMEBUFFER, ue.__webglFramebuffer);
        for (let pe = 0; pe < T.length; pe++) {
          if (
            (R.resolveDepthBuffer &&
              (R.depthBuffer && (J |= s.DEPTH_BUFFER_BIT),
              R.stencilBuffer &&
                R.resolveStencilBuffer &&
                (J |= s.STENCIL_BUFFER_BIT)),
            le)
          ) {
            s.framebufferRenderbuffer(
              s.READ_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.RENDERBUFFER,
              ue.__webglColorRenderbuffer[pe]
            );
            const Ye = n.get(T[pe]).__webglTexture;
            s.framebufferTexture2D(
              s.DRAW_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_2D,
              Ye,
              0
            );
          }
          s.blitFramebuffer(0, 0, Y, Q, 0, 0, Y, Q, J, s.NEAREST),
            l === !0 &&
              ((Le.length = 0),
              (U.length = 0),
              Le.push(s.COLOR_ATTACHMENT0 + pe),
              R.depthBuffer &&
                R.resolveDepthBuffer === !1 &&
                (Le.push($),
                U.push($),
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, U)),
              s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Le));
        }
        if (
          (t.bindFramebuffer(s.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
          le)
        )
          for (let pe = 0; pe < T.length; pe++) {
            t.bindFramebuffer(s.FRAMEBUFFER, ue.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + pe,
                s.RENDERBUFFER,
                ue.__webglColorRenderbuffer[pe]
              );
            const Ye = n.get(T[pe]).__webglTexture;
            t.bindFramebuffer(s.FRAMEBUFFER, ue.__webglFramebuffer),
              s.framebufferTexture2D(
                s.DRAW_FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + pe,
                s.TEXTURE_2D,
                Ye,
                0
              );
          }
        t.bindFramebuffer(
          s.DRAW_FRAMEBUFFER,
          ue.__webglMultisampledFramebuffer
        );
      } else if (R.depthBuffer && R.resolveDepthBuffer === !1 && l) {
        const T = R.stencilBuffer
          ? s.DEPTH_STENCIL_ATTACHMENT
          : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [T]);
      }
    }
  }
  function Fe(R) {
    return Math.min(i.maxSamples, R.samples);
  }
  function V(R) {
    const T = n.get(R);
    return (
      R.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      T.__useRenderToTexture !== !1
    );
  }
  function be(R) {
    const T = o.render.frame;
    h.get(R) !== T && (h.set(R, T), R.update());
  }
  function st(R, T) {
    const Y = R.colorSpace,
      Q = R.format,
      J = R.type;
    return (
      R.isCompressedTexture === !0 ||
        R.isVideoTexture === !0 ||
        (Y !== pn &&
          Y !== Mr &&
          (at.getTransfer(Y) === xt
            ? (Q !== si || J !== or) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                Y
              ))),
      T
    );
  }
  function Re(R) {
    return (
      typeof HTMLImageElement < "u" && R instanceof HTMLImageElement
        ? ((c.width = R.naturalWidth || R.width),
          (c.height = R.naturalHeight || R.height))
        : typeof VideoFrame < "u" && R instanceof VideoFrame
        ? ((c.width = R.displayWidth), (c.height = R.displayHeight))
        : ((c.width = R.width), (c.height = R.height)),
      c
    );
  }
  (this.allocateTextureUnit = O),
    (this.resetTextureUnits = I),
    (this.setTexture2D = G),
    (this.setTexture2DArray = z),
    (this.setTexture3D = q),
    (this.setTextureCube = H),
    (this.rebindTextures = Ve),
    (this.setupRenderTarget = Qe),
    (this.updateRenderTargetMipmap = Ge),
    (this.updateMultisampleRenderTarget = Mt),
    (this.setupDepthRenderbuffer = we),
    (this.setupFrameBufferTexture = ge),
    (this.useMultisampledRTT = V);
}
function iS(s, e) {
  function t(n, i = Mr) {
    let r;
    const o = at.getTransfer(i);
    if (n === or) return s.UNSIGNED_BYTE;
    if (n === wu) return s.UNSIGNED_SHORT_4_4_4_4;
    if (n === Ru) return s.UNSIGNED_SHORT_5_5_5_1;
    if (n === Bp) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (n === Op) return s.BYTE;
    if (n === Fp) return s.SHORT;
    if (n === ca) return s.UNSIGNED_SHORT;
    if (n === Au) return s.INT;
    if (n === cs) return s.UNSIGNED_INT;
    if (n === Dn) return s.FLOAT;
    if (n === Kn) return s.HALF_FLOAT;
    if (n === kp) return s.ALPHA;
    if (n === zp) return s.RGB;
    if (n === si) return s.RGBA;
    if (n === Hp) return s.LUMINANCE;
    if (n === Vp) return s.LUMINANCE_ALPHA;
    if (n === qs) return s.DEPTH_COMPONENT;
    if (n === ao) return s.DEPTH_STENCIL;
    if (n === Cu) return s.RED;
    if (n === Pu) return s.RED_INTEGER;
    if (n === Gp) return s.RG;
    if (n === Du) return s.RG_INTEGER;
    if (n === Lu) return s.RGBA_INTEGER;
    if (n === vl || n === xl || n === yl || n === Ml)
      if (o === xt)
        if (((r = e.get("WEBGL_compressed_texture_s3tc_srgb")), r !== null)) {
          if (n === vl) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === xl) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === yl) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Ml) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((r = e.get("WEBGL_compressed_texture_s3tc")), r !== null)) {
        if (n === vl) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === xl) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === yl) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Ml) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === xh || n === yh || n === Mh || n === Sh)
      if (((r = e.get("WEBGL_compressed_texture_pvrtc")), r !== null)) {
        if (n === xh) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === yh) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === Mh) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === Sh) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (n === Th || n === Eh || n === bh)
      if (((r = e.get("WEBGL_compressed_texture_etc")), r !== null)) {
        if (n === Th || n === Eh)
          return o === xt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (n === bh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      n === Ah ||
      n === wh ||
      n === Rh ||
      n === Ch ||
      n === Ph ||
      n === Dh ||
      n === Lh ||
      n === Ih ||
      n === Uh ||
      n === Nh ||
      n === Oh ||
      n === Fh ||
      n === Bh ||
      n === kh
    )
      if (((r = e.get("WEBGL_compressed_texture_astc")), r !== null)) {
        if (n === Ah)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === wh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === Rh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === Ch)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Ph)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Dh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === Lh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === Ih)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Uh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Nh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Oh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Fh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Bh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === kh)
          return o === xt
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === Sl || n === zh || n === Hh)
      if (((r = e.get("EXT_texture_compression_bptc")), r !== null)) {
        if (n === Sl)
          return o === xt
            ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === zh) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Hh) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === Wp || n === Vh || n === Gh || n === Wh)
      if (((r = e.get("EXT_texture_compression_rgtc")), r !== null)) {
        if (n === Sl) return r.COMPRESSED_RED_RGTC1_EXT;
        if (n === Vh) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Gh) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Wh) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === oo ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null;
  }
  return { convert: t };
}
class rS extends Tn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Jr extends Ut {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const sS = { type: "move" };
class Oc {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Jr()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Jr()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new F()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new F())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Jr()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new F()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new F())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      r = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const g of e.hand.values()) {
          const m = t.getJointPose(g, n),
            p = this._getHandJoint(c, g);
          m !== null &&
            (p.matrix.fromArray(m.transform.matrix),
            p.matrix.decompose(p.position, p.rotation, p.scale),
            (p.matrixWorldNeedsUpdate = !0),
            (p.jointRadius = m.radius)),
            (p.visible = m !== null);
        }
        const h = c.joints["index-finger-tip"],
          u = c.joints["thumb-tip"],
          f = h.position.distanceTo(u.position),
          d = 0.02,
          _ = 0.005;
        c.inputState.pinching && f > d + _
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            f <= d - _ &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((r = t.getPose(e.gripSpace, n)),
          r !== null &&
            (l.matrix.fromArray(r.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            r.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(r.linearVelocity))
              : (l.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(r.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && r !== null && (i = r),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(sS)));
    }
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = r !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Jr();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
const oS = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  aS = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class lS {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new nn(),
        r = e.properties.get(i);
      (r.__webglTexture = t.texture),
        (t.depthNear != n.depthNear || t.depthFar != n.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        n = new In({
          vertexShader: oS,
          fragmentShader: aS,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new Ln(new Ql(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class cS extends ms {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      r = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      h = null,
      u = null,
      f = null,
      d = null,
      _ = null;
    const g = new lS(),
      m = t.getContextAttributes();
    let p = null,
      M = null;
    const S = [],
      v = [],
      C = new De();
    let w = null;
    const E = new Tn();
    E.viewport = new ft();
    const A = new Tn();
    A.viewport = new ft();
    const y = [E, A],
      x = new rS();
    let P = null,
      I = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (K) {
        let te = S[K];
        return (
          te === void 0 && ((te = new Oc()), (S[K] = te)),
          te.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (K) {
        let te = S[K];
        return (
          te === void 0 && ((te = new Oc()), (S[K] = te)), te.getGripSpace()
        );
      }),
      (this.getHand = function (K) {
        let te = S[K];
        return (
          te === void 0 && ((te = new Oc()), (S[K] = te)), te.getHandSpace()
        );
      });
    function O(K) {
      const te = v.indexOf(K.inputSource);
      if (te === -1) return;
      const ge = S[te];
      ge !== void 0 &&
        (ge.update(K.inputSource, K.frame, c || o),
        ge.dispatchEvent({ type: K.type, data: K.inputSource }));
    }
    function k() {
      i.removeEventListener("select", O),
        i.removeEventListener("selectstart", O),
        i.removeEventListener("selectend", O),
        i.removeEventListener("squeeze", O),
        i.removeEventListener("squeezestart", O),
        i.removeEventListener("squeezeend", O),
        i.removeEventListener("end", k),
        i.removeEventListener("inputsourceschange", G);
      for (let K = 0; K < S.length; K++) {
        const te = v[K];
        te !== null && ((v[K] = null), S[K].disconnect(te));
      }
      (P = null),
        (I = null),
        g.reset(),
        e.setRenderTarget(p),
        (d = null),
        (f = null),
        (u = null),
        (i = null),
        (M = null),
        Ue.stop(),
        (n.isPresenting = !1),
        e.setPixelRatio(w),
        e.setSize(C.width, C.height, !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (K) {
      (r = K),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (K) {
        (a = K),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (K) {
        c = K;
      }),
      (this.getBaseLayer = function () {
        return f !== null ? f : d;
      }),
      (this.getBinding = function () {
        return u;
      }),
      (this.getFrame = function () {
        return _;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (K) {
        if (((i = K), i !== null)) {
          if (
            ((p = e.getRenderTarget()),
            i.addEventListener("select", O),
            i.addEventListener("selectstart", O),
            i.addEventListener("selectend", O),
            i.addEventListener("squeeze", O),
            i.addEventListener("squeezestart", O),
            i.addEventListener("squeezeend", O),
            i.addEventListener("end", k),
            i.addEventListener("inputsourceschange", G),
            m.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (w = e.getPixelRatio()),
            e.getSize(C),
            i.renderState.layers === void 0)
          ) {
            const te = {
              antialias: m.antialias,
              alpha: !0,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: r,
            };
            (d = new XRWebGLLayer(i, t, te)),
              i.updateRenderState({ baseLayer: d }),
              e.setPixelRatio(1),
              e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
              (M = new xi(d.framebufferWidth, d.framebufferHeight, {
                format: si,
                type: or,
                colorSpace: e.outputColorSpace,
                stencilBuffer: m.stencil,
              }));
          } else {
            let te = null,
              ge = null,
              ne = null;
            m.depth &&
              ((ne = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (te = m.stencil ? ao : qs),
              (ge = m.stencil ? oo : cs));
            const Ee = {
              colorFormat: t.RGBA8,
              depthFormat: ne,
              scaleFactor: r,
            };
            (u = new XRWebGLBinding(i, t)),
              (f = u.createProjectionLayer(Ee)),
              i.updateRenderState({ layers: [f] }),
              e.setPixelRatio(1),
              e.setSize(f.textureWidth, f.textureHeight, !1),
              (M = new xi(f.textureWidth, f.textureHeight, {
                format: si,
                type: or,
                depthTexture: new om(
                  f.textureWidth,
                  f.textureHeight,
                  ge,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  te
                ),
                stencilBuffer: m.stencil,
                colorSpace: e.outputColorSpace,
                samples: m.antialias ? 4 : 0,
                resolveDepthBuffer: f.ignoreDepthValues === !1,
              }));
          }
          (M.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await i.requestReferenceSpace(a)),
            Ue.setContext(i),
            Ue.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return g.getDepthTexture();
      });
    function G(K) {
      for (let te = 0; te < K.removed.length; te++) {
        const ge = K.removed[te],
          ne = v.indexOf(ge);
        ne >= 0 && ((v[ne] = null), S[ne].disconnect(ge));
      }
      for (let te = 0; te < K.added.length; te++) {
        const ge = K.added[te];
        let ne = v.indexOf(ge);
        if (ne === -1) {
          for (let we = 0; we < S.length; we++)
            if (we >= v.length) {
              v.push(ge), (ne = we);
              break;
            } else if (v[we] === null) {
              (v[we] = ge), (ne = we);
              break;
            }
          if (ne === -1) break;
        }
        const Ee = S[ne];
        Ee && Ee.connect(ge);
      }
    }
    const z = new F(),
      q = new F();
    function H(K, te, ge) {
      z.setFromMatrixPosition(te.matrixWorld),
        q.setFromMatrixPosition(ge.matrixWorld);
      const ne = z.distanceTo(q),
        Ee = te.projectionMatrix.elements,
        we = ge.projectionMatrix.elements,
        Ve = Ee[14] / (Ee[10] - 1),
        Qe = Ee[14] / (Ee[10] + 1),
        Ge = (Ee[9] + 1) / Ee[5],
        Le = (Ee[9] - 1) / Ee[5],
        U = (Ee[8] - 1) / Ee[0],
        Mt = (we[8] + 1) / we[0],
        Fe = Ve * U,
        V = Ve * Mt,
        be = ne / (-U + Mt),
        st = be * -U;
      if (
        (te.matrixWorld.decompose(K.position, K.quaternion, K.scale),
        K.translateX(st),
        K.translateZ(be),
        K.matrixWorld.compose(K.position, K.quaternion, K.scale),
        K.matrixWorldInverse.copy(K.matrixWorld).invert(),
        Ee[10] === -1)
      )
        K.projectionMatrix.copy(te.projectionMatrix),
          K.projectionMatrixInverse.copy(te.projectionMatrixInverse);
      else {
        const Re = Ve + be,
          R = Qe + be,
          T = Fe - st,
          Y = V + (ne - st),
          Q = ((Ge * Qe) / R) * Re,
          J = ((Le * Qe) / R) * Re;
        K.projectionMatrix.makePerspective(T, Y, Q, J, Re, R),
          K.projectionMatrixInverse.copy(K.projectionMatrix).invert();
      }
    }
    function ee(K, te) {
      te === null
        ? K.matrixWorld.copy(K.matrix)
        : K.matrixWorld.multiplyMatrices(te.matrixWorld, K.matrix),
        K.matrixWorldInverse.copy(K.matrixWorld).invert();
    }
    this.updateCamera = function (K) {
      if (i === null) return;
      let te = K.near,
        ge = K.far;
      g.texture !== null &&
        (g.depthNear > 0 && (te = g.depthNear),
        g.depthFar > 0 && (ge = g.depthFar)),
        (x.near = A.near = E.near = te),
        (x.far = A.far = E.far = ge),
        (P !== x.near || I !== x.far) &&
          (i.updateRenderState({ depthNear: x.near, depthFar: x.far }),
          (P = x.near),
          (I = x.far)),
        (E.layers.mask = K.layers.mask | 2),
        (A.layers.mask = K.layers.mask | 4),
        (x.layers.mask = E.layers.mask | A.layers.mask);
      const ne = K.parent,
        Ee = x.cameras;
      ee(x, ne);
      for (let we = 0; we < Ee.length; we++) ee(Ee[we], ne);
      Ee.length === 2
        ? H(x, E, A)
        : x.projectionMatrix.copy(E.projectionMatrix),
        D(K, x, ne);
    };
    function D(K, te, ge) {
      ge === null
        ? K.matrix.copy(te.matrixWorld)
        : (K.matrix.copy(ge.matrixWorld),
          K.matrix.invert(),
          K.matrix.multiply(te.matrixWorld)),
        K.matrix.decompose(K.position, K.quaternion, K.scale),
        K.updateMatrixWorld(!0),
        K.projectionMatrix.copy(te.projectionMatrix),
        K.projectionMatrixInverse.copy(te.projectionMatrixInverse),
        K.isPerspectiveCamera &&
          ((K.fov = lo * 2 * Math.atan(1 / K.projectionMatrix.elements[5])),
          (K.zoom = 1));
    }
    (this.getCamera = function () {
      return x;
    }),
      (this.getFoveation = function () {
        if (!(f === null && d === null)) return l;
      }),
      (this.setFoveation = function (K) {
        (l = K),
          f !== null && (f.fixedFoveation = K),
          d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = K);
      }),
      (this.hasDepthSensing = function () {
        return g.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return g.getMesh(x);
      });
    let oe = null;
    function Me(K, te) {
      if (((h = te.getViewerPose(c || o)), (_ = te), h !== null)) {
        const ge = h.views;
        d !== null &&
          (e.setRenderTargetFramebuffer(M, d.framebuffer),
          e.setRenderTarget(M));
        let ne = !1;
        ge.length !== x.cameras.length && ((x.cameras.length = 0), (ne = !0));
        for (let we = 0; we < ge.length; we++) {
          const Ve = ge[we];
          let Qe = null;
          if (d !== null) Qe = d.getViewport(Ve);
          else {
            const Le = u.getViewSubImage(f, Ve);
            (Qe = Le.viewport),
              we === 0 &&
                (e.setRenderTargetTextures(
                  M,
                  Le.colorTexture,
                  f.ignoreDepthValues ? void 0 : Le.depthStencilTexture
                ),
                e.setRenderTarget(M));
          }
          let Ge = y[we];
          Ge === void 0 &&
            ((Ge = new Tn()),
            Ge.layers.enable(we),
            (Ge.viewport = new ft()),
            (y[we] = Ge)),
            Ge.matrix.fromArray(Ve.transform.matrix),
            Ge.matrix.decompose(Ge.position, Ge.quaternion, Ge.scale),
            Ge.projectionMatrix.fromArray(Ve.projectionMatrix),
            Ge.projectionMatrixInverse.copy(Ge.projectionMatrix).invert(),
            Ge.viewport.set(Qe.x, Qe.y, Qe.width, Qe.height),
            we === 0 &&
              (x.matrix.copy(Ge.matrix),
              x.matrix.decompose(x.position, x.quaternion, x.scale)),
            ne === !0 && x.cameras.push(Ge);
        }
        const Ee = i.enabledFeatures;
        if (Ee && Ee.includes("depth-sensing")) {
          const we = u.getDepthInformation(ge[0]);
          we && we.isValid && we.texture && g.init(e, we, i.renderState);
        }
      }
      for (let ge = 0; ge < S.length; ge++) {
        const ne = v[ge],
          Ee = S[ge];
        ne !== null && Ee !== void 0 && Ee.update(ne, te, c || o);
      }
      oe && oe(K, te),
        te.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: te }),
        (_ = null);
    }
    const Ue = new sm();
    Ue.setAnimationLoop(Me),
      (this.setAnimationLoop = function (K) {
        oe = K;
      }),
      (this.dispose = function () {});
  }
}
const Vr = new Oi(),
  hS = new Ze();
function uS(s, e) {
  function t(m, p) {
    m.matrixAutoUpdate === !0 && m.updateMatrix(), p.value.copy(m.matrix);
  }
  function n(m, p) {
    p.color.getRGB(m.fogColor.value, nm(s)),
      p.isFog
        ? ((m.fogNear.value = p.near), (m.fogFar.value = p.far))
        : p.isFogExp2 && (m.fogDensity.value = p.density);
  }
  function i(m, p, M, S, v) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial
      ? r(m, p)
      : p.isMeshToonMaterial
      ? (r(m, p), u(m, p))
      : p.isMeshPhongMaterial
      ? (r(m, p), h(m, p))
      : p.isMeshStandardMaterial
      ? (r(m, p), f(m, p), p.isMeshPhysicalMaterial && d(m, p, v))
      : p.isMeshMatcapMaterial
      ? (r(m, p), _(m, p))
      : p.isMeshDepthMaterial
      ? r(m, p)
      : p.isMeshDistanceMaterial
      ? (r(m, p), g(m, p))
      : p.isMeshNormalMaterial
      ? r(m, p)
      : p.isLineBasicMaterial
      ? (o(m, p), p.isLineDashedMaterial && a(m, p))
      : p.isPointsMaterial
      ? l(m, p, M, S)
      : p.isSpriteMaterial
      ? c(m, p)
      : p.isShadowMaterial
      ? (m.color.value.copy(p.color), (m.opacity.value = p.opacity))
      : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function r(m, p) {
    (m.opacity.value = p.opacity),
      p.color && m.diffuse.value.copy(p.color),
      p.emissive &&
        m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
      p.map && ((m.map.value = p.map), t(p.map, m.mapTransform)),
      p.alphaMap &&
        ((m.alphaMap.value = p.alphaMap), t(p.alphaMap, m.alphaMapTransform)),
      p.bumpMap &&
        ((m.bumpMap.value = p.bumpMap),
        t(p.bumpMap, m.bumpMapTransform),
        (m.bumpScale.value = p.bumpScale),
        p.side === Un && (m.bumpScale.value *= -1)),
      p.normalMap &&
        ((m.normalMap.value = p.normalMap),
        t(p.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(p.normalScale),
        p.side === Un && m.normalScale.value.negate()),
      p.displacementMap &&
        ((m.displacementMap.value = p.displacementMap),
        t(p.displacementMap, m.displacementMapTransform),
        (m.displacementScale.value = p.displacementScale),
        (m.displacementBias.value = p.displacementBias)),
      p.emissiveMap &&
        ((m.emissiveMap.value = p.emissiveMap),
        t(p.emissiveMap, m.emissiveMapTransform)),
      p.specularMap &&
        ((m.specularMap.value = p.specularMap),
        t(p.specularMap, m.specularMapTransform)),
      p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
    const M = e.get(p),
      S = M.envMap,
      v = M.envMapRotation;
    S &&
      ((m.envMap.value = S),
      Vr.copy(v),
      (Vr.x *= -1),
      (Vr.y *= -1),
      (Vr.z *= -1),
      S.isCubeTexture &&
        S.isRenderTargetTexture === !1 &&
        ((Vr.y *= -1), (Vr.z *= -1)),
      m.envMapRotation.value.setFromMatrix4(hS.makeRotationFromEuler(Vr)),
      (m.flipEnvMap.value =
        S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
      (m.reflectivity.value = p.reflectivity),
      (m.ior.value = p.ior),
      (m.refractionRatio.value = p.refractionRatio)),
      p.lightMap &&
        ((m.lightMap.value = p.lightMap),
        (m.lightMapIntensity.value = p.lightMapIntensity),
        t(p.lightMap, m.lightMapTransform)),
      p.aoMap &&
        ((m.aoMap.value = p.aoMap),
        (m.aoMapIntensity.value = p.aoMapIntensity),
        t(p.aoMap, m.aoMapTransform));
  }
  function o(m, p) {
    m.diffuse.value.copy(p.color),
      (m.opacity.value = p.opacity),
      p.map && ((m.map.value = p.map), t(p.map, m.mapTransform));
  }
  function a(m, p) {
    (m.dashSize.value = p.dashSize),
      (m.totalSize.value = p.dashSize + p.gapSize),
      (m.scale.value = p.scale);
  }
  function l(m, p, M, S) {
    m.diffuse.value.copy(p.color),
      (m.opacity.value = p.opacity),
      (m.size.value = p.size * M),
      (m.scale.value = S * 0.5),
      p.map && ((m.map.value = p.map), t(p.map, m.uvTransform)),
      p.alphaMap &&
        ((m.alphaMap.value = p.alphaMap), t(p.alphaMap, m.alphaMapTransform)),
      p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
  }
  function c(m, p) {
    m.diffuse.value.copy(p.color),
      (m.opacity.value = p.opacity),
      (m.rotation.value = p.rotation),
      p.map && ((m.map.value = p.map), t(p.map, m.mapTransform)),
      p.alphaMap &&
        ((m.alphaMap.value = p.alphaMap), t(p.alphaMap, m.alphaMapTransform)),
      p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
  }
  function h(m, p) {
    m.specular.value.copy(p.specular),
      (m.shininess.value = Math.max(p.shininess, 1e-4));
  }
  function u(m, p) {
    p.gradientMap && (m.gradientMap.value = p.gradientMap);
  }
  function f(m, p) {
    (m.metalness.value = p.metalness),
      p.metalnessMap &&
        ((m.metalnessMap.value = p.metalnessMap),
        t(p.metalnessMap, m.metalnessMapTransform)),
      (m.roughness.value = p.roughness),
      p.roughnessMap &&
        ((m.roughnessMap.value = p.roughnessMap),
        t(p.roughnessMap, m.roughnessMapTransform)),
      p.envMap && (m.envMapIntensity.value = p.envMapIntensity);
  }
  function d(m, p, M) {
    (m.ior.value = p.ior),
      p.sheen > 0 &&
        (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        (m.sheenRoughness.value = p.sheenRoughness),
        p.sheenColorMap &&
          ((m.sheenColorMap.value = p.sheenColorMap),
          t(p.sheenColorMap, m.sheenColorMapTransform)),
        p.sheenRoughnessMap &&
          ((m.sheenRoughnessMap.value = p.sheenRoughnessMap),
          t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
      p.clearcoat > 0 &&
        ((m.clearcoat.value = p.clearcoat),
        (m.clearcoatRoughness.value = p.clearcoatRoughness),
        p.clearcoatMap &&
          ((m.clearcoatMap.value = p.clearcoatMap),
          t(p.clearcoatMap, m.clearcoatMapTransform)),
        p.clearcoatRoughnessMap &&
          ((m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
          t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap &&
          ((m.clearcoatNormalMap.value = p.clearcoatNormalMap),
          t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform),
          m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
          p.side === Un && m.clearcoatNormalScale.value.negate())),
      p.dispersion > 0 && (m.dispersion.value = p.dispersion),
      p.iridescence > 0 &&
        ((m.iridescence.value = p.iridescence),
        (m.iridescenceIOR.value = p.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1]),
        p.iridescenceMap &&
          ((m.iridescenceMap.value = p.iridescenceMap),
          t(p.iridescenceMap, m.iridescenceMapTransform)),
        p.iridescenceThicknessMap &&
          ((m.iridescenceThicknessMap.value = p.iridescenceThicknessMap),
          t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
      p.transmission > 0 &&
        ((m.transmission.value = p.transmission),
        (m.transmissionSamplerMap.value = M.texture),
        m.transmissionSamplerSize.value.set(M.width, M.height),
        p.transmissionMap &&
          ((m.transmissionMap.value = p.transmissionMap),
          t(p.transmissionMap, m.transmissionMapTransform)),
        (m.thickness.value = p.thickness),
        p.thicknessMap &&
          ((m.thicknessMap.value = p.thicknessMap),
          t(p.thicknessMap, m.thicknessMapTransform)),
        (m.attenuationDistance.value = p.attenuationDistance),
        m.attenuationColor.value.copy(p.attenuationColor)),
      p.anisotropy > 0 &&
        (m.anisotropyVector.value.set(
          p.anisotropy * Math.cos(p.anisotropyRotation),
          p.anisotropy * Math.sin(p.anisotropyRotation)
        ),
        p.anisotropyMap &&
          ((m.anisotropyMap.value = p.anisotropyMap),
          t(p.anisotropyMap, m.anisotropyMapTransform))),
      (m.specularIntensity.value = p.specularIntensity),
      m.specularColor.value.copy(p.specularColor),
      p.specularColorMap &&
        ((m.specularColorMap.value = p.specularColorMap),
        t(p.specularColorMap, m.specularColorMapTransform)),
      p.specularIntensityMap &&
        ((m.specularIntensityMap.value = p.specularIntensityMap),
        t(p.specularIntensityMap, m.specularIntensityMapTransform));
  }
  function _(m, p) {
    p.matcap && (m.matcap.value = p.matcap);
  }
  function g(m, p) {
    const M = e.get(p).light;
    m.referencePosition.value.setFromMatrixPosition(M.matrixWorld),
      (m.nearDistance.value = M.shadow.camera.near),
      (m.farDistance.value = M.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function fS(s, e, t, n) {
  let i = {},
    r = {},
    o = [];
  const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(M, S) {
    const v = S.program;
    n.uniformBlockBinding(M, v);
  }
  function c(M, S) {
    let v = i[M.id];
    v === void 0 &&
      (_(M), (v = h(M)), (i[M.id] = v), M.addEventListener("dispose", m));
    const C = S.program;
    n.updateUBOMapping(M, C);
    const w = e.render.frame;
    r[M.id] !== w && (f(M), (r[M.id] = w));
  }
  function h(M) {
    const S = u();
    M.__bindingPointIndex = S;
    const v = s.createBuffer(),
      C = M.__size,
      w = M.usage;
    return (
      s.bindBuffer(s.UNIFORM_BUFFER, v),
      s.bufferData(s.UNIFORM_BUFFER, C, w),
      s.bindBuffer(s.UNIFORM_BUFFER, null),
      s.bindBufferBase(s.UNIFORM_BUFFER, S, v),
      v
    );
  }
  function u() {
    for (let M = 0; M < a; M++) if (o.indexOf(M) === -1) return o.push(M), M;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function f(M) {
    const S = i[M.id],
      v = M.uniforms,
      C = M.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, S);
    for (let w = 0, E = v.length; w < E; w++) {
      const A = Array.isArray(v[w]) ? v[w] : [v[w]];
      for (let y = 0, x = A.length; y < x; y++) {
        const P = A[y];
        if (d(P, w, y, C) === !0) {
          const I = P.__offset,
            O = Array.isArray(P.value) ? P.value : [P.value];
          let k = 0;
          for (let G = 0; G < O.length; G++) {
            const z = O[G],
              q = g(z);
            typeof z == "number" || typeof z == "boolean"
              ? ((P.__data[0] = z),
                s.bufferSubData(s.UNIFORM_BUFFER, I + k, P.__data))
              : z.isMatrix3
              ? ((P.__data[0] = z.elements[0]),
                (P.__data[1] = z.elements[1]),
                (P.__data[2] = z.elements[2]),
                (P.__data[3] = 0),
                (P.__data[4] = z.elements[3]),
                (P.__data[5] = z.elements[4]),
                (P.__data[6] = z.elements[5]),
                (P.__data[7] = 0),
                (P.__data[8] = z.elements[6]),
                (P.__data[9] = z.elements[7]),
                (P.__data[10] = z.elements[8]),
                (P.__data[11] = 0))
              : (z.toArray(P.__data, k),
                (k += q.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          s.bufferSubData(s.UNIFORM_BUFFER, I, P.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function d(M, S, v, C) {
    const w = M.value,
      E = S + "_" + v;
    if (C[E] === void 0)
      return (
        typeof w == "number" || typeof w == "boolean"
          ? (C[E] = w)
          : (C[E] = w.clone()),
        !0
      );
    {
      const A = C[E];
      if (typeof w == "number" || typeof w == "boolean") {
        if (A !== w) return (C[E] = w), !0;
      } else if (A.equals(w) === !1) return A.copy(w), !0;
    }
    return !1;
  }
  function _(M) {
    const S = M.uniforms;
    let v = 0;
    const C = 16;
    for (let E = 0, A = S.length; E < A; E++) {
      const y = Array.isArray(S[E]) ? S[E] : [S[E]];
      for (let x = 0, P = y.length; x < P; x++) {
        const I = y[x],
          O = Array.isArray(I.value) ? I.value : [I.value];
        for (let k = 0, G = O.length; k < G; k++) {
          const z = O[k],
            q = g(z),
            H = v % C,
            ee = H % q.boundary,
            D = H + ee;
          (v += ee),
            D !== 0 && C - D < q.storage && (v += C - D),
            (I.__data = new Float32Array(
              q.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (I.__offset = v),
            (v += q.storage);
        }
      }
    }
    const w = v % C;
    return w > 0 && (v += C - w), (M.__size = v), (M.__cache = {}), this;
  }
  function g(M) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof M == "number" || typeof M == "boolean"
        ? ((S.boundary = 4), (S.storage = 4))
        : M.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : M.isVector3 || M.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : M.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : M.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : M.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : M.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            M
          ),
      S
    );
  }
  function m(M) {
    const S = M.target;
    S.removeEventListener("dispose", m);
    const v = o.indexOf(S.__bindingPointIndex);
    o.splice(v, 1), s.deleteBuffer(i[S.id]), delete i[S.id], delete r[S.id];
  }
  function p() {
    for (const M in i) s.deleteBuffer(i[M]);
    (o = []), (i = {}), (r = {});
  }
  return { bind: l, update: c, dispose: p };
}
class dS {
  constructor(e = {}) {
    const {
      canvas: t = Qg(),
      context: n = null,
      depth: i = !0,
      stencil: r = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: u = !1,
      reverseDepthBuffer: f = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let d;
    if (n !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      d = n.getContextAttributes().alpha;
    } else d = o;
    const _ = new Uint32Array(4),
      g = new Int32Array(4);
    let m = null,
      p = null;
    const M = [],
      S = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = sn),
      (this.toneMapping = Cr),
      (this.toneMappingExposure = 1);
    const v = this;
    let C = !1,
      w = 0,
      E = 0,
      A = null,
      y = -1,
      x = null;
    const P = new ft(),
      I = new ft();
    let O = null;
    const k = new He(0);
    let G = 0,
      z = t.width,
      q = t.height,
      H = 1,
      ee = null,
      D = null;
    const oe = new ft(0, 0, z, q),
      Me = new ft(0, 0, z, q);
    let Ue = !1;
    const K = new Uu();
    let te = !1,
      ge = !1;
    const ne = new Ze(),
      Ee = new Ze(),
      we = new F(),
      Ve = new ft(),
      Qe = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let Ge = !1;
    function Le() {
      return A === null ? H : 1;
    }
    let U = n;
    function Mt(b, N) {
      return t.getContext(b, N);
    }
    try {
      const b = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: u,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${bu}`),
        t.addEventListener("webglcontextlost", Z, !1),
        t.addEventListener("webglcontextrestored", ce, !1),
        t.addEventListener("webglcontextcreationerror", fe, !1),
        U === null)
      ) {
        const N = "webgl2";
        if (((U = Mt(N, b)), U === null))
          throw Mt(N)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (b) {
      throw (console.error("THREE.WebGLRenderer: " + b.message), b);
    }
    let Fe,
      V,
      be,
      st,
      Re,
      R,
      T,
      Y,
      Q,
      J,
      $,
      ue,
      le,
      pe,
      Ye,
      ie,
      ae,
      Ne,
      Ie,
      xe,
      je,
      Oe,
      ct,
      L;
    function he() {
      (Fe = new vy(U)),
        Fe.init(),
        (Oe = new iS(U, Fe)),
        (V = new fy(U, Fe, e, Oe)),
        (be = new eS(U, Fe)),
        V.reverseDepthBuffer && f && be.buffers.depth.setReversed(!0),
        (st = new My(U)),
        (Re = new kM()),
        (R = new nS(U, Fe, be, Re, V, Oe, st)),
        (T = new py(v)),
        (Y = new gy(v)),
        (Q = new R0(U)),
        (ct = new hy(U, Q)),
        (J = new xy(U, Q, st, ct)),
        ($ = new Ty(U, J, Q, st)),
        (Ie = new Sy(U, V, R)),
        (ie = new dy(Re)),
        (ue = new BM(v, T, Y, Fe, V, ct, ie)),
        (le = new uS(v, Re)),
        (pe = new HM()),
        (Ye = new qM(Fe)),
        (Ne = new cy(v, T, Y, be, $, d, l)),
        (ae = new JM(v, $, V)),
        (L = new fS(U, st, V, be)),
        (xe = new uy(U, Fe, st)),
        (je = new yy(U, Fe, st)),
        (st.programs = ue.programs),
        (v.capabilities = V),
        (v.extensions = Fe),
        (v.properties = Re),
        (v.renderLists = pe),
        (v.shadowMap = ae),
        (v.state = be),
        (v.info = st);
    }
    he();
    const j = new cS(v, U);
    (this.xr = j),
      (this.getContext = function () {
        return U;
      }),
      (this.getContextAttributes = function () {
        return U.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const b = Fe.get("WEBGL_lose_context");
        b && b.loseContext();
      }),
      (this.forceContextRestore = function () {
        const b = Fe.get("WEBGL_lose_context");
        b && b.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return H;
      }),
      (this.setPixelRatio = function (b) {
        b !== void 0 && ((H = b), this.setSize(z, q, !1));
      }),
      (this.getSize = function (b) {
        return b.set(z, q);
      }),
      (this.setSize = function (b, N, W = !0) {
        if (j.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (z = b),
          (q = N),
          (t.width = Math.floor(b * H)),
          (t.height = Math.floor(N * H)),
          W === !0 && ((t.style.width = b + "px"), (t.style.height = N + "px")),
          this.setViewport(0, 0, b, N);
      }),
      (this.getDrawingBufferSize = function (b) {
        return b.set(z * H, q * H).floor();
      }),
      (this.setDrawingBufferSize = function (b, N, W) {
        (z = b),
          (q = N),
          (H = W),
          (t.width = Math.floor(b * W)),
          (t.height = Math.floor(N * W)),
          this.setViewport(0, 0, b, N);
      }),
      (this.getCurrentViewport = function (b) {
        return b.copy(P);
      }),
      (this.getViewport = function (b) {
        return b.copy(oe);
      }),
      (this.setViewport = function (b, N, W, X) {
        b.isVector4 ? oe.set(b.x, b.y, b.z, b.w) : oe.set(b, N, W, X),
          be.viewport(P.copy(oe).multiplyScalar(H).round());
      }),
      (this.getScissor = function (b) {
        return b.copy(Me);
      }),
      (this.setScissor = function (b, N, W, X) {
        b.isVector4 ? Me.set(b.x, b.y, b.z, b.w) : Me.set(b, N, W, X),
          be.scissor(I.copy(Me).multiplyScalar(H).round());
      }),
      (this.getScissorTest = function () {
        return Ue;
      }),
      (this.setScissorTest = function (b) {
        be.setScissorTest((Ue = b));
      }),
      (this.setOpaqueSort = function (b) {
        ee = b;
      }),
      (this.setTransparentSort = function (b) {
        D = b;
      }),
      (this.getClearColor = function (b) {
        return b.copy(Ne.getClearColor());
      }),
      (this.setClearColor = function () {
        Ne.setClearColor.apply(Ne, arguments);
      }),
      (this.getClearAlpha = function () {
        return Ne.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Ne.setClearAlpha.apply(Ne, arguments);
      }),
      (this.clear = function (b = !0, N = !0, W = !0) {
        let X = 0;
        if (b) {
          let B = !1;
          if (A !== null) {
            const re = A.texture.format;
            B = re === Lu || re === Du || re === Pu;
          }
          if (B) {
            const re = A.texture.type,
              se =
                re === or ||
                re === cs ||
                re === ca ||
                re === oo ||
                re === wu ||
                re === Ru,
              de = Ne.getClearColor(),
              ye = Ne.getClearAlpha(),
              ke = de.r,
              Xe = de.g,
              Te = de.b;
            se
              ? ((_[0] = ke),
                (_[1] = Xe),
                (_[2] = Te),
                (_[3] = ye),
                U.clearBufferuiv(U.COLOR, 0, _))
              : ((g[0] = ke),
                (g[1] = Xe),
                (g[2] = Te),
                (g[3] = ye),
                U.clearBufferiv(U.COLOR, 0, g));
          } else X |= U.COLOR_BUFFER_BIT;
        }
        N && (X |= U.DEPTH_BUFFER_BIT),
          W &&
            ((X |= U.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          U.clear(X);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Z, !1),
          t.removeEventListener("webglcontextrestored", ce, !1),
          t.removeEventListener("webglcontextcreationerror", fe, !1),
          pe.dispose(),
          Ye.dispose(),
          Re.dispose(),
          T.dispose(),
          Y.dispose(),
          $.dispose(),
          ct.dispose(),
          L.dispose(),
          ue.dispose(),
          j.dispose(),
          j.removeEventListener("sessionstart", me),
          j.removeEventListener("sessionend", We),
          Ce.stop();
      });
    function Z(b) {
      b.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (C = !0);
    }
    function ce() {
      console.log("THREE.WebGLRenderer: Context Restored."), (C = !1);
      const b = st.autoReset,
        N = ae.enabled,
        W = ae.autoUpdate,
        X = ae.needsUpdate,
        B = ae.type;
      he(),
        (st.autoReset = b),
        (ae.enabled = N),
        (ae.autoUpdate = W),
        (ae.needsUpdate = X),
        (ae.type = B);
    }
    function fe(b) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        b.statusMessage
      );
    }
    function Be(b) {
      const N = b.target;
      N.removeEventListener("dispose", Be), ht(N);
    }
    function ht(b) {
      Nt(b), Re.remove(b);
    }
    function Nt(b) {
      const N = Re.get(b).programs;
      N !== void 0 &&
        (N.forEach(function (W) {
          ue.releaseProgram(W);
        }),
        b.isShaderMaterial && ue.releaseShaderCache(b));
    }
    this.renderBufferDirect = function (b, N, W, X, B, re) {
      N === null && (N = Qe);
      const se = B.isMesh && B.matrixWorld.determinant() < 0,
        de = zn(b, N, W, X, B);
      be.setMaterial(X, se);
      let ye = W.index,
        ke = 1;
      if (X.wireframe === !0) {
        if (((ye = J.getWireframeAttribute(W)), ye === void 0)) return;
        ke = 2;
      }
      const Xe = W.drawRange,
        Te = W.attributes.position;
      let qe = Xe.start * ke,
        ut = (Xe.start + Xe.count) * ke;
      re !== null &&
        ((qe = Math.max(qe, re.start * ke)),
        (ut = Math.min(ut, (re.start + re.count) * ke))),
        ye !== null
          ? ((qe = Math.max(qe, 0)), (ut = Math.min(ut, ye.count)))
          : Te != null &&
            ((qe = Math.max(qe, 0)), (ut = Math.min(ut, Te.count)));
      const pt = ut - qe;
      if (pt < 0 || pt === 1 / 0) return;
      ct.setup(B, X, de, W, ye);
      let zt,
        mt = xe;
      if (
        (ye !== null && ((zt = Q.get(ye)), (mt = je), mt.setIndex(zt)),
        B.isMesh)
      )
        X.wireframe === !0
          ? (be.setLineWidth(X.wireframeLinewidth * Le()), mt.setMode(U.LINES))
          : mt.setMode(U.TRIANGLES);
      else if (B.isLine) {
        let Pe = X.linewidth;
        Pe === void 0 && (Pe = 1),
          be.setLineWidth(Pe * Le()),
          B.isLineSegments
            ? mt.setMode(U.LINES)
            : B.isLineLoop
            ? mt.setMode(U.LINE_LOOP)
            : mt.setMode(U.LINE_STRIP);
      } else
        B.isPoints
          ? mt.setMode(U.POINTS)
          : B.isSprite && mt.setMode(U.TRIANGLES);
      if (B.isBatchedMesh)
        if (B._multiDrawInstances !== null)
          mt.renderMultiDrawInstances(
            B._multiDrawStarts,
            B._multiDrawCounts,
            B._multiDrawCount,
            B._multiDrawInstances
          );
        else if (Fe.get("WEBGL_multi_draw"))
          mt.renderMultiDraw(
            B._multiDrawStarts,
            B._multiDrawCounts,
            B._multiDrawCount
          );
        else {
          const Pe = B._multiDrawStarts,
            Hi = B._multiDrawCounts,
            _t = B._multiDrawCount,
            hi = ye ? Q.get(ye).bytesPerElement : 1,
            xs = Re.get(X).currentProgram.getUniforms();
          for (let Hn = 0; Hn < _t; Hn++)
            xs.setValue(U, "_gl_DrawID", Hn), mt.render(Pe[Hn] / hi, Hi[Hn]);
        }
      else if (B.isInstancedMesh) mt.renderInstances(qe, pt, B.count);
      else if (W.isInstancedBufferGeometry) {
        const Pe = W._maxInstanceCount !== void 0 ? W._maxInstanceCount : 1 / 0,
          Hi = Math.min(W.instanceCount, Pe);
        mt.renderInstances(qe, pt, Hi);
      } else mt.render(qe, pt);
    };
    function ve(b, N, W) {
      b.transparent === !0 && b.side === Ai && b.forceSinglePass === !1
        ? ((b.side = Un),
          (b.needsUpdate = !0),
          St(b, N, W),
          (b.side = sr),
          (b.needsUpdate = !0),
          St(b, N, W),
          (b.side = Ai))
        : St(b, N, W);
    }
    (this.compile = function (b, N, W = null) {
      W === null && (W = b),
        (p = Ye.get(W)),
        p.init(N),
        S.push(p),
        W.traverseVisible(function (B) {
          B.isLight &&
            B.layers.test(N.layers) &&
            (p.pushLight(B), B.castShadow && p.pushShadow(B));
        }),
        b !== W &&
          b.traverseVisible(function (B) {
            B.isLight &&
              B.layers.test(N.layers) &&
              (p.pushLight(B), B.castShadow && p.pushShadow(B));
          }),
        p.setupLights();
      const X = new Set();
      return (
        b.traverse(function (B) {
          if (!(B.isMesh || B.isPoints || B.isLine || B.isSprite)) return;
          const re = B.material;
          if (re)
            if (Array.isArray(re))
              for (let se = 0; se < re.length; se++) {
                const de = re[se];
                ve(de, W, B), X.add(de);
              }
            else ve(re, W, B), X.add(re);
        }),
        S.pop(),
        (p = null),
        X
      );
    }),
      (this.compileAsync = function (b, N, W = null) {
        const X = this.compile(b, N, W);
        return new Promise((B) => {
          function re() {
            if (
              (X.forEach(function (se) {
                Re.get(se).currentProgram.isReady() && X.delete(se);
              }),
              X.size === 0)
            ) {
              B(b);
              return;
            }
            setTimeout(re, 10);
          }
          Fe.get("KHR_parallel_shader_compile") !== null
            ? re()
            : setTimeout(re, 10);
        });
      });
    let Ae = null;
    function Ke(b) {
      Ae && Ae(b);
    }
    function me() {
      Ce.stop();
    }
    function We() {
      Ce.start();
    }
    const Ce = new sm();
    Ce.setAnimationLoop(Ke),
      typeof self < "u" && Ce.setContext(self),
      (this.setAnimationLoop = function (b) {
        (Ae = b), j.setAnimationLoop(b), b === null ? Ce.stop() : Ce.start();
      }),
      j.addEventListener("sessionstart", me),
      j.addEventListener("sessionend", We),
      (this.render = function (b, N) {
        if (N !== void 0 && N.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (C === !0) return;
        if (
          (b.matrixWorldAutoUpdate === !0 && b.updateMatrixWorld(),
          N.parent === null &&
            N.matrixWorldAutoUpdate === !0 &&
            N.updateMatrixWorld(),
          j.enabled === !0 &&
            j.isPresenting === !0 &&
            (j.cameraAutoUpdate === !0 && j.updateCamera(N),
            (N = j.getCamera())),
          b.isScene === !0 && b.onBeforeRender(v, b, N, A),
          (p = Ye.get(b, S.length)),
          p.init(N),
          S.push(p),
          Ee.multiplyMatrices(N.projectionMatrix, N.matrixWorldInverse),
          K.setFromProjectionMatrix(Ee),
          (ge = this.localClippingEnabled),
          (te = ie.init(this.clippingPlanes, ge)),
          (m = pe.get(b, M.length)),
          m.init(),
          M.push(m),
          j.enabled === !0 && j.isPresenting === !0)
        ) {
          const re = v.xr.getDepthSensingMesh();
          re !== null && ze(re, N, -1 / 0, v.sortObjects);
        }
        ze(b, N, 0, v.sortObjects),
          m.finish(),
          v.sortObjects === !0 && m.sort(ee, D),
          (Ge =
            j.enabled === !1 ||
            j.isPresenting === !1 ||
            j.hasDepthSensing() === !1),
          Ge && Ne.addToRenderList(m, b),
          this.info.render.frame++,
          te === !0 && ie.beginShadows();
        const W = p.state.shadowsArray;
        ae.render(W, b, N),
          te === !0 && ie.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const X = m.opaque,
          B = m.transmissive;
        if ((p.setupLights(), N.isArrayCamera)) {
          const re = N.cameras;
          if (B.length > 0)
            for (let se = 0, de = re.length; se < de; se++) {
              const ye = re[se];
              et(X, B, b, ye);
            }
          Ge && Ne.render(b);
          for (let se = 0, de = re.length; se < de; se++) {
            const ye = re[se];
            Ft(m, b, ye, ye.viewport);
          }
        } else B.length > 0 && et(X, B, b, N), Ge && Ne.render(b), Ft(m, b, N);
        A !== null &&
          (R.updateMultisampleRenderTarget(A), R.updateRenderTargetMipmap(A)),
          b.isScene === !0 && b.onAfterRender(v, b, N),
          ct.resetDefaultState(),
          (y = -1),
          (x = null),
          S.pop(),
          S.length > 0
            ? ((p = S[S.length - 1]),
              te === !0 && ie.setGlobalState(v.clippingPlanes, p.state.camera))
            : (p = null),
          M.pop(),
          M.length > 0 ? (m = M[M.length - 1]) : (m = null);
      });
    function ze(b, N, W, X) {
      if (b.visible === !1) return;
      if (b.layers.test(N.layers)) {
        if (b.isGroup) W = b.renderOrder;
        else if (b.isLOD) b.autoUpdate === !0 && b.update(N);
        else if (b.isLight) p.pushLight(b), b.castShadow && p.pushShadow(b);
        else if (b.isSprite) {
          if (!b.frustumCulled || K.intersectsSprite(b)) {
            X && Ve.setFromMatrixPosition(b.matrixWorld).applyMatrix4(Ee);
            const se = $.update(b),
              de = b.material;
            de.visible && m.push(b, se, de, W, Ve.z, null);
          }
        } else if (
          (b.isMesh || b.isLine || b.isPoints) &&
          (!b.frustumCulled || K.intersectsObject(b))
        ) {
          const se = $.update(b),
            de = b.material;
          if (
            (X &&
              (b.boundingSphere !== void 0
                ? (b.boundingSphere === null && b.computeBoundingSphere(),
                  Ve.copy(b.boundingSphere.center))
                : (se.boundingSphere === null && se.computeBoundingSphere(),
                  Ve.copy(se.boundingSphere.center)),
              Ve.applyMatrix4(b.matrixWorld).applyMatrix4(Ee)),
            Array.isArray(de))
          ) {
            const ye = se.groups;
            for (let ke = 0, Xe = ye.length; ke < Xe; ke++) {
              const Te = ye[ke],
                qe = de[Te.materialIndex];
              qe && qe.visible && m.push(b, se, qe, W, Ve.z, Te);
            }
          } else de.visible && m.push(b, se, de, W, Ve.z, null);
        }
      }
      const re = b.children;
      for (let se = 0, de = re.length; se < de; se++) ze(re[se], N, W, X);
    }
    function Ft(b, N, W, X) {
      const B = b.opaque,
        re = b.transmissive,
        se = b.transparent;
      p.setupLightsView(W),
        te === !0 && ie.setGlobalState(v.clippingPlanes, W),
        X && be.viewport(P.copy(X)),
        B.length > 0 && bt(B, N, W),
        re.length > 0 && bt(re, N, W),
        se.length > 0 && bt(se, N, W),
        be.buffers.depth.setTest(!0),
        be.buffers.depth.setMask(!0),
        be.buffers.color.setMask(!0),
        be.setPolygonOffset(!1);
    }
    function et(b, N, W, X) {
      if ((W.isScene === !0 ? W.overrideMaterial : null) !== null) return;
      p.state.transmissionRenderTarget[X.id] === void 0 &&
        (p.state.transmissionRenderTarget[X.id] = new xi(1, 1, {
          generateMipmaps: !0,
          type:
            Fe.has("EXT_color_buffer_half_float") ||
            Fe.has("EXT_color_buffer_float")
              ? Kn
              : or,
          minFilter: Ci,
          samples: 4,
          stencilBuffer: r,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: at.workingColorSpace,
        }));
      const re = p.state.transmissionRenderTarget[X.id],
        se = X.viewport || P;
      re.setSize(se.z, se.w);
      const de = v.getRenderTarget();
      v.setRenderTarget(re),
        v.getClearColor(k),
        (G = v.getClearAlpha()),
        G < 1 && v.setClearColor(16777215, 0.5),
        v.clear(),
        Ge && Ne.render(W);
      const ye = v.toneMapping;
      v.toneMapping = Cr;
      const ke = X.viewport;
      if (
        (X.viewport !== void 0 && (X.viewport = void 0),
        p.setupLightsView(X),
        te === !0 && ie.setGlobalState(v.clippingPlanes, X),
        bt(b, W, X),
        R.updateMultisampleRenderTarget(re),
        R.updateRenderTargetMipmap(re),
        Fe.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Xe = !1;
        for (let Te = 0, qe = N.length; Te < qe; Te++) {
          const ut = N[Te],
            pt = ut.object,
            zt = ut.geometry,
            mt = ut.material,
            Pe = ut.group;
          if (mt.side === Ai && pt.layers.test(X.layers)) {
            const Hi = mt.side;
            (mt.side = Un),
              (mt.needsUpdate = !0),
              Wt(pt, W, X, zt, mt, Pe),
              (mt.side = Hi),
              (mt.needsUpdate = !0),
              (Xe = !0);
          }
        }
        Xe === !0 &&
          (R.updateMultisampleRenderTarget(re), R.updateRenderTargetMipmap(re));
      }
      v.setRenderTarget(de),
        v.setClearColor(k, G),
        ke !== void 0 && (X.viewport = ke),
        (v.toneMapping = ye);
    }
    function bt(b, N, W) {
      const X = N.isScene === !0 ? N.overrideMaterial : null;
      for (let B = 0, re = b.length; B < re; B++) {
        const se = b[B],
          de = se.object,
          ye = se.geometry,
          ke = X === null ? se.material : X,
          Xe = se.group;
        de.layers.test(W.layers) && Wt(de, N, W, ye, ke, Xe);
      }
    }
    function Wt(b, N, W, X, B, re) {
      b.onBeforeRender(v, N, W, X, B, re),
        b.modelViewMatrix.multiplyMatrices(W.matrixWorldInverse, b.matrixWorld),
        b.normalMatrix.getNormalMatrix(b.modelViewMatrix),
        B.onBeforeRender(v, N, W, X, b, re),
        B.transparent === !0 && B.side === Ai && B.forceSinglePass === !1
          ? ((B.side = Un),
            (B.needsUpdate = !0),
            v.renderBufferDirect(W, N, X, B, b, re),
            (B.side = sr),
            (B.needsUpdate = !0),
            v.renderBufferDirect(W, N, X, B, b, re),
            (B.side = Ai))
          : v.renderBufferDirect(W, N, X, B, b, re),
        b.onAfterRender(v, N, W, X, B, re);
    }
    function St(b, N, W) {
      N.isScene !== !0 && (N = Qe);
      const X = Re.get(b),
        B = p.state.lights,
        re = p.state.shadowsArray,
        se = B.state.version,
        de = ue.getParameters(b, B.state, re, N, W),
        ye = ue.getProgramCacheKey(de);
      let ke = X.programs;
      (X.environment = b.isMeshStandardMaterial ? N.environment : null),
        (X.fog = N.fog),
        (X.envMap = (b.isMeshStandardMaterial ? Y : T).get(
          b.envMap || X.environment
        )),
        (X.envMapRotation =
          X.environment !== null && b.envMap === null
            ? N.environmentRotation
            : b.envMapRotation),
        ke === void 0 &&
          (b.addEventListener("dispose", Be),
          (ke = new Map()),
          (X.programs = ke));
      let Xe = ke.get(ye);
      if (Xe !== void 0) {
        if (X.currentProgram === Xe && X.lightsStateVersion === se)
          return dt(b, de), Xe;
      } else
        (de.uniforms = ue.getUniforms(b)),
          b.onBeforeCompile(de, v),
          (Xe = ue.acquireProgram(de, ye)),
          ke.set(ye, Xe),
          (X.uniforms = de.uniforms);
      const Te = X.uniforms;
      return (
        ((!b.isShaderMaterial && !b.isRawShaderMaterial) ||
          b.clipping === !0) &&
          (Te.clippingPlanes = ie.uniform),
        dt(b, de),
        (X.needsLights = mn(b)),
        (X.lightsStateVersion = se),
        X.needsLights &&
          ((Te.ambientLightColor.value = B.state.ambient),
          (Te.lightProbe.value = B.state.probe),
          (Te.directionalLights.value = B.state.directional),
          (Te.directionalLightShadows.value = B.state.directionalShadow),
          (Te.spotLights.value = B.state.spot),
          (Te.spotLightShadows.value = B.state.spotShadow),
          (Te.rectAreaLights.value = B.state.rectArea),
          (Te.ltc_1.value = B.state.rectAreaLTC1),
          (Te.ltc_2.value = B.state.rectAreaLTC2),
          (Te.pointLights.value = B.state.point),
          (Te.pointLightShadows.value = B.state.pointShadow),
          (Te.hemisphereLights.value = B.state.hemi),
          (Te.directionalShadowMap.value = B.state.directionalShadowMap),
          (Te.directionalShadowMatrix.value = B.state.directionalShadowMatrix),
          (Te.spotShadowMap.value = B.state.spotShadowMap),
          (Te.spotLightMatrix.value = B.state.spotLightMatrix),
          (Te.spotLightMap.value = B.state.spotLightMap),
          (Te.pointShadowMap.value = B.state.pointShadowMap),
          (Te.pointShadowMatrix.value = B.state.pointShadowMatrix)),
        (X.currentProgram = Xe),
        (X.uniformsList = null),
        Xe
      );
    }
    function Tt(b) {
      if (b.uniformsList === null) {
        const N = b.currentProgram.getUniforms();
        b.uniformsList = Tl.seqWithValue(N.seq, b.uniforms);
      }
      return b.uniformsList;
    }
    function dt(b, N) {
      const W = Re.get(b);
      (W.outputColorSpace = N.outputColorSpace),
        (W.batching = N.batching),
        (W.batchingColor = N.batchingColor),
        (W.instancing = N.instancing),
        (W.instancingColor = N.instancingColor),
        (W.instancingMorph = N.instancingMorph),
        (W.skinning = N.skinning),
        (W.morphTargets = N.morphTargets),
        (W.morphNormals = N.morphNormals),
        (W.morphColors = N.morphColors),
        (W.morphTargetsCount = N.morphTargetsCount),
        (W.numClippingPlanes = N.numClippingPlanes),
        (W.numIntersection = N.numClipIntersection),
        (W.vertexAlphas = N.vertexAlphas),
        (W.vertexTangents = N.vertexTangents),
        (W.toneMapping = N.toneMapping);
    }
    function zn(b, N, W, X, B) {
      N.isScene !== !0 && (N = Qe), R.resetTextureUnits();
      const re = N.fog,
        se = X.isMeshStandardMaterial ? N.environment : null,
        de =
          A === null
            ? v.outputColorSpace
            : A.isXRRenderTarget === !0
            ? A.texture.colorSpace
            : pn,
        ye = (X.isMeshStandardMaterial ? Y : T).get(X.envMap || se),
        ke =
          X.vertexColors === !0 &&
          !!W.attributes.color &&
          W.attributes.color.itemSize === 4,
        Xe = !!W.attributes.tangent && (!!X.normalMap || X.anisotropy > 0),
        Te = !!W.morphAttributes.position,
        qe = !!W.morphAttributes.normal,
        ut = !!W.morphAttributes.color;
      let pt = Cr;
      X.toneMapped &&
        (A === null || A.isXRRenderTarget === !0) &&
        (pt = v.toneMapping);
      const zt =
          W.morphAttributes.position ||
          W.morphAttributes.normal ||
          W.morphAttributes.color,
        mt = zt !== void 0 ? zt.length : 0,
        Pe = Re.get(X),
        Hi = p.state.lights;
      if (te === !0 && (ge === !0 || b !== x)) {
        const Qn = b === x && X.id === y;
        ie.setState(X, b, Qn);
      }
      let _t = !1;
      X.version === Pe.__version
        ? ((Pe.needsLights && Pe.lightsStateVersion !== Hi.state.version) ||
            Pe.outputColorSpace !== de ||
            (B.isBatchedMesh && Pe.batching === !1) ||
            (!B.isBatchedMesh && Pe.batching === !0) ||
            (B.isBatchedMesh &&
              Pe.batchingColor === !0 &&
              B.colorTexture === null) ||
            (B.isBatchedMesh &&
              Pe.batchingColor === !1 &&
              B.colorTexture !== null) ||
            (B.isInstancedMesh && Pe.instancing === !1) ||
            (!B.isInstancedMesh && Pe.instancing === !0) ||
            (B.isSkinnedMesh && Pe.skinning === !1) ||
            (!B.isSkinnedMesh && Pe.skinning === !0) ||
            (B.isInstancedMesh &&
              Pe.instancingColor === !0 &&
              B.instanceColor === null) ||
            (B.isInstancedMesh &&
              Pe.instancingColor === !1 &&
              B.instanceColor !== null) ||
            (B.isInstancedMesh &&
              Pe.instancingMorph === !0 &&
              B.morphTexture === null) ||
            (B.isInstancedMesh &&
              Pe.instancingMorph === !1 &&
              B.morphTexture !== null) ||
            Pe.envMap !== ye ||
            (X.fog === !0 && Pe.fog !== re) ||
            (Pe.numClippingPlanes !== void 0 &&
              (Pe.numClippingPlanes !== ie.numPlanes ||
                Pe.numIntersection !== ie.numIntersection)) ||
            Pe.vertexAlphas !== ke ||
            Pe.vertexTangents !== Xe ||
            Pe.morphTargets !== Te ||
            Pe.morphNormals !== qe ||
            Pe.morphColors !== ut ||
            Pe.toneMapping !== pt ||
            Pe.morphTargetsCount !== mt) &&
          (_t = !0)
        : ((_t = !0), (Pe.__version = X.version));
      let hi = Pe.currentProgram;
      _t === !0 && (hi = St(X, N, B));
      let xs = !1,
        Hn = !1,
        Eo = !1;
      const Rt = hi.getUniforms(),
        Si = Pe.uniforms;
      if (
        (be.useProgram(hi.program) && ((xs = !0), (Hn = !0), (Eo = !0)),
        X.id !== y && ((y = X.id), (Hn = !0)),
        xs || x !== b)
      ) {
        be.buffers.depth.getReversed()
          ? (ne.copy(b.projectionMatrix),
            t0(ne),
            n0(ne),
            Rt.setValue(U, "projectionMatrix", ne))
          : Rt.setValue(U, "projectionMatrix", b.projectionMatrix),
          Rt.setValue(U, "viewMatrix", b.matrixWorldInverse);
        const hr = Rt.map.cameraPosition;
        hr !== void 0 &&
          hr.setValue(U, we.setFromMatrixPosition(b.matrixWorld)),
          V.logarithmicDepthBuffer &&
            Rt.setValue(
              U,
              "logDepthBufFC",
              2 / (Math.log(b.far + 1) / Math.LN2)
            ),
          (X.isMeshPhongMaterial ||
            X.isMeshToonMaterial ||
            X.isMeshLambertMaterial ||
            X.isMeshBasicMaterial ||
            X.isMeshStandardMaterial ||
            X.isShaderMaterial) &&
            Rt.setValue(U, "isOrthographic", b.isOrthographicCamera === !0),
          x !== b && ((x = b), (Hn = !0), (Eo = !0));
      }
      if (B.isSkinnedMesh) {
        Rt.setOptional(U, B, "bindMatrix"),
          Rt.setOptional(U, B, "bindMatrixInverse");
        const Qn = B.skeleton;
        Qn &&
          (Qn.boneTexture === null && Qn.computeBoneTexture(),
          Rt.setValue(U, "boneTexture", Qn.boneTexture, R));
      }
      B.isBatchedMesh &&
        (Rt.setOptional(U, B, "batchingTexture"),
        Rt.setValue(U, "batchingTexture", B._matricesTexture, R),
        Rt.setOptional(U, B, "batchingIdTexture"),
        Rt.setValue(U, "batchingIdTexture", B._indirectTexture, R),
        Rt.setOptional(U, B, "batchingColorTexture"),
        B._colorsTexture !== null &&
          Rt.setValue(U, "batchingColorTexture", B._colorsTexture, R));
      const bo = W.morphAttributes;
      if (
        ((bo.position !== void 0 ||
          bo.normal !== void 0 ||
          bo.color !== void 0) &&
          Ie.update(B, W, hi),
        (Hn || Pe.receiveShadow !== B.receiveShadow) &&
          ((Pe.receiveShadow = B.receiveShadow),
          Rt.setValue(U, "receiveShadow", B.receiveShadow)),
        X.isMeshGouraudMaterial &&
          X.envMap !== null &&
          ((Si.envMap.value = ye),
          (Si.flipEnvMap.value =
            ye.isCubeTexture && ye.isRenderTargetTexture === !1 ? -1 : 1)),
        X.isMeshStandardMaterial &&
          X.envMap === null &&
          N.environment !== null &&
          (Si.envMapIntensity.value = N.environmentIntensity),
        Hn &&
          (Rt.setValue(U, "toneMappingExposure", v.toneMappingExposure),
          Pe.needsLights && wt(Si, Eo),
          re && X.fog === !0 && le.refreshFogUniforms(Si, re),
          le.refreshMaterialUniforms(
            Si,
            X,
            H,
            q,
            p.state.transmissionRenderTarget[b.id]
          ),
          Tl.upload(U, Tt(Pe), Si, R)),
        X.isShaderMaterial &&
          X.uniformsNeedUpdate === !0 &&
          (Tl.upload(U, Tt(Pe), Si, R), (X.uniformsNeedUpdate = !1)),
        X.isSpriteMaterial && Rt.setValue(U, "center", B.center),
        Rt.setValue(U, "modelViewMatrix", B.modelViewMatrix),
        Rt.setValue(U, "normalMatrix", B.normalMatrix),
        Rt.setValue(U, "modelMatrix", B.matrixWorld),
        X.isShaderMaterial || X.isRawShaderMaterial)
      ) {
        const Qn = X.uniformsGroups;
        for (let hr = 0, ur = Qn.length; hr < ur; hr++) {
          const gf = Qn[hr];
          L.update(gf, hi), L.bind(gf, hi);
        }
      }
      return hi;
    }
    function wt(b, N) {
      (b.ambientLightColor.needsUpdate = N),
        (b.lightProbe.needsUpdate = N),
        (b.directionalLights.needsUpdate = N),
        (b.directionalLightShadows.needsUpdate = N),
        (b.pointLights.needsUpdate = N),
        (b.pointLightShadows.needsUpdate = N),
        (b.spotLights.needsUpdate = N),
        (b.spotLightShadows.needsUpdate = N),
        (b.rectAreaLights.needsUpdate = N),
        (b.hemisphereLights.needsUpdate = N);
    }
    function mn(b) {
      return (
        b.isMeshLambertMaterial ||
        b.isMeshToonMaterial ||
        b.isMeshPhongMaterial ||
        b.isMeshStandardMaterial ||
        b.isShadowMaterial ||
        (b.isShaderMaterial && b.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return w;
    }),
      (this.getActiveMipmapLevel = function () {
        return E;
      }),
      (this.getRenderTarget = function () {
        return A;
      }),
      (this.setRenderTargetTextures = function (b, N, W) {
        (Re.get(b.texture).__webglTexture = N),
          (Re.get(b.depthTexture).__webglTexture = W);
        const X = Re.get(b);
        (X.__hasExternalTextures = !0),
          (X.__autoAllocateDepthBuffer = W === void 0),
          X.__autoAllocateDepthBuffer ||
            (Fe.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (X.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (b, N) {
        const W = Re.get(b);
        (W.__webglFramebuffer = N), (W.__useDefaultFramebuffer = N === void 0);
      }),
      (this.setRenderTarget = function (b, N = 0, W = 0) {
        (A = b), (w = N), (E = W);
        let X = !0,
          B = null,
          re = !1,
          se = !1;
        if (b) {
          const ye = Re.get(b);
          if (ye.__useDefaultFramebuffer !== void 0)
            be.bindFramebuffer(U.FRAMEBUFFER, null), (X = !1);
          else if (ye.__webglFramebuffer === void 0) R.setupRenderTarget(b);
          else if (ye.__hasExternalTextures)
            R.rebindTextures(
              b,
              Re.get(b.texture).__webglTexture,
              Re.get(b.depthTexture).__webglTexture
            );
          else if (b.depthBuffer) {
            const Te = b.depthTexture;
            if (ye.__boundDepthTexture !== Te) {
              if (
                Te !== null &&
                Re.has(Te) &&
                (b.width !== Te.image.width || b.height !== Te.image.height)
              )
                throw new Error(
                  "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
                );
              R.setupDepthRenderbuffer(b);
            }
          }
          const ke = b.texture;
          (ke.isData3DTexture ||
            ke.isDataArrayTexture ||
            ke.isCompressedArrayTexture) &&
            (se = !0);
          const Xe = Re.get(b).__webglFramebuffer;
          b.isWebGLCubeRenderTarget
            ? (Array.isArray(Xe[N]) ? (B = Xe[N][W]) : (B = Xe[N]), (re = !0))
            : b.samples > 0 && R.useMultisampledRTT(b) === !1
            ? (B = Re.get(b).__webglMultisampledFramebuffer)
            : Array.isArray(Xe)
            ? (B = Xe[W])
            : (B = Xe),
            P.copy(b.viewport),
            I.copy(b.scissor),
            (O = b.scissorTest);
        } else
          P.copy(oe).multiplyScalar(H).floor(),
            I.copy(Me).multiplyScalar(H).floor(),
            (O = Ue);
        if (
          (be.bindFramebuffer(U.FRAMEBUFFER, B) && X && be.drawBuffers(b, B),
          be.viewport(P),
          be.scissor(I),
          be.setScissorTest(O),
          re)
        ) {
          const ye = Re.get(b.texture);
          U.framebufferTexture2D(
            U.FRAMEBUFFER,
            U.COLOR_ATTACHMENT0,
            U.TEXTURE_CUBE_MAP_POSITIVE_X + N,
            ye.__webglTexture,
            W
          );
        } else if (se) {
          const ye = Re.get(b.texture),
            ke = N || 0;
          U.framebufferTextureLayer(
            U.FRAMEBUFFER,
            U.COLOR_ATTACHMENT0,
            ye.__webglTexture,
            W || 0,
            ke
          );
        }
        y = -1;
      }),
      (this.readRenderTargetPixels = function (b, N, W, X, B, re, se) {
        if (!(b && b.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let de = Re.get(b).__webglFramebuffer;
        if ((b.isWebGLCubeRenderTarget && se !== void 0 && (de = de[se]), de)) {
          be.bindFramebuffer(U.FRAMEBUFFER, de);
          try {
            const ye = b.texture,
              ke = ye.format,
              Xe = ye.type;
            if (!V.textureFormatReadable(ke)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!V.textureTypeReadable(Xe)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            N >= 0 &&
              N <= b.width - X &&
              W >= 0 &&
              W <= b.height - B &&
              U.readPixels(N, W, X, B, Oe.convert(ke), Oe.convert(Xe), re);
          } finally {
            const ye = A !== null ? Re.get(A).__webglFramebuffer : null;
            be.bindFramebuffer(U.FRAMEBUFFER, ye);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        b,
        N,
        W,
        X,
        B,
        re,
        se
      ) {
        if (!(b && b.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let de = Re.get(b).__webglFramebuffer;
        if ((b.isWebGLCubeRenderTarget && se !== void 0 && (de = de[se]), de)) {
          const ye = b.texture,
            ke = ye.format,
            Xe = ye.type;
          if (!V.textureFormatReadable(ke))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
            );
          if (!V.textureTypeReadable(Xe))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          if (N >= 0 && N <= b.width - X && W >= 0 && W <= b.height - B) {
            be.bindFramebuffer(U.FRAMEBUFFER, de);
            const Te = U.createBuffer();
            U.bindBuffer(U.PIXEL_PACK_BUFFER, Te),
              U.bufferData(U.PIXEL_PACK_BUFFER, re.byteLength, U.STREAM_READ),
              U.readPixels(N, W, X, B, Oe.convert(ke), Oe.convert(Xe), 0);
            const qe = A !== null ? Re.get(A).__webglFramebuffer : null;
            be.bindFramebuffer(U.FRAMEBUFFER, qe);
            const ut = U.fenceSync(U.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              U.flush(),
              await e0(U, ut, 4),
              U.bindBuffer(U.PIXEL_PACK_BUFFER, Te),
              U.getBufferSubData(U.PIXEL_PACK_BUFFER, 0, re),
              U.deleteBuffer(Te),
              U.deleteSync(ut),
              re
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
        }
      }),
      (this.copyFramebufferToTexture = function (b, N = null, W = 0) {
        b.isTexture !== !0 &&
          (ko(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (N = arguments[0] || null),
          (b = arguments[1]));
        const X = Math.pow(2, -W),
          B = Math.floor(b.image.width * X),
          re = Math.floor(b.image.height * X),
          se = N !== null ? N.x : 0,
          de = N !== null ? N.y : 0;
        R.setTexture2D(b, 0),
          U.copyTexSubImage2D(U.TEXTURE_2D, W, 0, 0, se, de, B, re),
          be.unbindTexture();
      }),
      (this.copyTextureToTexture = function (b, N, W = null, X = null, B = 0) {
        b.isTexture !== !0 &&
          (ko(
            "WebGLRenderer: copyTextureToTexture function signature has changed."
          ),
          (X = arguments[0] || null),
          (b = arguments[1]),
          (N = arguments[2]),
          (B = arguments[3] || 0),
          (W = null));
        let re, se, de, ye, ke, Xe, Te, qe, ut;
        const pt = b.isCompressedTexture ? b.mipmaps[B] : b.image;
        W !== null
          ? ((re = W.max.x - W.min.x),
            (se = W.max.y - W.min.y),
            (de = W.isBox3 ? W.max.z - W.min.z : 1),
            (ye = W.min.x),
            (ke = W.min.y),
            (Xe = W.isBox3 ? W.min.z : 0))
          : ((re = pt.width),
            (se = pt.height),
            (de = pt.depth || 1),
            (ye = 0),
            (ke = 0),
            (Xe = 0)),
          X !== null
            ? ((Te = X.x), (qe = X.y), (ut = X.z))
            : ((Te = 0), (qe = 0), (ut = 0));
        const zt = Oe.convert(N.format),
          mt = Oe.convert(N.type);
        let Pe;
        N.isData3DTexture
          ? (R.setTexture3D(N, 0), (Pe = U.TEXTURE_3D))
          : N.isDataArrayTexture || N.isCompressedArrayTexture
          ? (R.setTexture2DArray(N, 0), (Pe = U.TEXTURE_2D_ARRAY))
          : (R.setTexture2D(N, 0), (Pe = U.TEXTURE_2D)),
          U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL, N.flipY),
          U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
          U.pixelStorei(U.UNPACK_ALIGNMENT, N.unpackAlignment);
        const Hi = U.getParameter(U.UNPACK_ROW_LENGTH),
          _t = U.getParameter(U.UNPACK_IMAGE_HEIGHT),
          hi = U.getParameter(U.UNPACK_SKIP_PIXELS),
          xs = U.getParameter(U.UNPACK_SKIP_ROWS),
          Hn = U.getParameter(U.UNPACK_SKIP_IMAGES);
        U.pixelStorei(U.UNPACK_ROW_LENGTH, pt.width),
          U.pixelStorei(U.UNPACK_IMAGE_HEIGHT, pt.height),
          U.pixelStorei(U.UNPACK_SKIP_PIXELS, ye),
          U.pixelStorei(U.UNPACK_SKIP_ROWS, ke),
          U.pixelStorei(U.UNPACK_SKIP_IMAGES, Xe);
        const Eo = b.isDataArrayTexture || b.isData3DTexture,
          Rt = N.isDataArrayTexture || N.isData3DTexture;
        if (b.isRenderTargetTexture || b.isDepthTexture) {
          const Si = Re.get(b),
            bo = Re.get(N),
            Qn = Re.get(Si.__renderTarget),
            hr = Re.get(bo.__renderTarget);
          be.bindFramebuffer(U.READ_FRAMEBUFFER, Qn.__webglFramebuffer),
            be.bindFramebuffer(U.DRAW_FRAMEBUFFER, hr.__webglFramebuffer);
          for (let ur = 0; ur < de; ur++)
            Eo &&
              U.framebufferTextureLayer(
                U.READ_FRAMEBUFFER,
                U.COLOR_ATTACHMENT0,
                Re.get(b).__webglTexture,
                B,
                Xe + ur
              ),
              b.isDepthTexture
                ? (Rt &&
                    U.framebufferTextureLayer(
                      U.DRAW_FRAMEBUFFER,
                      U.COLOR_ATTACHMENT0,
                      Re.get(N).__webglTexture,
                      B,
                      ut + ur
                    ),
                  U.blitFramebuffer(
                    ye,
                    ke,
                    re,
                    se,
                    Te,
                    qe,
                    re,
                    se,
                    U.DEPTH_BUFFER_BIT,
                    U.NEAREST
                  ))
                : Rt
                ? U.copyTexSubImage3D(Pe, B, Te, qe, ut + ur, ye, ke, re, se)
                : U.copyTexSubImage2D(Pe, B, Te, qe, ut + ur, ye, ke, re, se);
          be.bindFramebuffer(U.READ_FRAMEBUFFER, null),
            be.bindFramebuffer(U.DRAW_FRAMEBUFFER, null);
        } else
          Rt
            ? b.isDataTexture || b.isData3DTexture
              ? U.texSubImage3D(Pe, B, Te, qe, ut, re, se, de, zt, mt, pt.data)
              : N.isCompressedArrayTexture
              ? U.compressedTexSubImage3D(
                  Pe,
                  B,
                  Te,
                  qe,
                  ut,
                  re,
                  se,
                  de,
                  zt,
                  pt.data
                )
              : U.texSubImage3D(Pe, B, Te, qe, ut, re, se, de, zt, mt, pt)
            : b.isDataTexture
            ? U.texSubImage2D(U.TEXTURE_2D, B, Te, qe, re, se, zt, mt, pt.data)
            : b.isCompressedTexture
            ? U.compressedTexSubImage2D(
                U.TEXTURE_2D,
                B,
                Te,
                qe,
                pt.width,
                pt.height,
                zt,
                pt.data
              )
            : U.texSubImage2D(U.TEXTURE_2D, B, Te, qe, re, se, zt, mt, pt);
        U.pixelStorei(U.UNPACK_ROW_LENGTH, Hi),
          U.pixelStorei(U.UNPACK_IMAGE_HEIGHT, _t),
          U.pixelStorei(U.UNPACK_SKIP_PIXELS, hi),
          U.pixelStorei(U.UNPACK_SKIP_ROWS, xs),
          U.pixelStorei(U.UNPACK_SKIP_IMAGES, Hn),
          B === 0 && N.generateMipmaps && U.generateMipmap(Pe),
          be.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (
        b,
        N,
        W = null,
        X = null,
        B = 0
      ) {
        return (
          b.isTexture !== !0 &&
            (ko(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed."
            ),
            (W = arguments[0] || null),
            (X = arguments[1] || null),
            (b = arguments[2]),
            (N = arguments[3]),
            (B = arguments[4] || 0)),
          ko(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(b, N, W, X, B)
        );
      }),
      (this.initRenderTarget = function (b) {
        Re.get(b).__webglFramebuffer === void 0 && R.setupRenderTarget(b);
      }),
      (this.initTexture = function (b) {
        b.isCubeTexture
          ? R.setTextureCube(b, 0)
          : b.isData3DTexture
          ? R.setTexture3D(b, 0)
          : b.isDataArrayTexture || b.isCompressedArrayTexture
          ? R.setTexture2DArray(b, 0)
          : R.setTexture2D(b, 0),
          be.unbindTexture();
      }),
      (this.resetState = function () {
        (w = 0), (E = 0), (A = null), be.reset(), ct.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return er;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorspace = at._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = at._getUnpackColorSpace());
  }
}
class pS extends Ut {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Oi()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Oi()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class mS {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Yh),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = vi());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const _n = new F();
class Ou {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      _n.fromBufferAttribute(this, t),
        _n.applyMatrix4(e),
        this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      _n.fromBufferAttribute(this, t),
        _n.applyNormalMatrix(e),
        this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      _n.fromBufferAttribute(this, t),
        _n.transformDirection(e),
        this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = _i(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = gt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = n),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = gt(t, this.array)), (n = gt(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gt(t, this.array)),
        (n = gt(n, this.array)),
        (i = gt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gt(t, this.array)),
        (n = gt(n, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = r),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
      }
      return new Rn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Ou(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const xd = new F(),
  yd = new ft(),
  Md = new ft(),
  _S = new F(),
  Sd = new Ze(),
  Ka = new F(),
  Fc = new Bi(),
  Td = new Ze(),
  Bc = new Ta();
class gS extends Ln {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = Mf),
      (this.bindMatrix = new Ze()),
      (this.bindMatrixInverse = new Ze()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new cr()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Ka), this.boundingBox.expandByPoint(Ka);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Bi()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Ka), this.boundingSphere.expandByPoint(Ka);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      i = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Fc.copy(this.boundingSphere),
      Fc.applyMatrix4(i),
      e.ray.intersectsSphere(Fc) !== !1 &&
        (Td.copy(i).invert(),
        Bc.copy(e.ray).applyMatrix4(Td),
        !(
          this.boundingBox !== null && Bc.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, Bc)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ft(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === Mf
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === Eg
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    yd.fromBufferAttribute(i.attributes.skinIndex, e),
      Md.fromBufferAttribute(i.attributes.skinWeight, e),
      xd.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const o = Md.getComponent(r);
      if (o !== 0) {
        const a = yd.getComponent(r);
        Sd.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
          t.addScaledVector(_S.copy(xd).applyMatrix4(Sd), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class um extends Ut {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Fu extends nn {
  constructor(e = null, t = 1, n = 1, i, r, o, a, l, c = wn, h = wn, u, f) {
    super(null, o, a, l, c, h, i, r, u, f),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const Ed = new Ze(),
  vS = new Ze();
class Bu {
  constructor(e = [], t = []) {
    (this.uuid = vi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new Ze());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Ze();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r] ? e[r].matrixWorld : vS;
      Ed.multiplyMatrices(a, t[r]), Ed.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Bu(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Fu(t, e, e, si, Dn);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let o = t[r];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", r),
        (o = new um())),
        this.bones.push(o),
        this.boneInverses.push(new Ze().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = n[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class jh extends Rn {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Us = new Ze(),
  bd = new Ze(),
  $a = [],
  Ad = new cr(),
  xS = new Ze(),
  Po = new Ln(),
  Do = new Bi();
class yS extends Ln {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new jh(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, xS);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new cr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Us),
        Ad.copy(e.boundingBox).applyMatrix4(Us),
        this.boundingBox.union(Ad);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Bi()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Us),
        Do.copy(e.boundingSphere).applyMatrix4(Us),
        this.boundingSphere.union(Do);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      r = n.length + 1,
      o = e * r + 1;
    for (let a = 0; a < n.length; a++) n[a] = i[o + a];
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((Po.geometry = this.geometry),
      (Po.material = this.material),
      Po.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Do.copy(this.boundingSphere),
        Do.applyMatrix4(n),
        e.ray.intersectsSphere(Do) !== !1))
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Us),
          bd.multiplyMatrices(n, Us),
          (Po.matrixWorld = bd),
          Po.raycast(e, $a);
        for (let o = 0, a = $a.length; o < a; o++) {
          const l = $a[o];
          (l.instanceId = r), (l.object = this), t.push(l);
        }
        $a.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new jh(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = n.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Fu(
        new Float32Array(i * this.count),
        i,
        this.count,
        Cu,
        Dn
      ));
    const r = this.morphTexture.source.data.data;
    let o = 0;
    for (let c = 0; c < n.length; c++) o += n[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = i * e;
    (r[l] = a), r.set(n, l + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
class fm extends Li {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.color = new He(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Fl = new F(),
  Bl = new F(),
  wd = new Ze(),
  Lo = new Ta(),
  Za = new Bi(),
  kc = new F(),
  Rd = new F();
class ku extends Ut {
  constructor(e = new Mi(), t = new fm()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, r = t.count; i < r; i++)
        Fl.fromBufferAttribute(t, i - 1),
          Bl.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += Fl.distanceTo(Bl));
      e.setAttribute("lineDistance", new yi(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Line.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Za.copy(n.boundingSphere),
      Za.applyMatrix4(i),
      (Za.radius += r),
      e.ray.intersectsSphere(Za) === !1)
    )
      return;
    wd.copy(i).invert(), Lo.copy(e.ray).applyMatrix4(wd);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      h = n.index,
      f = n.attributes.position;
    if (h !== null) {
      const d = Math.max(0, o.start),
        _ = Math.min(h.count, o.start + o.count);
      for (let g = d, m = _ - 1; g < m; g += c) {
        const p = h.getX(g),
          M = h.getX(g + 1),
          S = Ja(this, e, Lo, l, p, M);
        S && t.push(S);
      }
      if (this.isLineLoop) {
        const g = h.getX(_ - 1),
          m = h.getX(d),
          p = Ja(this, e, Lo, l, g, m);
        p && t.push(p);
      }
    } else {
      const d = Math.max(0, o.start),
        _ = Math.min(f.count, o.start + o.count);
      for (let g = d, m = _ - 1; g < m; g += c) {
        const p = Ja(this, e, Lo, l, g, g + 1);
        p && t.push(p);
      }
      if (this.isLineLoop) {
        const g = Ja(this, e, Lo, l, _ - 1, d);
        g && t.push(g);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = r);
        }
      }
    }
  }
}
function Ja(s, e, t, n, i, r) {
  const o = s.geometry.attributes.position;
  if (
    (Fl.fromBufferAttribute(o, i),
    Bl.fromBufferAttribute(o, r),
    t.distanceSqToSegment(Fl, Bl, kc, Rd) > n)
  )
    return;
  kc.applyMatrix4(s.matrixWorld);
  const l = e.ray.origin.distanceTo(kc);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      point: Rd.clone().applyMatrix4(s.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s,
    };
}
const Cd = new F(),
  Pd = new F();
class MS extends ku {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, r = t.count; i < r; i += 2)
        Cd.fromBufferAttribute(t, i),
          Pd.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + Cd.distanceTo(Pd));
      e.setAttribute("lineDistance", new yi(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class SS extends ku {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class dm extends Li {
  static get type() {
    return "PointsMaterial";
  }
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.color = new He(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const Dd = new Ze(),
  Kh = new Ta(),
  Qa = new Bi(),
  el = new F();
class TS extends Ut {
  constructor(e = new Mi(), t = new dm()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Points.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Qa.copy(n.boundingSphere),
      Qa.applyMatrix4(i),
      (Qa.radius += r),
      e.ray.intersectsSphere(Qa) === !1)
    )
      return;
    Dd.copy(i).invert(), Kh.copy(e.ray).applyMatrix4(Dd);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = n.index,
      u = n.attributes.position;
    if (c !== null) {
      const f = Math.max(0, o.start),
        d = Math.min(c.count, o.start + o.count);
      for (let _ = f, g = d; _ < g; _++) {
        const m = c.getX(_);
        el.fromBufferAttribute(u, m), Ld(el, m, l, i, e, t, this);
      }
    } else {
      const f = Math.max(0, o.start),
        d = Math.min(u.count, o.start + o.count);
      for (let _ = f, g = d; _ < g; _++)
        el.fromBufferAttribute(u, _), Ld(el, _, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = r);
        }
      }
    }
  }
}
function Ld(s, e, t, n, i, r, o) {
  const a = Kh.distanceSqToPoint(s);
  if (a < t) {
    const l = new F();
    Kh.closestPointToPoint(s, l), l.applyMatrix4(n);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    });
  }
}
class zu extends Li {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.color = new He(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new He(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yp),
      (this.normalScale = new De(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Oi()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ki extends zu {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new De(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Qt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new He(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new He(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new He(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function tl(s, e, t) {
  return !s || (!t && s.constructor === e)
    ? s
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(s)
    : Array.prototype.slice.call(s);
}
function ES(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function bS(s) {
  function e(i, r) {
    return s[i] - s[r];
  }
  const t = s.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function Id(s, e, t) {
  const n = s.length,
    i = new s.constructor(n);
  for (let r = 0, o = 0; o !== n; ++r) {
    const a = t[r] * e;
    for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
  }
  return i;
}
function pm(s, e, t, n) {
  let i = 1,
    r = s[0];
  for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
  if (r === void 0) return;
  let o = r[n];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = r[n]),
          o !== void 0 && (e.push(r.time), t.push.apply(t, o)),
          (r = s[i++]);
      while (r !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = r[n]),
          o !== void 0 && (e.push(r.time), o.toArray(t, t.length)),
          (r = s[i++]);
      while (r !== void 0);
    else
      do (o = r[n]), o !== void 0 && (e.push(r.time), t.push(o)), (r = s[i++]);
      while (r !== void 0);
}
class ba {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      r = t[n - 1];
    n: {
      e: {
        let o;
        t: {
          i: if (!(e < i)) {
            for (let a = n + 2; ; ) {
              if (i === void 0) {
                if (e < r) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === a) break;
              if (((r = i), (i = t[++n]), e < i)) break e;
            }
            o = t.length;
            break t;
          }
          if (!(e >= r)) {
            const a = t[1];
            e < a && ((n = 2), (r = a));
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === l) break;
              if (((i = r), (r = t[--n - 1]), e >= r)) break e;
            }
            (o = n), (n = 0);
            break t;
          }
          break n;
        }
        for (; n < o; ) {
          const a = (n + o) >>> 1;
          e < t[a] ? (o = a) : (n = a + 1);
        }
        if (((i = t[n]), (r = t[n - 1]), r === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i;
    for (let o = 0; o !== i; ++o) t[o] = n[r + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class AS extends ba {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Sf, endingEnd: Sf });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2,
      o = e + 1,
      a = i[r],
      l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Tf:
          (r = e), (a = 2 * t - n);
          break;
        case Ef:
          (r = i.length - 2), (a = t + i[r] - i[r + 1]);
          break;
        default:
          (r = e), (a = n);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Tf:
          (o = e), (l = 2 * n - t);
          break;
        case Ef:
          (o = 1), (l = n + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const c = (n - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - n)),
      (this._offsetPrev = r * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      h = this._offsetPrev,
      u = this._offsetNext,
      f = this._weightPrev,
      d = this._weightNext,
      _ = (n - t) / (i - t),
      g = _ * _,
      m = g * _,
      p = -f * m + 2 * f * g - f * _,
      M = (1 + f) * m + (-1.5 - 2 * f) * g + (-0.5 + f) * _ + 1,
      S = (-1 - d) * m + (1.5 + d) * g + 0.5 * _,
      v = d * m - d * g;
    for (let C = 0; C !== a; ++C)
      r[C] = p * o[h + C] + M * o[c + C] + S * o[l + C] + v * o[u + C];
    return r;
  }
}
class wS extends ba {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      h = (n - t) / (i - t),
      u = 1 - h;
    for (let f = 0; f !== a; ++f) r[f] = o[c + f] * u + o[l + f] * h;
    return r;
  }
}
class RS extends ba {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class zi {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = tl(t, this.TimeBufferType)),
      (this.values = tl(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: tl(e.times, Array),
        values: tl(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new RS(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new wS(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new AS(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case ha:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ua:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case cc:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return ha;
      case this.InterpolantFactoryMethodLinear:
        return ua;
      case this.InterpolantFactoryMethodSmooth:
        return cc;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let r = 0,
      o = i - 1;
    for (; r !== i && n[r] < e; ) ++r;
    for (; o !== -1 && n[o] > t; ) --o;
    if ((++o, r !== 0 || o !== i)) {
      r >= o && ((o = Math.max(o, 1)), (r = o - 1));
      const a = this.getValueSize();
      (this.times = n.slice(r, o)),
        (this.values = this.values.slice(r * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      r = n.length;
    r === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== r; a++) {
      const l = n[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (i !== void 0 && ES(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.getValueSize(),
      i = this.getInterpolation() === cc,
      r = e.length - 1;
    let o = 1;
    for (let a = 1; a < r; ++a) {
      let l = !1;
      const c = e[a],
        h = e[a + 1];
      if (c !== h && (a !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const u = a * n,
            f = u - n,
            d = u + n;
          for (let _ = 0; _ !== n; ++_) {
            const g = t[u + _];
            if (g !== t[f + _] || g !== t[d + _]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const u = a * n,
            f = o * n;
          for (let d = 0; d !== n; ++d) t[f + d] = t[u + d];
        }
        ++o;
      }
    }
    if (r > 0) {
      e[o] = e[r];
      for (let a = r * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
zi.prototype.TimeBufferType = Float32Array;
zi.prototype.ValueBufferType = Float32Array;
zi.prototype.DefaultInterpolation = ua;
class So extends zi {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
So.prototype.ValueTypeName = "bool";
So.prototype.ValueBufferType = Array;
So.prototype.DefaultInterpolation = ha;
So.prototype.InterpolantFactoryMethodLinear = void 0;
So.prototype.InterpolantFactoryMethodSmooth = void 0;
class mm extends zi {}
mm.prototype.ValueTypeName = "color";
class ho extends zi {}
ho.prototype.ValueTypeName = "number";
class CS extends ba {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (n - t) / (i - t);
    let c = e * a;
    for (let h = c + a; c !== h; c += 4) Ni.slerpFlat(r, 0, o, c - a, o, c, l);
    return r;
  }
}
class uo extends zi {
  InterpolantFactoryMethodLinear(e) {
    return new CS(this.times, this.values, this.getValueSize(), e);
  }
}
uo.prototype.ValueTypeName = "quaternion";
uo.prototype.InterpolantFactoryMethodSmooth = void 0;
class To extends zi {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
To.prototype.ValueTypeName = "string";
To.prototype.ValueBufferType = Array;
To.prototype.DefaultInterpolation = ha;
To.prototype.InterpolantFactoryMethodLinear = void 0;
To.prototype.InterpolantFactoryMethodSmooth = void 0;
class fo extends zi {}
fo.prototype.ValueTypeName = "vector";
class PS {
  constructor(e = "", t = -1, n = [], i = bg) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = vi()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o) t.push(LS(n[o]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return (r.uuid = e.uuid), r;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let r = 0, o = n.length; r !== o; ++r) t.push(zi.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length,
      o = [];
    for (let a = 0; a < r; a++) {
      let l = [],
        c = [];
      l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
      const h = bS(l);
      (l = Id(l, 1, h)),
        (c = Id(c, 1, h)),
        !i && l[0] === 0 && (l.push(r), c.push(c[0])),
        o.push(
          new ho(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        h = c.name.match(r);
      if (h && h.length > 1) {
        const u = h[1];
        let f = i[u];
        f || (i[u] = f = []), f.push(c);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (u, f, d, _, g) {
        if (d.length !== 0) {
          const m = [],
            p = [];
          pm(d, m, p, _), m.length !== 0 && g.push(new u(f, m, p));
        }
      },
      i = [],
      r = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const f = c[u].keys;
      if (!(!f || f.length === 0))
        if (f[0].morphTargets) {
          const d = {};
          let _;
          for (_ = 0; _ < f.length; _++)
            if (f[_].morphTargets)
              for (let g = 0; g < f[_].morphTargets.length; g++)
                d[f[_].morphTargets[g]] = -1;
          for (const g in d) {
            const m = [],
              p = [];
            for (let M = 0; M !== f[_].morphTargets.length; ++M) {
              const S = f[_];
              m.push(S.time), p.push(S.morphTarget === g ? 1 : 0);
            }
            i.push(new ho(".morphTargetInfluence[" + g + "]", m, p));
          }
          l = d.length * o;
        } else {
          const d = ".bones[" + t[u].name + "]";
          n(fo, d + ".position", f, "pos", i),
            n(uo, d + ".quaternion", f, "rot", i),
            n(fo, d + ".scale", f, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(r, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function DS(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return ho;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return fo;
    case "color":
      return mm;
    case "quaternion":
      return uo;
    case "bool":
    case "boolean":
      return So;
    case "string":
      return To;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function LS(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = DS(s.type);
  if (s.times === void 0) {
    const t = [],
      n = [];
    pm(s.keys, t, n, "value"), (s.times = t), (s.values = n);
  }
  return e.parse !== void 0
    ? e.parse(s)
    : new e(s.name, s.times, s.values, s.interpolation);
}
const Tr = {
  enabled: !1,
  files: {},
  add: function (s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function (s) {
    if (this.enabled !== !1) return this.files[s];
  },
  remove: function (s) {
    delete this.files[s];
  },
  clear: function () {
    this.files = {};
  },
};
class IS {
  constructor(e, t, n) {
    const i = this;
    let r = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (h) {
        a++, r === !1 && i.onStart !== void 0 && i.onStart(h, o, a), (r = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          i.onProgress !== void 0 && i.onProgress(h, o, a),
          o === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (l = h), this;
      }),
      (this.addHandler = function (h, u) {
        return c.push(h, u), this;
      }),
      (this.removeHandler = function (h) {
        const u = c.indexOf(h);
        return u !== -1 && c.splice(u, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let u = 0, f = c.length; u < f; u += 2) {
          const d = c[u],
            _ = c[u + 1];
          if ((d.global && (d.lastIndex = 0), d.test(h))) return _;
        }
        return null;
      });
  }
}
const US = new IS();
class _s {
  constructor(e) {
    (this.manager = e !== void 0 ? e : US),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
_s.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const qi = {};
class NS extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Hu extends _s {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = Tr.get(e);
    if (r !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(r), this.manager.itemEnd(e);
        }, 0),
        r
      );
    if (qi[e] !== void 0) {
      qi[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (qi[e] = []), qi[e].push({ onLoad: t, onProgress: n, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const h = qi[e],
            u = c.body.getReader(),
            f = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            d = f ? parseInt(f) : 0,
            _ = d !== 0;
          let g = 0;
          const m = new ReadableStream({
            start(p) {
              M();
              function M() {
                u.read().then(
                  ({ done: S, value: v }) => {
                    if (S) p.close();
                    else {
                      g += v.byteLength;
                      const C = new ProgressEvent("progress", {
                        lengthComputable: _,
                        loaded: g,
                        total: d,
                      });
                      for (let w = 0, E = h.length; w < E; w++) {
                        const A = h[w];
                        A.onProgress && A.onProgress(C);
                      }
                      p.enqueue(v), M();
                    }
                  },
                  (S) => {
                    p.error(S);
                  }
                );
              }
            },
          });
          return new Response(m);
        } else
          throw new NS(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const u = /charset="?([^;"\s]*)"?/i.exec(a),
                f = u && u[1] ? u[1].toLowerCase() : void 0,
                d = new TextDecoder(f);
              return c.arrayBuffer().then((_) => d.decode(_));
            }
        }
      })
      .then((c) => {
        Tr.add(e, c);
        const h = qi[e];
        delete qi[e];
        for (let u = 0, f = h.length; u < f; u++) {
          const d = h[u];
          d.onLoad && d.onLoad(c);
        }
      })
      .catch((c) => {
        const h = qi[e];
        if (h === void 0) throw (this.manager.itemError(e), c);
        delete qi[e];
        for (let u = 0, f = h.length; u < f; u++) {
          const d = h[u];
          d.onError && d.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class OS extends _s {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      o = Tr.get(e);
    if (o !== void 0)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), r.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = fa("img");
    function l() {
      h(), Tr.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(u) {
      h(), i && i(u), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      r.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class FS extends _s {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this,
      o = new Fu(),
      a = new Hu(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(r.withCredentials),
      a.load(
        e,
        function (l) {
          let c;
          try {
            c = r.parse(l);
          } catch (h) {
            if (i !== void 0) i(h);
            else {
              console.error(h);
              return;
            }
          }
          c.image !== void 0
            ? (o.image = c.image)
            : c.data !== void 0 &&
              ((o.image.width = c.width),
              (o.image.height = c.height),
              (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : Ri),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : Ri),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : tn),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : tn),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = Ci)),
            c.mipmapCount === 1 && (o.minFilter = tn),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c);
        },
        n,
        i
      ),
      o
    );
  }
}
class BS extends _s {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new nn(),
      o = new OS(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (r.image = a), (r.needsUpdate = !0), t !== void 0 && t(r);
        },
        n,
        i
      ),
      r
    );
  }
}
class nc extends Ut {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new He(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
const zc = new Ze(),
  Ud = new F(),
  Nd = new F();
class Vu {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new De(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Ze()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Uu()),
      (this._frameExtents = new De(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new ft(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    Ud.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Ud),
      Nd.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Nd),
      t.updateMatrixWorld(),
      zc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(zc),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(zc);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class kS extends Vu {
  constructor() {
    super(new Tn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = lo * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = r), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class zS extends nc {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Ut.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ut()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = r),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new kS());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Od = new Ze(),
  Io = new F(),
  Hc = new F();
class HS extends Vu {
  constructor() {
    super(new Tn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new De(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new ft(2, 1, 1, 1),
        new ft(0, 1, 1, 1),
        new ft(3, 1, 1, 1),
        new ft(1, 1, 1, 1),
        new ft(3, 0, 1, 1),
        new ft(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new F(1, 0, 0),
        new F(-1, 0, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
        new F(0, 1, 0),
        new F(0, -1, 0),
      ]),
      (this._cubeUps = [
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      r = e.distance || n.far;
    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
      Io.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(Io),
      Hc.copy(n.position),
      Hc.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(Hc),
      n.updateMatrixWorld(),
      i.makeTranslation(-Io.x, -Io.y, -Io.z),
      Od.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Od);
  }
}
class VS extends nc {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new HS());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class GS extends Vu {
  constructor() {
    super(new ec(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class WS extends nc {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Ut.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ut()),
      (this.shadow = new GS());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class XS extends nc {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class $o {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class YS extends _s {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      o = Tr.get(e);
    if (o !== void 0) {
      if ((r.manager.itemStart(e), o.then)) {
        o.then((c) => {
          t && t(c), r.manager.itemEnd(e);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(o), r.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(r.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return Tr.add(e, c), t && t(c), r.manager.itemEnd(e), c;
      })
      .catch(function (c) {
        i && i(c), Tr.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
      });
    Tr.add(e, l), r.manager.itemStart(e);
  }
}
class qS {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = Fd()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = Fd();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function Fd() {
  return performance.now();
}
const Gu = "\\[\\]\\.:\\/",
  jS = new RegExp("[" + Gu + "]", "g"),
  Wu = "[^" + Gu + "]",
  KS = "[^" + Gu.replace("\\.", "") + "]",
  $S = /((?:WC+[\/:])*)/.source.replace("WC", Wu),
  ZS = /(WCOD+)?/.source.replace("WCOD", KS),
  JS = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Wu),
  QS = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Wu),
  eT = new RegExp("^" + $S + ZS + JS + QS + "$"),
  tT = ["material", "materials", "bones", "map"];
class nT {
  constructor(e, t, n) {
    const i = n || vt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class vt {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || vt.parseTrackName(t)),
      (this.node = vt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new vt.Composite(e, t, n)
      : new vt(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(jS, "");
  }
  static parseTrackName(e) {
    const t = eT.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      tT.indexOf(r) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (r) {
          for (let o = 0; o < r.length; o++) {
            const a = r[o];
            if (a.name === t || a.uuid === t) return a;
            const l = n(a.children);
            if (l) return l;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let r = t.propertyIndex;
    if (
      (e || ((e = vt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[r] !== void 0 &&
          (r = e.morphTargetDictionary[r]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = r);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
vt.Composite = nT;
vt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
vt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
vt.prototype.GetterByBindingType = [
  vt.prototype._getValue_direct,
  vt.prototype._getValue_array,
  vt.prototype._getValue_arrayElement,
  vt.prototype._getValue_toArray,
];
vt.prototype.SetterByBindingTypeAndVersioning = [
  [
    vt.prototype._setValue_direct,
    vt.prototype._setValue_direct_setNeedsUpdate,
    vt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    vt.prototype._setValue_array,
    vt.prototype._setValue_array_setNeedsUpdate,
    vt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    vt.prototype._setValue_arrayElement,
    vt.prototype._setValue_arrayElement_setNeedsUpdate,
    vt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    vt.prototype._setValue_fromArray,
    vt.prototype._setValue_fromArray_setNeedsUpdate,
    vt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class Bd {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos(Qt(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class iT extends ms {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: bu } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = bu));
const kd = { type: "change" },
  Xu = { type: "start" },
  _m = { type: "end" },
  nl = new Ta(),
  zd = new yr(),
  rT = Math.cos(70 * jp.DEG2RAD),
  Xt = new F(),
  Cn = 2 * Math.PI,
  yt = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6,
  },
  Vc = 1e-6;
class sT extends iT {
  constructor(e, t = null) {
    super(e, t),
      (this.state = yt.NONE),
      (this.enabled = !0),
      (this.target = new F()),
      (this.cursor = new F()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minTargetRadius = 0),
      (this.maxTargetRadius = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: Xs.ROTATE,
        MIDDLE: Xs.DOLLY,
        RIGHT: Xs.PAN,
      }),
      (this.touches = { ONE: zs.ROTATE, TWO: zs.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this._lastPosition = new F()),
      (this._lastQuaternion = new Ni()),
      (this._lastTargetPosition = new F()),
      (this._quat = new Ni().setFromUnitVectors(e.up, new F(0, 1, 0))),
      (this._quatInverse = this._quat.clone().invert()),
      (this._spherical = new Bd()),
      (this._sphericalDelta = new Bd()),
      (this._scale = 1),
      (this._panOffset = new F()),
      (this._rotateStart = new De()),
      (this._rotateEnd = new De()),
      (this._rotateDelta = new De()),
      (this._panStart = new De()),
      (this._panEnd = new De()),
      (this._panDelta = new De()),
      (this._dollyStart = new De()),
      (this._dollyEnd = new De()),
      (this._dollyDelta = new De()),
      (this._dollyDirection = new F()),
      (this._mouse = new De()),
      (this._performCursorZoom = !1),
      (this._pointers = []),
      (this._pointerPositions = {}),
      (this._controlActive = !1),
      (this._onPointerMove = aT.bind(this)),
      (this._onPointerDown = oT.bind(this)),
      (this._onPointerUp = lT.bind(this)),
      (this._onContextMenu = mT.bind(this)),
      (this._onMouseWheel = uT.bind(this)),
      (this._onKeyDown = fT.bind(this)),
      (this._onTouchStart = dT.bind(this)),
      (this._onTouchMove = pT.bind(this)),
      (this._onMouseDown = cT.bind(this)),
      (this._onMouseMove = hT.bind(this)),
      (this._interceptControlDown = _T.bind(this)),
      (this._interceptControlUp = gT.bind(this)),
      this.domElement !== null && this.connect(),
      this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown),
      this.domElement.addEventListener("pointercancel", this._onPointerUp),
      this.domElement.addEventListener("contextmenu", this._onContextMenu),
      this.domElement.addEventListener("wheel", this._onMouseWheel, {
        passive: !1,
      }),
      this.domElement
        .getRootNode()
        .addEventListener("keydown", this._interceptControlDown, {
          passive: !0,
          capture: !0,
        }),
      (this.domElement.style.touchAction = "none");
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown),
      this.domElement.removeEventListener("pointermove", this._onPointerMove),
      this.domElement.removeEventListener("pointerup", this._onPointerUp),
      this.domElement.removeEventListener("pointercancel", this._onPointerUp),
      this.domElement.removeEventListener("wheel", this._onMouseWheel),
      this.domElement.removeEventListener("contextmenu", this._onContextMenu),
      this.stopListenToKeyEvents(),
      this.domElement
        .getRootNode()
        .removeEventListener("keydown", this._interceptControlDown, {
          capture: !0,
        }),
      (this.domElement.style.touchAction = "auto");
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown),
      (this._domElementKeyEvents = e);
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null &&
      (this._domElementKeyEvents.removeEventListener(
        "keydown",
        this._onKeyDown
      ),
      (this._domElementKeyEvents = null));
  }
  saveState() {
    this.target0.copy(this.target),
      this.position0.copy(this.object.position),
      (this.zoom0 = this.object.zoom);
  }
  reset() {
    this.target.copy(this.target0),
      this.object.position.copy(this.position0),
      (this.object.zoom = this.zoom0),
      this.object.updateProjectionMatrix(),
      this.dispatchEvent(kd),
      this.update(),
      (this.state = yt.NONE);
  }
  update(e = null) {
    const t = this.object.position;
    Xt.copy(t).sub(this.target),
      Xt.applyQuaternion(this._quat),
      this._spherical.setFromVector3(Xt),
      this.autoRotate &&
        this.state === yt.NONE &&
        this._rotateLeft(this._getAutoRotationAngle(e)),
      this.enableDamping
        ? ((this._spherical.theta +=
            this._sphericalDelta.theta * this.dampingFactor),
          (this._spherical.phi +=
            this._sphericalDelta.phi * this.dampingFactor))
        : ((this._spherical.theta += this._sphericalDelta.theta),
          (this._spherical.phi += this._sphericalDelta.phi));
    let n = this.minAzimuthAngle,
      i = this.maxAzimuthAngle;
    isFinite(n) &&
      isFinite(i) &&
      (n < -Math.PI ? (n += Cn) : n > Math.PI && (n -= Cn),
      i < -Math.PI ? (i += Cn) : i > Math.PI && (i -= Cn),
      n <= i
        ? (this._spherical.theta = Math.max(
            n,
            Math.min(i, this._spherical.theta)
          ))
        : (this._spherical.theta =
            this._spherical.theta > (n + i) / 2
              ? Math.max(n, this._spherical.theta)
              : Math.min(i, this._spherical.theta))),
      (this._spherical.phi = Math.max(
        this.minPolarAngle,
        Math.min(this.maxPolarAngle, this._spherical.phi)
      )),
      this._spherical.makeSafe(),
      this.enableDamping === !0
        ? this.target.addScaledVector(this._panOffset, this.dampingFactor)
        : this.target.add(this._panOffset),
      this.target.sub(this.cursor),
      this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
      this.target.add(this.cursor);
    let r = !1;
    if (
      (this.zoomToCursor && this._performCursorZoom) ||
      this.object.isOrthographicCamera
    )
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      (this._spherical.radius = this._clampDistance(
        this._spherical.radius * this._scale
      )),
        (r = o != this._spherical.radius);
    }
    if (
      (Xt.setFromSpherical(this._spherical),
      Xt.applyQuaternion(this._quatInverse),
      t.copy(this.target).add(Xt),
      this.object.lookAt(this.target),
      this.enableDamping === !0
        ? ((this._sphericalDelta.theta *= 1 - this.dampingFactor),
          (this._sphericalDelta.phi *= 1 - this.dampingFactor),
          this._panOffset.multiplyScalar(1 - this.dampingFactor))
        : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)),
      this.zoomToCursor && this._performCursorZoom)
    ) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const a = Xt.length();
        o = this._clampDistance(a * this._scale);
        const l = a - o;
        this.object.position.addScaledVector(this._dollyDirection, l),
          this.object.updateMatrixWorld(),
          (r = !!l);
      } else if (this.object.isOrthographicCamera) {
        const a = new F(this._mouse.x, this._mouse.y, 0);
        a.unproject(this.object);
        const l = this.object.zoom;
        (this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / this._scale)
        )),
          this.object.updateProjectionMatrix(),
          (r = l !== this.object.zoom);
        const c = new F(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object),
          this.object.position.sub(c).add(a),
          this.object.updateMatrixWorld(),
          (o = Xt.length());
      } else
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
        ),
          (this.zoomToCursor = !1);
      o !== null &&
        (this.screenSpacePanning
          ? this.target
              .set(0, 0, -1)
              .transformDirection(this.object.matrix)
              .multiplyScalar(o)
              .add(this.object.position)
          : (nl.origin.copy(this.object.position),
            nl.direction.set(0, 0, -1).transformDirection(this.object.matrix),
            Math.abs(this.object.up.dot(nl.direction)) < rT
              ? this.object.lookAt(this.target)
              : (zd.setFromNormalAndCoplanarPoint(this.object.up, this.target),
                nl.intersectPlane(zd, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      (this.object.zoom = Math.max(
        this.minZoom,
        Math.min(this.maxZoom, this.object.zoom / this._scale)
      )),
        o !== this.object.zoom &&
          (this.object.updateProjectionMatrix(), (r = !0));
    }
    return (
      (this._scale = 1),
      (this._performCursorZoom = !1),
      r ||
      this._lastPosition.distanceToSquared(this.object.position) > Vc ||
      8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Vc ||
      this._lastTargetPosition.distanceToSquared(this.target) > Vc
        ? (this.dispatchEvent(kd),
          this._lastPosition.copy(this.object.position),
          this._lastQuaternion.copy(this.object.quaternion),
          this._lastTargetPosition.copy(this.target),
          !0)
        : !1
    );
  }
  _getAutoRotationAngle(e) {
    return e !== null
      ? (Cn / 60) * this.autoRotateSpeed * e
      : (Cn / 60 / 60) * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    Xt.setFromMatrixColumn(t, 0),
      Xt.multiplyScalar(-e),
      this._panOffset.add(Xt);
  }
  _panUp(e, t) {
    this.screenSpacePanning === !0
      ? Xt.setFromMatrixColumn(t, 1)
      : (Xt.setFromMatrixColumn(t, 0), Xt.crossVectors(this.object.up, Xt)),
      Xt.multiplyScalar(e),
      this._panOffset.add(Xt);
  }
  _pan(e, t) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const i = this.object.position;
      Xt.copy(i).sub(this.target);
      let r = Xt.length();
      (r *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
        this._panLeft((2 * e * r) / n.clientHeight, this.object.matrix),
        this._panUp((2 * t * r) / n.clientHeight, this.object.matrix);
    } else
      this.object.isOrthographicCamera
        ? (this._panLeft(
            (e * (this.object.right - this.object.left)) /
              this.object.zoom /
              n.clientWidth,
            this.object.matrix
          ),
          this._panUp(
            (t * (this.object.top - this.object.bottom)) /
              this.object.zoom /
              n.clientHeight,
            this.object.matrix
          ))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
          ),
          (this.enablePan = !1));
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale /= e)
      : (console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
        ),
        (this.enableZoom = !1));
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale *= e)
      : (console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
        ),
        (this.enableZoom = !1));
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor) return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(),
      i = e - n.left,
      r = t - n.top,
      o = n.width,
      a = n.height;
    (this._mouse.x = (i / o) * 2 - 1),
      (this._mouse.y = -(r / a) * 2 + 1),
      this._dollyDirection
        .set(this._mouse.x, this._mouse.y, 1)
        .unproject(this.object)
        .sub(this.object.position)
        .normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX),
      this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY),
      this._rotateDelta
        .subVectors(this._rotateEnd, this._rotateStart)
        .multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft((Cn * this._rotateDelta.x) / t.clientHeight),
      this._rotateUp((Cn * this._rotateDelta.y) / t.clientHeight),
      this._rotateStart.copy(this._rotateEnd),
      this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY),
      this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
      this._dollyDelta.y > 0
        ? this._dollyOut(this._getZoomScale(this._dollyDelta.y))
        : this._dollyDelta.y < 0 &&
          this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
      this._dollyStart.copy(this._dollyEnd),
      this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY),
      this._panDelta
        .subVectors(this._panEnd, this._panStart)
        .multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd),
      this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY),
      e.deltaY < 0
        ? this._dollyIn(this._getZoomScale(e.deltaY))
        : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
      this.update();
  }
  _handleKeyDown(e) {
    let t = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateUp(
              (Cn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(0, this.keyPanSpeed),
          (t = !0);
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateUp(
              (-Cn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(0, -this.keyPanSpeed),
          (t = !0);
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateLeft(
              (Cn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(this.keyPanSpeed, 0),
          (t = !0);
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateLeft(
              (-Cn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(-this.keyPanSpeed, 0),
          (t = !0);
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1) this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e),
        n = 0.5 * (e.pageX + t.x),
        i = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(n, i);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1) this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e),
        n = 0.5 * (e.pageX + t.x),
        i = 0.5 * (e.pageY + t.y);
      this._panStart.set(n, i);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e),
      n = e.pageX - t.x,
      i = e.pageY - t.y,
      r = Math.sqrt(n * n + i * i);
    this._dollyStart.set(0, r);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e),
      this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e),
      this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1) this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e),
        i = 0.5 * (e.pageX + n.x),
        r = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(i, r);
    }
    this._rotateDelta
      .subVectors(this._rotateEnd, this._rotateStart)
      .multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft((Cn * this._rotateDelta.x) / t.clientHeight),
      this._rotateUp((Cn * this._rotateDelta.y) / t.clientHeight),
      this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1) this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e),
        n = 0.5 * (e.pageX + t.x),
        i = 0.5 * (e.pageY + t.y);
      this._panEnd.set(n, i);
    }
    this._panDelta
      .subVectors(this._panEnd, this._panStart)
      .multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e),
      n = e.pageX - t.x,
      i = e.pageY - t.y,
      r = Math.sqrt(n * n + i * i);
    this._dollyEnd.set(0, r),
      this._dollyDelta.set(
        0,
        Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)
      ),
      this._dollyOut(this._dollyDelta.y),
      this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + t.x) * 0.5,
      a = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(o, a);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e),
      this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e),
      this.enableRotate && this._handleTouchMoveRotate(e);
  }
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && ((t = new De()), (this._pointerPositions[e.pointerId] = t)),
      t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t =
      e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  _customWheelEvent(e) {
    const t = e.deltaMode,
      n = { clientX: e.clientX, clientY: e.clientY, deltaY: e.deltaY };
    switch (t) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function oT(s) {
  this.enabled !== !1 &&
    (this._pointers.length === 0 &&
      (this.domElement.setPointerCapture(s.pointerId),
      this.domElement.addEventListener("pointermove", this._onPointerMove),
      this.domElement.addEventListener("pointerup", this._onPointerUp)),
    !this._isTrackingPointer(s) &&
      (this._addPointer(s),
      s.pointerType === "touch"
        ? this._onTouchStart(s)
        : this._onMouseDown(s)));
}
function aT(s) {
  this.enabled !== !1 &&
    (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
}
function lT(s) {
  switch ((this._removePointer(s), this._pointers.length)) {
    case 0:
      this.domElement.releasePointerCapture(s.pointerId),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.dispatchEvent(_m),
        (this.state = yt.NONE);
      break;
    case 1:
      const e = this._pointers[0],
        t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function cT(s) {
  let e;
  switch (s.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case Xs.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(s), (this.state = yt.DOLLY);
      break;
    case Xs.ROTATE:
      if (s.ctrlKey || s.metaKey || s.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(s), (this.state = yt.PAN);
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(s), (this.state = yt.ROTATE);
      }
      break;
    case Xs.PAN:
      if (s.ctrlKey || s.metaKey || s.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(s), (this.state = yt.ROTATE);
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(s), (this.state = yt.PAN);
      }
      break;
    default:
      this.state = yt.NONE;
  }
  this.state !== yt.NONE && this.dispatchEvent(Xu);
}
function hT(s) {
  switch (this.state) {
    case yt.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(s);
      break;
    case yt.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(s);
      break;
    case yt.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(s);
      break;
  }
}
function uT(s) {
  this.enabled === !1 ||
    this.enableZoom === !1 ||
    this.state !== yt.NONE ||
    (s.preventDefault(),
    this.dispatchEvent(Xu),
    this._handleMouseWheel(this._customWheelEvent(s)),
    this.dispatchEvent(_m));
}
function fT(s) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(s);
}
function dT(s) {
  switch ((this._trackPointer(s), this._pointers.length)) {
    case 1:
      switch (this.touches.ONE) {
        case zs.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(s), (this.state = yt.TOUCH_ROTATE);
          break;
        case zs.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(s), (this.state = yt.TOUCH_PAN);
          break;
        default:
          this.state = yt.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case zs.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(s), (this.state = yt.TOUCH_DOLLY_PAN);
          break;
        case zs.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(s),
            (this.state = yt.TOUCH_DOLLY_ROTATE);
          break;
        default:
          this.state = yt.NONE;
      }
      break;
    default:
      this.state = yt.NONE;
  }
  this.state !== yt.NONE && this.dispatchEvent(Xu);
}
function pT(s) {
  switch ((this._trackPointer(s), this.state)) {
    case yt.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(s), this.update();
      break;
    case yt.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(s), this.update();
      break;
    case yt.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(s), this.update();
      break;
    case yt.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(s), this.update();
      break;
    default:
      this.state = yt.NONE;
  }
}
function mT(s) {
  this.enabled !== !1 && s.preventDefault();
}
function _T(s) {
  s.key === "Control" &&
    ((this._controlActive = !0),
    this.domElement
      .getRootNode()
      .addEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0,
      }));
}
function gT(s) {
  s.key === "Control" &&
    ((this._controlActive = !1),
    this.domElement
      .getRootNode()
      .removeEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0,
      }));
}
function Hd(s, e) {
  if (e === Ag)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      s
    );
  if (e === Xh || e === Xp) {
    let t = s.getIndex();
    if (t === null) {
      const o = [],
        a = s.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        s.setIndex(o), (t = s.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          s
        );
    }
    const n = t.count - 2,
      i = [];
    if (e === Xh)
      for (let o = 1; o <= n; o++)
        i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
    else
      for (let o = 0; o < n; o++)
        o % 2 === 0
          ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2)))
          : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
    i.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const r = s.clone();
    return r.setIndex(i), r.clearGroups(), r;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      s
    );
}
class vT extends _s {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new TT(t);
      }),
      this.register(function (t) {
        return new ET(t);
      }),
      this.register(function (t) {
        return new IT(t);
      }),
      this.register(function (t) {
        return new UT(t);
      }),
      this.register(function (t) {
        return new NT(t);
      }),
      this.register(function (t) {
        return new AT(t);
      }),
      this.register(function (t) {
        return new wT(t);
      }),
      this.register(function (t) {
        return new RT(t);
      }),
      this.register(function (t) {
        return new CT(t);
      }),
      this.register(function (t) {
        return new ST(t);
      }),
      this.register(function (t) {
        return new PT(t);
      }),
      this.register(function (t) {
        return new bT(t);
      }),
      this.register(function (t) {
        return new LT(t);
      }),
      this.register(function (t) {
        return new DT(t);
      }),
      this.register(function (t) {
        return new yT(t);
      }),
      this.register(function (t) {
        return new OT(t);
      }),
      this.register(function (t) {
        return new FT(t);
      });
  }
  load(e, t, n, i) {
    const r = this;
    let o;
    if (this.resourcePath !== "") o = this.resourcePath;
    else if (this.path !== "") {
      const c = $o.extractUrlBase(e);
      o = $o.resolveURL(c, this.path);
    } else o = $o.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function (c) {
        i ? i(c) : console.error(c),
          r.manager.itemError(e),
          r.manager.itemEnd(e);
      },
      l = new Hu(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            r.parse(
              c,
              o,
              function (h) {
                t(h), r.manager.itemEnd(e);
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        n,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let r;
    const o = {},
      a = {},
      l = new TextDecoder();
    if (typeof e == "string") r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === gm) {
        try {
          o[it.KHR_BINARY_GLTF] = new BT(e);
        } catch (u) {
          i && i(u);
          return;
        }
        r = JSON.parse(o[it.KHR_BINARY_GLTF].content);
      } else r = JSON.parse(l.decode(e));
    else r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new ZT(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      u.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (a[u.name] = u),
        (o[u.name] = !0);
    }
    if (r.extensionsUsed)
      for (let h = 0; h < r.extensionsUsed.length; ++h) {
        const u = r.extensionsUsed[h],
          f = r.extensionsRequired || [];
        switch (u) {
          case it.KHR_MATERIALS_UNLIT:
            o[u] = new MT();
            break;
          case it.KHR_DRACO_MESH_COMPRESSION:
            o[u] = new kT(r, this.dracoLoader);
            break;
          case it.KHR_TEXTURE_TRANSFORM:
            o[u] = new zT();
            break;
          case it.KHR_MESH_QUANTIZATION:
            o[u] = new HT();
            break;
          default:
            f.indexOf(u) >= 0 &&
              a[u] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(a), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function xT() {
  let s = {};
  return {
    get: function (e) {
      return s[e];
    },
    add: function (e, t) {
      s[e] = t;
    },
    remove: function (e) {
      delete s[e];
    },
    removeAll: function () {
      s = {};
    },
  };
}
const it = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class yT {
  constructor(e) {
    (this.parser = e),
      (this.name = it.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions &&
        r.extensions[this.name] &&
        r.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const r = t.json,
      l = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const h = new He(16777215);
    l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], pn);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new WS(h)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new VS(h)), (c.distance = u);
        break;
      case "spot":
        (c = new zS(h)),
          (c.distance = u),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      Ki(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (i = Promise.resolve(c)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      r = n.json.nodes[e],
      a = ((r.extensions && r.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return n._getNodeRef(t.cache, a, l);
        });
  }
}
class MT {
  constructor() {
    this.name = it.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Sr;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new He(1, 1, 1)), (e.opacity = 1);
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const o = r.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], pn), (e.opacity = o[3]);
      }
      r.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", r.baseColorTexture, sn));
    }
    return Promise.all(i);
  }
}
class ST {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class TT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (r.push(
          n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new De(a, a);
    }
    return Promise.all(r);
  }
}
class ET {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = i.extensions[this.name];
    return (
      (t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0),
      Promise.resolve()
    );
  }
}
class bT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        r.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(r)
    );
  }
}
class AT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [];
    (t.sheenColor = new He(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = i.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], pn);
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, sn)),
      o.sheenRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(r)
    );
  }
}
class wT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(r)
    );
  }
}
class RT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new He().setRGB(a[0], a[1], a[2], pn)),
      Promise.all(r)
    );
  }
}
class CT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = i.extensions[this.name];
    return (t.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
  }
}
class PT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new He().setRGB(a[0], a[1], a[2], pn)),
      o.specularColorTexture !== void 0 &&
        r.push(
          n.assignTexture(t, "specularColorMap", o.specularColorTexture, sn)
        ),
      Promise.all(r)
    );
  }
}
class DT {
  constructor(e) {
    (this.parser = e), (this.name = it.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    return (
      (t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
      o.bumpTexture !== void 0 &&
        r.push(n.assignTexture(t, "bumpMap", o.bumpTexture)),
      Promise.all(r)
    );
  }
}
class LT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ki;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        r.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(r)
    );
  }
}
class IT {
  constructor(e) {
    (this.parser = e), (this.name = it.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const r = i.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, r.source, o);
  }
}
class UT {
  constructor(e) {
    (this.parser = e),
      (this.name = it.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const o = r.extensions[t],
      a = i.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, o.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class NT {
  constructor(e) {
    (this.parser = e),
      (this.name = it.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const o = r.extensions[t],
      a = i.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, o.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class OT {
  constructor(e) {
    (this.name = it.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        r = this.parser.getDependency("buffer", i.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return r.then(function (a) {
        const l = i.byteOffset || 0,
          c = i.byteLength || 0,
          h = i.count,
          u = i.byteStride,
          f = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(h, u, f, i.mode, i.filter)
              .then(function (d) {
                return d.buffer;
              })
          : o.ready.then(function () {
              const d = new ArrayBuffer(h * u);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(d),
                  h,
                  u,
                  f,
                  i.mode,
                  i.filter
                ),
                d
              );
            });
      });
    } else return null;
  }
}
class FT {
  constructor(e) {
    (this.name = it.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const c of i.primitives)
      if (
        c.mode !== ni.TRIANGLES &&
        c.mode !== ni.TRIANGLE_STRIP &&
        c.mode !== ni.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const o = n.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const c in o)
      a.push(
        this.parser
          .getDependency("accessor", o[c])
          .then((h) => ((l[c] = h), l[c]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((c) => {
          const h = c.pop(),
            u = h.isGroup ? h.children : [h],
            f = c[0].count,
            d = [];
          for (const _ of u) {
            const g = new Ze(),
              m = new F(),
              p = new Ni(),
              M = new F(1, 1, 1),
              S = new yS(_.geometry, _.material, f);
            for (let v = 0; v < f; v++)
              l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, v),
                l.ROTATION && p.fromBufferAttribute(l.ROTATION, v),
                l.SCALE && M.fromBufferAttribute(l.SCALE, v),
                S.setMatrixAt(v, g.compose(m, p, M));
            for (const v in l)
              if (v === "_COLOR_0") {
                const C = l[v];
                S.instanceColor = new jh(C.array, C.itemSize, C.normalized);
              } else
                v !== "TRANSLATION" &&
                  v !== "ROTATION" &&
                  v !== "SCALE" &&
                  _.geometry.setAttribute(v, l[v]);
            Ut.prototype.copy.call(S, _),
              this.parser.assignFinalMaterial(S),
              d.push(S);
          }
          return h.isGroup ? (h.clear(), h.add(...d), h) : d[0];
        }));
  }
}
const gm = "glTF",
  Uo = 12,
  Vd = { JSON: 1313821514, BIN: 5130562 };
class BT {
  constructor(e) {
    (this.name = it.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, Uo),
      n = new TextDecoder();
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== gm)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - Uo,
      r = new DataView(e, Uo);
    let o = 0;
    for (; o < i; ) {
      const a = r.getUint32(o, !0);
      o += 4;
      const l = r.getUint32(o, !0);
      if (((o += 4), l === Vd.JSON)) {
        const c = new Uint8Array(e, Uo + o, a);
        this.content = n.decode(c);
      } else if (l === Vd.BIN) {
        const c = Uo + o;
        this.body = e.slice(c, c + a);
      }
      o += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class kT {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = it.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      r = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {};
    for (const h in o) {
      const u = $h[h] || h.toLowerCase();
      a[u] = o[h];
    }
    for (const h in e.attributes) {
      const u = $h[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const f = n.accessors[e.attributes[h]],
          d = Ks[f.componentType];
        (c[u] = d.name), (l[u] = f.normalized === !0);
      }
    }
    return t.getDependency("bufferView", r).then(function (h) {
      return new Promise(function (u, f) {
        i.decodeDracoFile(
          h,
          function (d) {
            for (const _ in d.attributes) {
              const g = d.attributes[_],
                m = l[_];
              m !== void 0 && (g.normalized = m);
            }
            u(d);
          },
          a,
          c,
          pn,
          f
        );
      });
    });
  }
}
class zT {
  constructor() {
    this.name = it.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class HT {
  constructor() {
    this.name = it.KHR_MESH_QUANTIZATION;
  }
}
class vm extends ba {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i * 3 + i;
    for (let o = 0; o !== i; o++) t[o] = n[r + o];
    return t;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      c = a * 3,
      h = i - t,
      u = (n - t) / h,
      f = u * u,
      d = f * u,
      _ = e * c,
      g = _ - c,
      m = -2 * d + 3 * f,
      p = d - f,
      M = 1 - m,
      S = p - f + u;
    for (let v = 0; v !== a; v++) {
      const C = o[g + v + a],
        w = o[g + v + l] * h,
        E = o[_ + v + a],
        A = o[_ + v] * h;
      r[v] = M * C + S * w + m * E + p * A;
    }
    return r;
  }
}
const VT = new Ni();
class GT extends vm {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return VT.fromArray(r).normalize().toArray(r), r;
  }
}
const ni = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Ks = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  Gd = { 9728: wn, 9729: tn, 9984: Np, 9985: gl, 9986: Bo, 9987: Ci },
  Wd = { 33071: Ri, 33648: Ul, 10497: so },
  Gc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  $h = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  vr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  WT = { CUBICSPLINE: void 0, LINEAR: ua, STEP: ha },
  Wc = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function XT(s) {
  return (
    s.DefaultMaterial === void 0 &&
      (s.DefaultMaterial = new zu({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: sr,
      })),
    s.DefaultMaterial
  );
}
function Gr(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function Ki(s, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(s.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function YT(s, e, t) {
  let n = !1,
    i = !1,
    r = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (
      (u.POSITION !== void 0 && (n = !0),
      u.NORMAL !== void 0 && (i = !0),
      u.COLOR_0 !== void 0 && (r = !0),
      n && i && r)
    )
      break;
  }
  if (!n && !i && !r) return Promise.resolve(s);
  const o = [],
    a = [],
    l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (n) {
      const f =
        u.POSITION !== void 0
          ? t.getDependency("accessor", u.POSITION)
          : s.attributes.position;
      o.push(f);
    }
    if (i) {
      const f =
        u.NORMAL !== void 0
          ? t.getDependency("accessor", u.NORMAL)
          : s.attributes.normal;
      a.push(f);
    }
    if (r) {
      const f =
        u.COLOR_0 !== void 0
          ? t.getDependency("accessor", u.COLOR_0)
          : s.attributes.color;
      l.push(f);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (c) {
      const h = c[0],
        u = c[1],
        f = c[2];
      return (
        n && (s.morphAttributes.position = h),
        i && (s.morphAttributes.normal = u),
        r && (s.morphAttributes.color = f),
        (s.morphTargetsRelative = !0),
        s
      );
    }
  );
}
function qT(s, e) {
  if ((s.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function jT(s) {
  let e;
  const t = s.extensions && s.extensions[it.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + Xc(t.attributes))
      : (e = s.indices + ":" + Xc(s.attributes) + ":" + s.mode),
    s.targets !== void 0)
  )
    for (let n = 0, i = s.targets.length; n < i; n++)
      e += ":" + Xc(s.targets[n]);
  return e;
}
function Xc(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function Zh(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function KT(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : s.search(/\.ktx2($|\?)/i) > 0 || s.search(/^data\:image\/ktx2/) === 0
    ? "image/ktx2"
    : "image/png";
}
const $T = new Ze();
class ZT {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new xT()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = -1,
      r = !1,
      o = -1;
    if (typeof navigator < "u") {
      const a = navigator.userAgent;
      n = /^((?!chrome|android).)*safari/i.test(a) === !0;
      const l = a.match(/Version\/(\d+)/);
      (i = n && l ? parseInt(l[1], 10) : -1),
        (r = a.indexOf("Firefox") > -1),
        (o = r ? a.match(/Firefox\/([0-9]+)\./)[1] : -1);
    }
    typeof createImageBitmap > "u" || (n && i < 17) || (r && o < 98)
      ? (this.textureLoader = new BS(this.options.manager))
      : (this.textureLoader = new YS(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Hu(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      r = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][i.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          return (
            Gr(r, a, i),
            Ki(a, i),
            Promise.all(
              n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              for (const l of a.scenes) l.updateMatrixWorld();
              e(a);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      r = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, h] of o.children.entries()) r(h, a.children[c]);
      };
    return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (r) {
              return r != this && r.getDependency && r.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (r, o) {
          return n.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[it.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (r, o) {
      n.load($o.resolveURL(t.uri, i.path), r, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const o = Gc[i.type],
        a = Ks[i.componentType],
        l = i.normalized === !0,
        c = new a(i.count * o);
      return Promise.resolve(new Rn(c, o, l));
    }
    const r = [];
    return (
      i.bufferView !== void 0
        ? r.push(this.getDependency("bufferView", i.bufferView))
        : r.push(null),
      i.sparse !== void 0 &&
        (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(r).then(function (o) {
        const a = o[0],
          l = Gc[i.type],
          c = Ks[i.componentType],
          h = c.BYTES_PER_ELEMENT,
          u = h * l,
          f = i.byteOffset || 0,
          d =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          _ = i.normalized === !0;
        let g, m;
        if (d && d !== u) {
          const p = Math.floor(f / d),
            M =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              p +
              ":" +
              i.count;
          let S = t.cache.get(M);
          S ||
            ((g = new c(a, p * d, (i.count * d) / h)),
            (S = new mS(g, d / h)),
            t.cache.add(M, S)),
            (m = new Ou(S, l, (f % d) / h, _));
        } else a === null ? (g = new c(i.count * l)) : (g = new c(a, f, i.count * l)), (m = new Rn(g, l, _));
        if (i.sparse !== void 0) {
          const p = Gc.SCALAR,
            M = Ks[i.sparse.indices.componentType],
            S = i.sparse.indices.byteOffset || 0,
            v = i.sparse.values.byteOffset || 0,
            C = new M(o[1], S, i.sparse.count * p),
            w = new c(o[2], v, i.sparse.count * l);
          a !== null && (m = new Rn(m.array.slice(), m.itemSize, m.normalized)),
            (m.normalized = !1);
          for (let E = 0, A = C.length; E < A; E++) {
            const y = C[E];
            if (
              (m.setX(y, w[E * l]),
              l >= 2 && m.setY(y, w[E * l + 1]),
              l >= 3 && m.setZ(y, w[E * l + 2]),
              l >= 4 && m.setW(y, w[E * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
          m.normalized = _;
        }
        return m;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      r = t.textures[e].source,
      o = t.images[r];
    let a = this.textureLoader;
    if (o.uri) {
      const l = n.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, r, a);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      r = this.json,
      o = r.textures[e],
      a = r.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, n)
      .then(function (h) {
        (h.flipY = !1),
          (h.name = o.name || a.name || ""),
          h.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (h.name = a.uri);
        const f = (r.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = Gd[f.magFilter] || tn),
          (h.minFilter = Gd[f.minFilter] || Ci),
          (h.wrapS = Wd[f.wrapS] || so),
          (h.wrapT = Wd[f.wrapT] || so),
          (h.generateMipmaps =
            !h.isCompressedTexture && h.minFilter !== wn && h.minFilter !== tn),
          i.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const o = i.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      c = !1;
    if (o.bufferView !== void 0)
      l = n.getDependency("bufferView", o.bufferView).then(function (u) {
        c = !0;
        const f = new Blob([u], { type: o.mimeType });
        return (l = a.createObjectURL(f)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (u) {
        return new Promise(function (f, d) {
          let _ = f;
          t.isImageBitmapLoader === !0 &&
            (_ = function (g) {
              const m = new nn(g);
              (m.needsUpdate = !0), f(m);
            }),
            t.load($o.resolveURL(u, r.path), _, void 0, d);
        });
      })
      .then(function (u) {
        return (
          c === !0 && a.revokeObjectURL(l),
          Ki(u, o),
          (u.userData.mimeType = o.mimeType || KT(o.uri)),
          u
        );
      })
      .catch(function (u) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), u);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, n, i) {
    const r = this;
    return this.getDependency("texture", n.index).then(function (o) {
      if (!o) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((o = o.clone()), (o.channel = n.texCoord)),
        r.extensions[it.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          n.extensions !== void 0
            ? n.extensions[it.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = r.associations.get(o);
          (o = r.extensions[it.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            r.associations.set(o, l);
        }
      }
      return i !== void 0 && (o.colorSpace = i), (e[t] = o), o;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      r = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new dm()),
        Li.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (n = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new fm()),
        Li.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        this.cache.add(a, l)),
        (n = l);
    }
    if (i || r || o) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      i && (a += "derivative-tangents:"),
        r && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = n.clone()),
        r && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(n))),
        (n = l);
    }
    e.material = n;
  }
  getMaterialType() {
    return zu;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.materials[e];
    let o;
    const a = {},
      l = r.extensions || {},
      c = [];
    if (l[it.KHR_MATERIALS_UNLIT]) {
      const u = i[it.KHR_MATERIALS_UNLIT];
      (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
    } else {
      const u = r.pbrMetallicRoughness || {};
      if (
        ((a.color = new He(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(u.baseColorFactor))
      ) {
        const f = u.baseColorFactor;
        a.color.setRGB(f[0], f[1], f[2], pn), (a.opacity = f[3]);
      }
      u.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(a, "map", u.baseColorTexture, sn)),
        (a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1),
        (a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
        u.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (f) {
          return f.getMaterialType && f.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (f) {
              return f.extendMaterialParams && f.extendMaterialParams(e, a);
            })
          )
        );
    }
    r.doubleSided === !0 && (a.side = Ai);
    const h = r.alphaMode || Wc.OPAQUE;
    if (
      (h === Wc.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Wc.MASK &&
            (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
      r.normalTexture !== void 0 &&
        o !== Sr &&
        (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        (a.normalScale = new De(1, 1)),
        r.normalTexture.scale !== void 0))
    ) {
      const u = r.normalTexture.scale;
      a.normalScale.set(u, u);
    }
    if (
      (r.occlusionTexture !== void 0 &&
        o !== Sr &&
        (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = r.occlusionTexture.strength)),
      r.emissiveFactor !== void 0 && o !== Sr)
    ) {
      const u = r.emissiveFactor;
      a.emissive = new He().setRGB(u[0], u[1], u[2], pn);
    }
    return (
      r.emissiveTexture !== void 0 &&
        o !== Sr &&
        c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, sn)),
      Promise.all(c).then(function () {
        const u = new o(a);
        return (
          r.name && (u.name = r.name),
          Ki(u, r),
          t.associations.set(u, { materials: e }),
          r.extensions && Gr(i, u, r),
          u
        );
      })
    );
  }
  createUniqueName(e) {
    const t = vt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function r(a) {
      return n[it.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return Xd(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        h = jT(c),
        u = i[h];
      if (u) o.push(u.promise);
      else {
        let f;
        c.extensions && c.extensions[it.KHR_DRACO_MESH_COMPRESSION]
          ? (f = r(c))
          : (f = Xd(new Mi(), c, t)),
          (i[h] = { primitive: c, promise: f }),
          o.push(f);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.meshes[e],
      o = r.primitives,
      a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const h =
        o[l].material === void 0
          ? XT(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          u = [];
        for (let d = 0, _ = h.length; d < _; d++) {
          const g = h[d],
            m = o[d];
          let p;
          const M = c[d];
          if (
            m.mode === ni.TRIANGLES ||
            m.mode === ni.TRIANGLE_STRIP ||
            m.mode === ni.TRIANGLE_FAN ||
            m.mode === void 0
          )
            (p = r.isSkinnedMesh === !0 ? new gS(g, M) : new Ln(g, M)),
              p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
              m.mode === ni.TRIANGLE_STRIP
                ? (p.geometry = Hd(p.geometry, Xp))
                : m.mode === ni.TRIANGLE_FAN &&
                  (p.geometry = Hd(p.geometry, Xh));
          else if (m.mode === ni.LINES) p = new MS(g, M);
          else if (m.mode === ni.LINE_STRIP) p = new ku(g, M);
          else if (m.mode === ni.LINE_LOOP) p = new SS(g, M);
          else if (m.mode === ni.POINTS) p = new TS(g, M);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + m.mode
            );
          Object.keys(p.geometry.morphAttributes).length > 0 && qT(p, r),
            (p.name = t.createUniqueName(r.name || "mesh_" + e)),
            Ki(p, r),
            m.extensions && Gr(i, p, m),
            t.assignFinalMaterial(p),
            u.push(p);
        }
        for (let d = 0, _ = u.length; d < _; d++)
          t.associations.set(u[d], { meshes: e, primitives: d });
        if (u.length === 1) return r.extensions && Gr(i, u[0], r), u[0];
        const f = new Jr();
        r.extensions && Gr(i, f, r), t.associations.set(f, { meshes: e });
        for (let d = 0, _ = u.length; d < _; d++) f.add(u[d]);
        return f;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new Tn(
            jp.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (t = new ec(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      Ki(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, r = t.joints.length; i < r; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const r = i.pop(),
          o = i,
          a = [],
          l = [];
        for (let c = 0, h = o.length; c < h; c++) {
          const u = o[c];
          if (u) {
            a.push(u);
            const f = new Ze();
            r !== null && f.fromArray(r.array, c * 16), l.push(f);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[c]
            );
        }
        return new Bu(a, l);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      n = this,
      i = t.animations[e],
      r = i.name ? i.name : "animation_" + e,
      o = [],
      a = [],
      l = [],
      c = [],
      h = [];
    for (let u = 0, f = i.channels.length; u < f; u++) {
      const d = i.channels[u],
        _ = i.samplers[d.sampler],
        g = d.target,
        m = g.node,
        p = i.parameters !== void 0 ? i.parameters[_.input] : _.input,
        M = i.parameters !== void 0 ? i.parameters[_.output] : _.output;
      g.node !== void 0 &&
        (o.push(this.getDependency("node", m)),
        a.push(this.getDependency("accessor", p)),
        l.push(this.getDependency("accessor", M)),
        c.push(_),
        h.push(g));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(h),
    ]).then(function (u) {
      const f = u[0],
        d = u[1],
        _ = u[2],
        g = u[3],
        m = u[4],
        p = [];
      for (let M = 0, S = f.length; M < S; M++) {
        const v = f[M],
          C = d[M],
          w = _[M],
          E = g[M],
          A = m[M];
        if (v === void 0) continue;
        v.updateMatrix && v.updateMatrix();
        const y = n._createAnimationTracks(v, C, w, E, A);
        if (y) for (let x = 0; x < y.length; x++) p.push(y[x]);
      }
      return new PS(r, void 0, p);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (r) {
          const o = n._getNodeRef(n.meshCache, i.mesh, r);
          return (
            i.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, c = i.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = i.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      r = n._loadNodeShallow(e),
      o = [],
      a = i.children || [];
    for (let c = 0, h = a.length; c < h; c++)
      o.push(n.getDependency("node", a[c]));
    const l =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", i.skin);
    return Promise.all([r, Promise.all(o), l]).then(function (c) {
      const h = c[0],
        u = c[1],
        f = c[2];
      f !== null &&
        h.traverse(function (d) {
          d.isSkinnedMesh && d.bind(f, $T);
        });
      for (let d = 0, _ = u.length; d < _; d++) h.add(u[d]);
      return h;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const r = t.nodes[e],
      o = r.name ? i.createUniqueName(r.name) : "",
      a = [],
      l = i._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      r.camera !== void 0 &&
        a.push(
          i.getDependency("camera", r.camera).then(function (c) {
            return i._getNodeRef(i.cameraCache, r.camera, c);
          })
        ),
      i
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          a.push(c);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (c) {
        let h;
        if (
          (r.isBone === !0
            ? (h = new um())
            : c.length > 1
            ? (h = new Jr())
            : c.length === 1
            ? (h = c[0])
            : (h = new Ut()),
          h !== c[0])
        )
          for (let u = 0, f = c.length; u < f; u++) h.add(c[u]);
        if (
          (r.name && ((h.userData.name = r.name), (h.name = o)),
          Ki(h, r),
          r.extensions && Gr(n, h, r),
          r.matrix !== void 0)
        ) {
          const u = new Ze();
          u.fromArray(r.matrix), h.applyMatrix4(u);
        } else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
        return (
          i.associations.has(h) || i.associations.set(h, {}),
          (i.associations.get(h).nodes = e),
          h
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      r = new Jr();
    n.name && (r.name = i.createUniqueName(n.name)),
      Ki(r, n),
      n.extensions && Gr(t, r, n);
    const o = n.nodes || [],
      a = [];
    for (let l = 0, c = o.length; l < c; l++)
      a.push(i.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let h = 0, u = l.length; h < u; h++) r.add(l[h]);
      const c = (h) => {
        const u = new Map();
        for (const [f, d] of i.associations)
          (f instanceof Li || f instanceof nn) && u.set(f, d);
        return (
          h.traverse((f) => {
            const d = i.associations.get(f);
            d != null && u.set(f, d);
          }),
          u
        );
      };
      return (i.associations = c(r)), r;
    });
  }
  _createAnimationTracks(e, t, n, i, r) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      l = [];
    vr[r.path] === vr.weights
      ? e.traverse(function (f) {
          f.morphTargetInfluences && l.push(f.name ? f.name : f.uuid);
        })
      : l.push(a);
    let c;
    switch (vr[r.path]) {
      case vr.weights:
        c = ho;
        break;
      case vr.rotation:
        c = uo;
        break;
      case vr.position:
      case vr.scale:
        c = fo;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            c = ho;
            break;
          case 2:
          case 3:
          default:
            c = fo;
            break;
        }
        break;
    }
    const h = i.interpolation !== void 0 ? WT[i.interpolation] : ua,
      u = this._getArrayFromAccessor(n);
    for (let f = 0, d = l.length; f < d; f++) {
      const _ = new c(l[f] + "." + vr[r.path], t.array, u, h);
      i.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(_),
        o.push(_);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Zh(t.constructor),
        i = new Float32Array(t.length);
      for (let r = 0, o = t.length; r < o; r++) i[r] = t[r] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (n) {
      const i = this instanceof uo ? GT : vm;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function JT(s, e, t) {
  const n = e.attributes,
    i = new cr();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION],
      l = a.min,
      c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (i.set(new F(l[0], l[1], l[2]), new F(c[0], c[1], c[2])), a.normalized)
      ) {
        const h = Zh(Ks[a.componentType]);
        i.min.multiplyScalar(h), i.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const r = e.targets;
  if (r !== void 0) {
    const a = new F(),
      l = new F();
    for (let c = 0, h = r.length; c < h; c++) {
      const u = r[c];
      if (u.POSITION !== void 0) {
        const f = t.json.accessors[u.POSITION],
          d = f.min,
          _ = f.max;
        if (d !== void 0 && _ !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(d[0]), Math.abs(_[0]))),
            l.setY(Math.max(Math.abs(d[1]), Math.abs(_[1]))),
            l.setZ(Math.max(Math.abs(d[2]), Math.abs(_[2]))),
            f.normalized)
          ) {
            const g = Zh(Ks[f.componentType]);
            l.multiplyScalar(g);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(a);
  }
  s.boundingBox = i;
  const o = new Bi();
  i.getCenter(o.center),
    (o.radius = i.min.distanceTo(i.max) / 2),
    (s.boundingSphere = o);
}
function Xd(s, e, t) {
  const n = e.attributes,
    i = [];
  function r(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      s.setAttribute(a, l);
    });
  }
  for (const o in n) {
    const a = $h[o] || o.toLowerCase();
    a in s.attributes || i.push(r(n[o], a));
  }
  if (e.indices !== void 0 && !s.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      s.setIndex(a);
    });
    i.push(o);
  }
  return (
    at.workingColorSpace !== pn &&
      "COLOR_0" in n &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${at.workingColorSpace}" not supported.`
      ),
    Ki(s, e),
    JT(s, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? YT(s, e.targets, t) : s;
    })
  );
}
class QT extends FS {
  constructor(e) {
    super(e), (this.type = Kn);
  }
  parse(e) {
    const o = function (A, y) {
        switch (A) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (y || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (y || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (y || ""));
          default:
          case 4:
            throw new Error("THREE.RGBELoader: Memory Error: " + (y || ""));
        }
      },
      h = `
`,
      u = function (A, y, x) {
        y = y || 1024;
        let I = A.pos,
          O = -1,
          k = 0,
          G = "",
          z = String.fromCharCode.apply(
            null,
            new Uint16Array(A.subarray(I, I + 128))
          );
        for (; 0 > (O = z.indexOf(h)) && k < y && I < A.byteLength; )
          (G += z),
            (k += z.length),
            (I += 128),
            (z += String.fromCharCode.apply(
              null,
              new Uint16Array(A.subarray(I, I + 128))
            ));
        return -1 < O ? ((A.pos += k + O + 1), G + z.slice(0, O)) : !1;
      },
      f = function (A) {
        const y = /^#\?(\S+)/,
          x = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          P = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          I = /^\s*FORMAT=(\S+)\s*$/,
          O = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          k = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let G, z;
        for (
          (A.pos >= A.byteLength || !(G = u(A))) && o(1, "no header found"),
            (z = G.match(y)) || o(3, "bad initial token"),
            k.valid |= 1,
            k.programtype = z[1],
            k.string +=
              G +
              `
`;
          (G = u(A)), G !== !1;

        ) {
          if (
            ((k.string +=
              G +
              `
`),
            G.charAt(0) === "#")
          ) {
            k.comments +=
              G +
              `
`;
            continue;
          }
          if (
            ((z = G.match(x)) && (k.gamma = parseFloat(z[1])),
            (z = G.match(P)) && (k.exposure = parseFloat(z[1])),
            (z = G.match(I)) && ((k.valid |= 2), (k.format = z[1])),
            (z = G.match(O)) &&
              ((k.valid |= 4),
              (k.height = parseInt(z[1], 10)),
              (k.width = parseInt(z[2], 10))),
            k.valid & 2 && k.valid & 4)
          )
            break;
        }
        return (
          k.valid & 2 || o(3, "missing format specifier"),
          k.valid & 4 || o(3, "missing image size specifier"),
          k
        );
      },
      d = function (A, y, x) {
        const P = y;
        if (P < 8 || P > 32767 || A[0] !== 2 || A[1] !== 2 || A[2] & 128)
          return new Uint8Array(A);
        P !== ((A[2] << 8) | A[3]) && o(3, "wrong scanline width");
        const I = new Uint8Array(4 * y * x);
        I.length || o(4, "unable to allocate buffer space");
        let O = 0,
          k = 0;
        const G = 4 * P,
          z = new Uint8Array(4),
          q = new Uint8Array(G);
        let H = x;
        for (; H > 0 && k < A.byteLength; ) {
          k + 4 > A.byteLength && o(1),
            (z[0] = A[k++]),
            (z[1] = A[k++]),
            (z[2] = A[k++]),
            (z[3] = A[k++]),
            (z[0] != 2 || z[1] != 2 || ((z[2] << 8) | z[3]) != P) &&
              o(3, "bad rgbe scanline format");
          let ee = 0,
            D;
          for (; ee < G && k < A.byteLength; ) {
            D = A[k++];
            const Me = D > 128;
            if (
              (Me && (D -= 128),
              (D === 0 || ee + D > G) && o(3, "bad scanline data"),
              Me)
            ) {
              const Ue = A[k++];
              for (let K = 0; K < D; K++) q[ee++] = Ue;
            } else q.set(A.subarray(k, k + D), ee), (ee += D), (k += D);
          }
          const oe = P;
          for (let Me = 0; Me < oe; Me++) {
            let Ue = 0;
            (I[O] = q[Me + Ue]),
              (Ue += P),
              (I[O + 1] = q[Me + Ue]),
              (Ue += P),
              (I[O + 2] = q[Me + Ue]),
              (Ue += P),
              (I[O + 3] = q[Me + Ue]),
              (O += 4);
          }
          H--;
        }
        return I;
      },
      _ = function (A, y, x, P) {
        const I = A[y + 3],
          O = Math.pow(2, I - 128) / 255;
        (x[P + 0] = A[y + 0] * O),
          (x[P + 1] = A[y + 1] * O),
          (x[P + 2] = A[y + 2] * O),
          (x[P + 3] = 1);
      },
      g = function (A, y, x, P) {
        const I = A[y + 3],
          O = Math.pow(2, I - 128) / 255;
        (x[P + 0] = Oa.toHalfFloat(Math.min(A[y + 0] * O, 65504))),
          (x[P + 1] = Oa.toHalfFloat(Math.min(A[y + 1] * O, 65504))),
          (x[P + 2] = Oa.toHalfFloat(Math.min(A[y + 2] * O, 65504))),
          (x[P + 3] = Oa.toHalfFloat(1));
      },
      m = new Uint8Array(e);
    m.pos = 0;
    const p = f(m),
      M = p.width,
      S = p.height,
      v = d(m.subarray(m.pos), M, S);
    let C, w, E;
    switch (this.type) {
      case Dn:
        E = v.length / 4;
        const A = new Float32Array(E * 4);
        for (let x = 0; x < E; x++) _(v, x * 4, A, x * 4);
        (C = A), (w = Dn);
        break;
      case Kn:
        E = v.length / 4;
        const y = new Uint16Array(E * 4);
        for (let x = 0; x < E; x++) g(v, x * 4, y, x * 4);
        (C = y), (w = Kn);
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: M,
      height: S,
      data: C,
      header: p.string,
      gamma: p.gamma,
      exposure: p.exposure,
      type: w,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function r(o, a) {
      switch (o.type) {
        case Dn:
        case Kn:
          (o.colorSpace = pn),
            (o.minFilter = tn),
            (o.magFilter = tn),
            (o.generateMipmaps = !1),
            (o.flipY = !0);
          break;
      }
      t && t(o, a);
    }
    return super.load(e, r, n, i);
  }
}
const xm = {
  name: "CopyShader",
  uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`,
};
class Aa {
  constructor() {
    (this.isPass = !0),
      (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1),
      (this.renderToScreen = !1);
  }
  setSize() {}
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {}
}
const eE = new ec(-1, 1, 1, -1, 0, 1);
class tE extends Mi {
  constructor() {
    super(),
      this.setAttribute("position", new yi([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
      this.setAttribute("uv", new yi([0, 2, 0, 0, 2, 0], 2));
  }
}
const nE = new tE();
class ym {
  constructor(e) {
    this._mesh = new Ln(nE, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, eE);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class iE extends Aa {
  constructor(e, t) {
    super(),
      (this.textureID = t !== void 0 ? t : "tDiffuse"),
      e instanceof In
        ? ((this.uniforms = e.uniforms), (this.material = e))
        : e &&
          ((this.uniforms = Ol.clone(e.uniforms)),
          (this.material = new In({
            name: e.name !== void 0 ? e.name : "unspecified",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
          }))),
      (this.fsQuad = new ym(this.material));
  }
  render(e, t, n) {
    this.uniforms[this.textureID] &&
      (this.uniforms[this.textureID].value = n.texture),
      (this.fsQuad.material = this.material),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(t),
          this.clear &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class Yd extends Aa {
  constructor(e, t) {
    super(),
      (this.scene = e),
      (this.camera = t),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }
  render(e, t, n) {
    const i = e.getContext(),
      r = e.state;
    r.buffers.color.setMask(!1),
      r.buffers.depth.setMask(!1),
      r.buffers.color.setLocked(!0),
      r.buffers.depth.setLocked(!0);
    let o, a;
    this.inverse ? ((o = 0), (a = 1)) : ((o = 1), (a = 0)),
      r.buffers.stencil.setTest(!0),
      r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
      r.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295),
      r.buffers.stencil.setClear(a),
      r.buffers.stencil.setLocked(!0),
      e.setRenderTarget(n),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      e.setRenderTarget(t),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      r.buffers.color.setLocked(!1),
      r.buffers.depth.setLocked(!1),
      r.buffers.color.setMask(!0),
      r.buffers.depth.setMask(!0),
      r.buffers.stencil.setLocked(!1),
      r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
      r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
      r.buffers.stencil.setLocked(!0);
  }
}
class rE extends Aa {
  constructor() {
    super(), (this.needsSwap = !1);
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class sE {
  constructor(e, t) {
    if (
      ((this.renderer = e),
      (this._pixelRatio = e.getPixelRatio()),
      t === void 0)
    ) {
      const n = e.getSize(new De());
      (this._width = n.width),
        (this._height = n.height),
        (t = new xi(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          { type: Kn }
        )),
        (t.texture.name = "EffectComposer.rt1");
    } else (this._width = t.width), (this._height = t.height);
    (this.renderTarget1 = t),
      (this.renderTarget2 = t.clone()),
      (this.renderTarget2.texture.name = "EffectComposer.rt2"),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.renderToScreen = !0),
      (this.passes = []),
      (this.copyPass = new iE(xm)),
      (this.copyPass.material.blending = nr),
      (this.clock = new qS());
  }
  swapBuffers() {
    const e = this.readBuffer;
    (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
  }
  addPass(e) {
    this.passes.push(e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled) return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let n = !1;
    for (let i = 0, r = this.passes.length; i < r; i++) {
      const o = this.passes[i];
      if (o.enabled !== !1) {
        if (
          ((o.renderToScreen =
            this.renderToScreen && this.isLastEnabledPass(i)),
          o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n),
          o.needsSwap)
        ) {
          if (n) {
            const a = this.renderer.getContext(),
              l = this.renderer.state.buffers.stencil;
            l.setFunc(a.NOTEQUAL, 1, 4294967295),
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                e
              ),
              l.setFunc(a.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        Yd !== void 0 &&
          (o instanceof Yd ? (n = !0) : o instanceof rE && (n = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new De());
      (this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = t.width),
        (this._height = t.height),
        (e = this.renderTarget1.clone()),
        e.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      (this.renderTarget1 = e),
      (this.renderTarget2 = e.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2);
  }
  setSize(e, t) {
    (this._width = e), (this._height = t);
    const n = this._width * this._pixelRatio,
      i = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
    for (let r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i);
  }
  setPixelRatio(e) {
    (this._pixelRatio = e), this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      this.copyPass.dispose();
  }
}
class oE extends Aa {
  constructor(e, t, n = null, i = null, r = null) {
    super(),
      (this.scene = e),
      (this.camera = t),
      (this.overrideMaterial = n),
      (this.clearColor = i),
      (this.clearAlpha = r),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1),
      (this._oldClearColor = new He());
  }
  render(e, t, n) {
    const i = e.autoClear;
    e.autoClear = !1;
    let r, o;
    this.overrideMaterial !== null &&
      ((o = this.scene.overrideMaterial),
      (this.scene.overrideMaterial = this.overrideMaterial)),
      this.clearColor !== null &&
        (e.getClearColor(this._oldClearColor),
        e.setClearColor(this.clearColor, e.getClearAlpha())),
      this.clearAlpha !== null &&
        ((r = e.getClearAlpha()), e.setClearAlpha(this.clearAlpha)),
      this.clearDepth == !0 && e.clearDepth(),
      e.setRenderTarget(this.renderToScreen ? null : n),
      this.clear === !0 &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
      e.render(this.scene, this.camera),
      this.clearColor !== null && e.setClearColor(this._oldClearColor),
      this.clearAlpha !== null && e.setClearAlpha(r),
      this.overrideMaterial !== null && (this.scene.overrideMaterial = o),
      (e.autoClear = i);
  }
}
const aE = {
  name: "LuminosityHighPassShader",
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new He(0) },
    defaultOpacity: { value: 0 },
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`,
};
class po extends Aa {
  constructor(e, t, n, i) {
    super(),
      (this.strength = t !== void 0 ? t : 1),
      (this.radius = n),
      (this.threshold = i),
      (this.resolution = e !== void 0 ? new De(e.x, e.y) : new De(256, 256)),
      (this.clearColor = new He(0, 0, 0)),
      (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5);
    let r = Math.round(this.resolution.x / 2),
      o = Math.round(this.resolution.y / 2);
    (this.renderTargetBright = new xi(r, o, { type: Kn })),
      (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
      (this.renderTargetBright.texture.generateMipmaps = !1);
    for (let u = 0; u < this.nMips; u++) {
      const f = new xi(r, o, { type: Kn });
      (f.texture.name = "UnrealBloomPass.h" + u),
        (f.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(f);
      const d = new xi(r, o, { type: Kn });
      (d.texture.name = "UnrealBloomPass.v" + u),
        (d.texture.generateMipmaps = !1),
        this.renderTargetsVertical.push(d),
        (r = Math.round(r / 2)),
        (o = Math.round(o / 2));
    }
    const a = aE;
    (this.highPassUniforms = Ol.clone(a.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = i),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new In({
        uniforms: this.highPassUniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
      })),
      (this.separableBlurMaterials = []);
    const l = [3, 5, 7, 9, 11];
    (r = Math.round(this.resolution.x / 2)),
      (o = Math.round(this.resolution.y / 2));
    for (let u = 0; u < this.nMips; u++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[u])),
        (this.separableBlurMaterials[u].uniforms.invSize.value = new De(
          1 / r,
          1 / o
        )),
        (r = Math.round(r / 2)),
        (o = Math.round(o / 2));
    (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value =
        this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value =
        this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value =
        this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value =
        this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value =
        this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = t),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1);
    const c = [1, 0.8, 0.6, 0.4, 0.2];
    (this.compositeMaterial.uniforms.bloomFactors.value = c),
      (this.bloomTintColors = [
        new F(1, 1, 1),
        new F(1, 1, 1),
        new F(1, 1, 1),
        new F(1, 1, 1),
        new F(1, 1, 1),
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors);
    const h = xm;
    (this.copyUniforms = Ol.clone(h.uniforms)),
      (this.blendMaterial = new In({
        uniforms: this.copyUniforms,
        vertexShader: h.vertexShader,
        fragmentShader: h.fragmentShader,
        blending: lh,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new He()),
      (this.oldClearAlpha = 1),
      (this.basic = new Sr()),
      (this.fsQuad = new ym(null));
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(),
      this.blendMaterial.dispose(),
      this.basic.dispose(),
      this.fsQuad.dispose();
  }
  setSize(e, t) {
    let n = Math.round(e / 2),
      i = Math.round(t / 2);
    this.renderTargetBright.setSize(n, i);
    for (let r = 0; r < this.nMips; r++)
      this.renderTargetsHorizontal[r].setSize(n, i),
        this.renderTargetsVertical[r].setSize(n, i),
        (this.separableBlurMaterials[r].uniforms.invSize.value = new De(
          1 / n,
          1 / i
        )),
        (n = Math.round(n / 2)),
        (i = Math.round(i / 2));
  }
  render(e, t, n, i, r) {
    e.getClearColor(this._oldClearColor),
      (this.oldClearAlpha = e.getClearAlpha());
    const o = e.autoClear;
    (e.autoClear = !1),
      e.setClearColor(this.clearColor, 0),
      r && e.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = n.texture),
        e.setRenderTarget(null),
        e.clear(),
        this.fsQuad.render(e)),
      (this.highPassUniforms.tDiffuse.value = n.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      e.setRenderTarget(this.renderTargetBright),
      e.clear(),
      this.fsQuad.render(e);
    let a = this.renderTargetBright;
    for (let l = 0; l < this.nMips; l++)
      (this.fsQuad.material = this.separableBlurMaterials[l]),
        (this.separableBlurMaterials[l].uniforms.colorTexture.value =
          a.texture),
        (this.separableBlurMaterials[l].uniforms.direction.value =
          po.BlurDirectionX),
        e.setRenderTarget(this.renderTargetsHorizontal[l]),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterials[l].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[l].texture),
        (this.separableBlurMaterials[l].uniforms.direction.value =
          po.BlurDirectionY),
        e.setRenderTarget(this.renderTargetsVertical[l]),
        e.clear(),
        this.fsQuad.render(e),
        (a = this.renderTargetsVertical[l]);
    (this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      e.setRenderTarget(this.renderTargetsHorizontal[0]),
      e.clear(),
      this.fsQuad.render(e),
      (this.fsQuad.material = this.blendMaterial),
      (this.copyUniforms.tDiffuse.value =
        this.renderTargetsHorizontal[0].texture),
      r && e.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(n), this.fsQuad.render(e)),
      e.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (e.autoClear = o);
  }
  getSeperableBlurMaterial(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push((0.39894 * Math.exp((-0.5 * n * n) / (e * e))) / e);
    return new In({
      defines: { KERNEL_RADIUS: e },
      uniforms: {
        colorTexture: { value: null },
        invSize: { value: new De(0.5, 0.5) },
        direction: { value: new De(0.5, 0.5) },
        gaussianCoefficients: { value: t },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`,
    });
  }
  getCompositeMaterial(e) {
    return new In({
      defines: { NUM_MIPS: e },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`,
    });
  }
}
po.BlurDirectionX = new De(1, 0);
po.BlurDirectionY = new De(0, 1);
function $i(s) {
  if (s === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return s;
}
function Mm(s, e) {
  (s.prototype = Object.create(e.prototype)),
    (s.prototype.constructor = s),
    (s.__proto__ = e);
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Zn = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  mo = { duration: 0.5, overwrite: !1, delay: 0 },
  Yu,
  fn,
  Pt,
  oi = 1e8,
  At = 1 / oi,
  Jh = Math.PI * 2,
  lE = Jh / 4,
  cE = 0,
  Sm = Math.sqrt,
  hE = Math.cos,
  uE = Math.sin,
  rn = function (e) {
    return typeof e == "string";
  },
  Ot = function (e) {
    return typeof e == "function";
  },
  ar = function (e) {
    return typeof e == "number";
  },
  qu = function (e) {
    return typeof e > "u";
  },
  Fi = function (e) {
    return typeof e == "object";
  },
  Nn = function (e) {
    return e !== !1;
  },
  ju = function () {
    return typeof window < "u";
  },
  il = function (e) {
    return Ot(e) || rn(e);
  },
  Tm =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  dn = Array.isArray,
  Qh = /(?:-?\.?\d|\.)+/gi,
  Em = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  Vs = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  Yc = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  bm = /[+-]=-?[.\d]+/,
  Am = /[^,'"\[\]\s]+/gi,
  fE = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  Lt,
  Ti,
  eu,
  Ku,
  Jn = {},
  kl = {},
  wm,
  Rm = function (e) {
    return (kl = hs(e, Jn)) && kn;
  },
  $u = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  da = function (e, t) {
    return !t && console.warn(e);
  },
  Cm = function (e, t) {
    return (e && (Jn[e] = t) && kl && (kl[e] = t)) || Jn;
  },
  pa = function () {
    return 0;
  },
  dE = { suppressEvents: !0, isStart: !0, kill: !1 },
  El = { suppressEvents: !0, kill: !1 },
  pE = { suppressEvents: !0 },
  Zu = {},
  Pr = [],
  tu = {},
  Pm,
  Yn = {},
  qc = {},
  qd = 30,
  bl = [],
  Ju = "",
  Qu = function (e) {
    var t = e[0],
      n,
      i;
    if ((Fi(t) || Ot(t) || (e = [e]), !(n = (t._gsap || {}).harness))) {
      for (i = bl.length; i-- && !bl[i].targetTest(t); );
      n = bl[i];
    }
    for (i = e.length; i--; )
      (e[i] && (e[i]._gsap || (e[i]._gsap = new e_(e[i], n)))) ||
        e.splice(i, 1);
    return e;
  },
  ts = function (e) {
    return e._gsap || Qu(ai(e))[0]._gsap;
  },
  Dm = function (e, t, n) {
    return (n = e[t]) && Ot(n)
      ? e[t]()
      : (qu(n) && e.getAttribute && e.getAttribute(t)) || n;
  },
  On = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  Bt = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  en = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  $s = function (e, t) {
    var n = t.charAt(0),
      i = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
    );
  },
  mE = function (e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
    return i < n;
  },
  zl = function () {
    var e = Pr.length,
      t = Pr.slice(0),
      n,
      i;
    for (tu = {}, Pr.length = 0, n = 0; n < e; n++)
      (i = t[n]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
  },
  Lm = function (e, t, n, i) {
    Pr.length && !fn && zl(),
      e.render(t, n, fn && t < 0 && (e._initted || e._startAt)),
      Pr.length && !fn && zl();
  },
  Im = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(Am).length < 2
      ? t
      : rn(e)
      ? e.trim()
      : e;
  },
  Um = function (e) {
    return e;
  },
  ci = function (e, t) {
    for (var n in t) n in e || (e[n] = t[n]);
    return e;
  },
  _E = function (e) {
    return function (t, n) {
      for (var i in n)
        i in t || (i === "duration" && e) || i === "ease" || (t[i] = n[i]);
    };
  },
  hs = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  jd = function s(e, t) {
    for (var n in t)
      n !== "__proto__" &&
        n !== "constructor" &&
        n !== "prototype" &&
        (e[n] = Fi(t[n]) ? s(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e;
  },
  Hl = function (e, t) {
    var n = {},
      i;
    for (i in e) i in t || (n[i] = e[i]);
    return n;
  },
  Zo = function (e) {
    var t = e.parent || Lt,
      n = e.keyframes ? _E(dn(e.keyframes)) : ci;
    if (Nn(e.inherit))
      for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  gE = function (e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; );
    return n < 0;
  },
  Nm = function (e, t, n, i, r) {
    var o = e[i],
      a;
    if (r) for (a = t[r]; o && o[r] > a; ) o = o._prev;
    return (
      o ? ((t._next = o._next), (o._next = t)) : ((t._next = e[n]), (e[n] = t)),
      t._next ? (t._next._prev = t) : (e[i] = t),
      (t._prev = o),
      (t.parent = t._dp = e),
      t
    );
  },
  ic = function (e, t, n, i) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var r = t._prev,
      o = t._next;
    r ? (r._next = o) : e[n] === t && (e[n] = o),
      o ? (o._prev = r) : e[i] === t && (e[i] = r),
      (t._next = t._prev = t.parent = null);
  },
  Ir = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  ns = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
    return e;
  },
  vE = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  nu = function (e, t, n, i) {
    return (
      e._startAt &&
      (fn
        ? e._startAt.revert(El)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, i))
    );
  },
  xE = function s(e) {
    return !e || (e._ts && s(e.parent));
  },
  Kd = function (e) {
    return e._repeat ? _o(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  _o = function (e, t) {
    var n = Math.floor((e /= t));
    return e && n === e ? n - 1 : n;
  },
  Vl = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  rc = function (e) {
    return (e._end = en(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || At) || 0)
    ));
  },
  sc = function (e, t) {
    var n = e._dp;
    return (
      n &&
        n.smoothChildTiming &&
        e._ts &&
        ((e._start = en(
          n._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        rc(e),
        n._dirty || ns(n, e)),
      e
    );
  },
  Om = function (e, t) {
    var n;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((n = Vl(e.rawTime(), t)),
        (!t._dur || wa(0, t.totalDuration(), n) - t._tTime > At) &&
          t.render(n, !0)),
      ns(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (n = e; n._dp; )
          n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
      e._zTime = -At;
    }
  },
  wi = function (e, t, n, i) {
    return (
      t.parent && Ir(t),
      (t._start = en(
        (ar(n) ? n : n || e !== Lt ? ti(e, n, t) : e._time) + t._delay
      )),
      (t._end = en(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      Nm(e, t, "_first", "_last", e._sort ? "_start" : 0),
      iu(t) || (e._recent = t),
      i || Om(e, t),
      e._ts < 0 && sc(e, e._tTime),
      e
    );
  },
  Fm = function (e, t) {
    return (
      (Jn.ScrollTrigger || $u("scrollTrigger", t)) &&
      Jn.ScrollTrigger.create(t, e)
    );
  },
  Bm = function (e, t, n, i, r) {
    if ((tf(e, t, r), !e._initted)) return 1;
    if (
      !n &&
      e._pt &&
      !fn &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      Pm !== qn.frame
    )
      return Pr.push(e), (e._lazy = [r, i]), 1;
  },
  yE = function s(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t));
  },
  iu = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  ME = function (e, t, n, i) {
    var r = e.ratio,
      o =
        t < 0 ||
        (!t &&
          ((!e._start && yE(e) && !(!e._initted && iu(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !iu(e))))
          ? 0
          : 1,
      a = e._rDelay,
      l = 0,
      c,
      h,
      u;
    if (
      (a &&
        e._repeat &&
        ((l = wa(0, e._tDur, t)),
        (h = _o(l, a)),
        e._yoyo && h & 1 && (o = 1 - o),
        h !== _o(e._tTime, a) &&
          ((r = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
      o !== r || fn || i || e._zTime === At || (!t && e._zTime))
    ) {
      if (!e._initted && Bm(e, t, i, n, l)) return;
      for (
        u = e._zTime,
          e._zTime = t || (n ? At : 0),
          n || (n = t && !u),
          e.ratio = o,
          e._from && (o = 1 - o),
          e._time = 0,
          e._tTime = l,
          c = e._pt;
        c;

      )
        c.r(o, c.d), (c = c._next);
      t < 0 && nu(e, t, n, !0),
        e._onUpdate && !n && $n(e, "onUpdate"),
        l && e._repeat && !n && e.parent && $n(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === o &&
          (o && Ir(e, 1),
          !n &&
            !fn &&
            ($n(e, o ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  SE = function (e, t, n) {
    var i;
    if (n > t)
      for (i = e._first; i && i._start <= n; ) {
        if (i.data === "isPause" && i._start > t) return i;
        i = i._next;
      }
    else
      for (i = e._last; i && i._start >= n; ) {
        if (i.data === "isPause" && i._start < t) return i;
        i = i._prev;
      }
  },
  go = function (e, t, n, i) {
    var r = e._repeat,
      o = en(t) || 0,
      a = e._tTime / e._tDur;
    return (
      a && !i && (e._time *= o / e._dur),
      (e._dur = o),
      (e._tDur = r ? (r < 0 ? 1e10 : en(o * (r + 1) + e._rDelay * r)) : o),
      a > 0 && !i && sc(e, (e._tTime = e._tDur * a)),
      e.parent && rc(e),
      n || ns(e.parent, e),
      e
    );
  },
  $d = function (e) {
    return e instanceof En ? ns(e) : go(e, e._dur);
  },
  TE = { _start: 0, endTime: pa, totalDuration: pa },
  ti = function s(e, t, n) {
    var i = e.labels,
      r = e._recent || TE,
      o = e.duration() >= oi ? r.endTime(!1) : e._dur,
      a,
      l,
      c;
    return rn(t) && (isNaN(t) || t in i)
      ? ((l = t.charAt(0)),
        (c = t.substr(-1) === "%"),
        (a = t.indexOf("=")),
        l === "<" || l === ">"
          ? (a >= 0 && (t = t.replace(/=/, "")),
            (l === "<" ? r._start : r.endTime(r._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (c ? (a < 0 ? r : n).totalDuration() / 100 : 1))
          : a < 0
          ? (t in i || (i[t] = o), i[t])
          : ((l = parseFloat(t.charAt(a - 1) + t.substr(a + 1))),
            c && n && (l = (l / 100) * (dn(n) ? n[0] : n).totalDuration()),
            a > 1 ? s(e, t.substr(0, a - 1), n) + l : o + l))
      : t == null
      ? o
      : +t;
  },
  Jo = function (e, t, n) {
    var i = ar(t[1]),
      r = (i ? 2 : 1) + (e < 2 ? 0 : 1),
      o = t[r],
      a,
      l;
    if ((i && (o.duration = t[1]), (o.parent = n), e)) {
      for (a = o, l = n; l && !("immediateRender" in a); )
        (a = l.vars.defaults || {}), (l = Nn(l.vars.inherit) && l.parent);
      (o.immediateRender = Nn(a.immediateRender)),
        e < 2 ? (o.runBackwards = 1) : (o.startAt = t[r - 1]);
    }
    return new Gt(t[0], o, t[r + 1]);
  },
  Or = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  wa = function (e, t, n) {
    return n < e ? e : n > t ? t : n;
  },
  un = function (e, t) {
    return !rn(e) || !(t = fE.exec(e)) ? "" : t[1];
  },
  EE = function (e, t, n) {
    return Or(n, function (i) {
      return wa(e, t, i);
    });
  },
  ru = [].slice,
  km = function (e, t) {
    return (
      e &&
      Fi(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Fi(e[0]))) &&
      !e.nodeType &&
      e !== Ti
    );
  },
  bE = function (e, t, n) {
    return (
      n === void 0 && (n = []),
      e.forEach(function (i) {
        var r;
        return (rn(i) && !t) || km(i, 1)
          ? (r = n).push.apply(r, ai(i))
          : n.push(i);
      }) || n
    );
  },
  ai = function (e, t, n) {
    return Pt && !t && Pt.selector
      ? Pt.selector(e)
      : rn(e) && !n && (eu || !vo())
      ? ru.call((t || Ku).querySelectorAll(e), 0)
      : dn(e)
      ? bE(e, n)
      : km(e)
      ? ru.call(e, 0)
      : e
      ? [e]
      : [];
  },
  su = function (e) {
    return (
      (e = ai(e)[0] || da("Invalid scope") || {}),
      function (t) {
        var n = e.current || e.nativeElement || e;
        return ai(
          t,
          n.querySelectorAll
            ? n
            : n === e
            ? da("Invalid scope") || Ku.createElement("div")
            : e
        );
      }
    );
  },
  zm = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  Hm = function (e) {
    if (Ot(e)) return e;
    var t = Fi(e) ? e : { each: e },
      n = is(t.ease),
      i = t.from || 0,
      r = parseFloat(t.base) || 0,
      o = {},
      a = i > 0 && i < 1,
      l = isNaN(i) || a,
      c = t.axis,
      h = i,
      u = i;
    return (
      rn(i)
        ? (h = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
        : !a && l && ((h = i[0]), (u = i[1])),
      function (f, d, _) {
        var g = (_ || t).length,
          m = o[g],
          p,
          M,
          S,
          v,
          C,
          w,
          E,
          A,
          y;
        if (!m) {
          if (((y = t.grid === "auto" ? 0 : (t.grid || [1, oi])[1]), !y)) {
            for (
              E = -oi;
              E < (E = _[y++].getBoundingClientRect().left) && y < g;

            );
            y < g && y--;
          }
          for (
            m = o[g] = [],
              p = l ? Math.min(y, g) * h - 0.5 : i % y,
              M = y === oi ? 0 : l ? (g * u) / y - 0.5 : (i / y) | 0,
              E = 0,
              A = oi,
              w = 0;
            w < g;
            w++
          )
            (S = (w % y) - p),
              (v = M - ((w / y) | 0)),
              (m[w] = C = c ? Math.abs(c === "y" ? v : S) : Sm(S * S + v * v)),
              C > E && (E = C),
              C < A && (A = C);
          i === "random" && zm(m),
            (m.max = E - A),
            (m.min = A),
            (m.v = g =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (y > g
                    ? g - 1
                    : c
                    ? c === "y"
                      ? g / y
                      : y
                    : Math.max(y, g / y)) ||
                0) * (i === "edges" ? -1 : 1)),
            (m.b = g < 0 ? r - g : r),
            (m.u = un(t.amount || t.each) || 0),
            (n = n && g < 0 ? Zm(n) : n);
        }
        return (
          (g = (m[f] - m.min) / m.max || 0),
          en(m.b + (n ? n(g) : g) * m.v) + m.u
        );
      }
    );
  },
  ou = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (n) {
      var i = en(Math.round(parseFloat(n) / e) * e * t);
      return (i - (i % 1)) / t + (ar(n) ? 0 : un(n));
    };
  },
  Vm = function (e, t) {
    var n = dn(e),
      i,
      r;
    return (
      !n &&
        Fi(e) &&
        ((i = n = e.radius || oi),
        e.values
          ? ((e = ai(e.values)), (r = !ar(e[0])) && (i *= i))
          : (e = ou(e.increment))),
      Or(
        t,
        n
          ? Ot(e)
            ? function (o) {
                return (r = e(o)), Math.abs(r - o) <= i ? r : o;
              }
            : function (o) {
                for (
                  var a = parseFloat(r ? o.x : o),
                    l = parseFloat(r ? o.y : 0),
                    c = oi,
                    h = 0,
                    u = e.length,
                    f,
                    d;
                  u--;

                )
                  r
                    ? ((f = e[u].x - a), (d = e[u].y - l), (f = f * f + d * d))
                    : (f = Math.abs(e[u] - a)),
                    f < c && ((c = f), (h = u));
                return (
                  (h = !i || c <= i ? e[h] : o),
                  r || h === o || ar(o) ? h : h + un(o)
                );
              }
          : ou(e)
      )
    );
  },
  Gm = function (e, t, n, i) {
    return Or(dn(e) ? !t : n === !0 ? !!(n = 0) : !i, function () {
      return dn(e)
        ? e[~~(Math.random() * e.length)]
        : (n = n || 1e-5) &&
            (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) *
                n *
                i
            ) / i;
    });
  },
  AE = function () {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return function (i) {
      return t.reduce(function (r, o) {
        return o(r);
      }, i);
    };
  },
  wE = function (e, t) {
    return function (n) {
      return e(parseFloat(n)) + (t || un(n));
    };
  },
  RE = function (e, t, n) {
    return Xm(e, t, 0, 1, n);
  },
  Wm = function (e, t, n) {
    return Or(n, function (i) {
      return e[~~t(i)];
    });
  },
  CE = function s(e, t, n) {
    var i = t - e;
    return dn(e)
      ? Wm(e, s(0, e.length), t)
      : Or(n, function (r) {
          return ((i + ((r - e) % i)) % i) + e;
        });
  },
  PE = function s(e, t, n) {
    var i = t - e,
      r = i * 2;
    return dn(e)
      ? Wm(e, s(0, e.length - 1), t)
      : Or(n, function (o) {
          return (o = (r + ((o - e) % r)) % r || 0), e + (o > i ? r - o : o);
        });
  },
  ma = function (e) {
    for (var t = 0, n = "", i, r, o, a; ~(i = e.indexOf("random(", t)); )
      (o = e.indexOf(")", i)),
        (a = e.charAt(i + 7) === "["),
        (r = e.substr(i + 7, o - i - 7).match(a ? Am : Qh)),
        (n +=
          e.substr(t, i - t) + Gm(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5)),
        (t = o + 1);
    return n + e.substr(t, e.length - t);
  },
  Xm = function (e, t, n, i, r) {
    var o = t - e,
      a = i - n;
    return Or(r, function (l) {
      return n + (((l - e) / o) * a || 0);
    });
  },
  DE = function s(e, t, n, i) {
    var r = isNaN(e + t)
      ? 0
      : function (d) {
          return (1 - d) * e + d * t;
        };
    if (!r) {
      var o = rn(e),
        a = {},
        l,
        c,
        h,
        u,
        f;
      if ((n === !0 && (i = 1) && (n = null), o))
        (e = { p: e }), (t = { p: t });
      else if (dn(e) && !dn(t)) {
        for (h = [], u = e.length, f = u - 2, c = 1; c < u; c++)
          h.push(s(e[c - 1], e[c]));
        u--,
          (r = function (_) {
            _ *= u;
            var g = Math.min(f, ~~_);
            return h[g](_ - g);
          }),
          (n = t);
      } else i || (e = hs(dn(e) ? [] : {}, e));
      if (!h) {
        for (l in t) ef.call(a, e, l, "get", t[l]);
        r = function (_) {
          return sf(_, a) || (o ? e.p : e);
        };
      }
    }
    return Or(n, r);
  },
  Zd = function (e, t, n) {
    var i = e.labels,
      r = oi,
      o,
      a,
      l;
    for (o in i)
      (a = i[o] - t),
        a < 0 == !!n && a && r > (a = Math.abs(a)) && ((l = o), (r = a));
    return l;
  },
  $n = function (e, t, n) {
    var i = e.vars,
      r = i[t],
      o = Pt,
      a = e._ctx,
      l,
      c,
      h;
    if (r)
      return (
        (l = i[t + "Params"]),
        (c = i.callbackScope || e),
        n && Pr.length && zl(),
        a && (Pt = a),
        (h = l ? r.apply(c, l) : r.call(c)),
        (Pt = o),
        h
      );
  },
  Ho = function (e) {
    return (
      Ir(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!fn),
      e.progress() < 1 && $n(e, "onInterrupt"),
      e
    );
  },
  Gs,
  Ym = [],
  qm = function (e) {
    if (e)
      if (((e = (!e.name && e.default) || e), ju() || e.headless)) {
        var t = e.name,
          n = Ot(e),
          i =
            t && !n && e.init
              ? function () {
                  this._props = [];
                }
              : e,
          r = {
            init: pa,
            render: sf,
            add: ef,
            kill: qE,
            modifier: YE,
            rawVars: 0,
          },
          o = {
            targetTest: 0,
            get: 0,
            getSetter: rf,
            aliases: {},
            register: 0,
          };
        if ((vo(), e !== i)) {
          if (Yn[t]) return;
          ci(i, ci(Hl(e, r), o)),
            hs(i.prototype, hs(r, Hl(e, o))),
            (Yn[(i.prop = t)] = i),
            e.targetTest && (bl.push(i), (Zu[t] = 1)),
            (t =
              (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
              "Plugin");
        }
        Cm(t, i), e.register && e.register(kn, i, Fn);
      } else Ym.push(e);
  },
  Et = 255,
  Vo = {
    aqua: [0, Et, Et],
    lime: [0, Et, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Et],
    navy: [0, 0, 128],
    white: [Et, Et, Et],
    olive: [128, 128, 0],
    yellow: [Et, Et, 0],
    orange: [Et, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Et, 0, 0],
    pink: [Et, 192, 203],
    cyan: [0, Et, Et],
    transparent: [Et, Et, Et, 0],
  },
  jc = function (e, t, n) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (n - t) * e * 6
        : e < 0.5
        ? n
        : e * 3 < 2
        ? t + (n - t) * (2 / 3 - e) * 6
        : t) *
        Et +
        0.5) |
        0
    );
  },
  jm = function (e, t, n) {
    var i = e ? (ar(e) ? [e >> 16, (e >> 8) & Et, e & Et] : 0) : Vo.black,
      r,
      o,
      a,
      l,
      c,
      h,
      u,
      f,
      d,
      _;
    if (!i) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Vo[e]))
        i = Vo[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((r = e.charAt(1)),
            (o = e.charAt(2)),
            (a = e.charAt(3)),
            (e =
              "#" +
              r +
              r +
              o +
              o +
              a +
              a +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (i = parseInt(e.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & Et, i & Et, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (i = [e >> 16, (e >> 8) & Et, e & Et]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((i = _ = e.match(Qh)), !t))
          (l = (+i[0] % 360) / 360),
            (c = +i[1] / 100),
            (h = +i[2] / 100),
            (o = h <= 0.5 ? h * (c + 1) : h + c - h * c),
            (r = h * 2 - o),
            i.length > 3 && (i[3] *= 1),
            (i[0] = jc(l + 1 / 3, r, o)),
            (i[1] = jc(l, r, o)),
            (i[2] = jc(l - 1 / 3, r, o));
        else if (~e.indexOf("="))
          return (i = e.match(Em)), n && i.length < 4 && (i[3] = 1), i;
      } else i = e.match(Qh) || Vo.transparent;
      i = i.map(Number);
    }
    return (
      t &&
        !_ &&
        ((r = i[0] / Et),
        (o = i[1] / Et),
        (a = i[2] / Et),
        (u = Math.max(r, o, a)),
        (f = Math.min(r, o, a)),
        (h = (u + f) / 2),
        u === f
          ? (l = c = 0)
          : ((d = u - f),
            (c = h > 0.5 ? d / (2 - u - f) : d / (u + f)),
            (l =
              u === r
                ? (o - a) / d + (o < a ? 6 : 0)
                : u === o
                ? (a - r) / d + 2
                : (r - o) / d + 4),
            (l *= 60)),
        (i[0] = ~~(l + 0.5)),
        (i[1] = ~~(c * 100 + 0.5)),
        (i[2] = ~~(h * 100 + 0.5))),
      n && i.length < 4 && (i[3] = 1),
      i
    );
  },
  Km = function (e) {
    var t = [],
      n = [],
      i = -1;
    return (
      e.split(Dr).forEach(function (r) {
        var o = r.match(Vs) || [];
        t.push.apply(t, o), n.push((i += o.length + 1));
      }),
      (t.c = n),
      t
    );
  },
  Jd = function (e, t, n) {
    var i = "",
      r = (e + i).match(Dr),
      o = t ? "hsla(" : "rgba(",
      a = 0,
      l,
      c,
      h,
      u;
    if (!r) return e;
    if (
      ((r = r.map(function (f) {
        return (
          (f = jm(f, t, 1)) &&
          o +
            (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) +
            ")"
        );
      })),
      n && ((h = Km(e)), (l = n.c), l.join(i) !== h.c.join(i)))
    )
      for (c = e.replace(Dr, "1").split(Vs), u = c.length - 1; a < u; a++)
        i +=
          c[a] +
          (~l.indexOf(a)
            ? r.shift() || o + "0,0,0,0)"
            : (h.length ? h : r.length ? r : n).shift());
    if (!c)
      for (c = e.split(Dr), u = c.length - 1; a < u; a++) i += c[a] + r[a];
    return i + c[u];
  },
  Dr = (function () {
    var s =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in Vo) s += "|" + e + "\\b";
    return new RegExp(s + ")", "gi");
  })(),
  LE = /hsl[a]?\(/,
  $m = function (e) {
    var t = e.join(" "),
      n;
    if (((Dr.lastIndex = 0), Dr.test(t)))
      return (
        (n = LE.test(t)),
        (e[1] = Jd(e[1], n)),
        (e[0] = Jd(e[0], n, Km(e[1]))),
        !0
      );
  },
  _a,
  qn = (function () {
    var s = Date.now,
      e = 500,
      t = 33,
      n = s(),
      i = n,
      r = 1e3 / 240,
      o = r,
      a = [],
      l,
      c,
      h,
      u,
      f,
      d,
      _ = function g(m) {
        var p = s() - i,
          M = m === !0,
          S,
          v,
          C,
          w;
        if (
          ((p > e || p < 0) && (n += p - t),
          (i += p),
          (C = i - n),
          (S = C - o),
          (S > 0 || M) &&
            ((w = ++u.frame),
            (f = C - u.time * 1e3),
            (u.time = C = C / 1e3),
            (o += S + (S >= r ? 4 : r - S)),
            (v = 1)),
          M || (l = c(g)),
          v)
        )
          for (d = 0; d < a.length; d++) a[d](C, f, w, m);
      };
    return (
      (u = {
        time: 0,
        frame: 0,
        tick: function () {
          _(!0);
        },
        deltaRatio: function (m) {
          return f / (1e3 / (m || 60));
        },
        wake: function () {
          wm &&
            (!eu &&
              ju() &&
              ((Ti = eu = window),
              (Ku = Ti.document || {}),
              (Jn.gsap = kn),
              (Ti.gsapVersions || (Ti.gsapVersions = [])).push(kn.version),
              Rm(kl || Ti.GreenSockGlobals || (!Ti.gsap && Ti) || {}),
              Ym.forEach(qm)),
            (h = typeof requestAnimationFrame < "u" && requestAnimationFrame),
            l && u.sleep(),
            (c =
              h ||
              function (m) {
                return setTimeout(m, (o - u.time * 1e3 + 1) | 0);
              }),
            (_a = 1),
            _(2));
        },
        sleep: function () {
          (h ? cancelAnimationFrame : clearTimeout)(l), (_a = 0), (c = pa);
        },
        lagSmoothing: function (m, p) {
          (e = m || 1 / 0), (t = Math.min(p || 33, e));
        },
        fps: function (m) {
          (r = 1e3 / (m || 240)), (o = u.time * 1e3 + r);
        },
        add: function (m, p, M) {
          var S = p
            ? function (v, C, w, E) {
                m(v, C, w, E), u.remove(S);
              }
            : m;
          return u.remove(m), a[M ? "unshift" : "push"](S), vo(), S;
        },
        remove: function (m, p) {
          ~(p = a.indexOf(m)) && a.splice(p, 1) && d >= p && d--;
        },
        _listeners: a,
      }),
      u
    );
  })(),
  vo = function () {
    return !_a && qn.wake();
  },
  lt = {},
  IE = /^[\d.\-M][\d.\-,\s]/,
  UE = /["']/g,
  NE = function (e) {
    for (
      var t = {},
        n = e.substr(1, e.length - 3).split(":"),
        i = n[0],
        r = 1,
        o = n.length,
        a,
        l,
        c;
      r < o;
      r++
    )
      (l = n[r]),
        (a = r !== o - 1 ? l.lastIndexOf(",") : l.length),
        (c = l.substr(0, a)),
        (t[i] = isNaN(c) ? c.replace(UE, "").trim() : +c),
        (i = l.substr(a + 1).trim());
    return t;
  },
  OE = function (e) {
    var t = e.indexOf("(") + 1,
      n = e.indexOf(")"),
      i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
  },
  FE = function (e) {
    var t = (e + "").split("("),
      n = lt[t[0]];
    return n && t.length > 1 && n.config
      ? n.config.apply(
          null,
          ~e.indexOf("{") ? [NE(t[1])] : OE(e).split(",").map(Im)
        )
      : lt._CE && IE.test(e)
      ? lt._CE("", e)
      : n;
  },
  Zm = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  Jm = function s(e, t) {
    for (var n = e._first, i; n; )
      n instanceof En
        ? s(n, t)
        : n.vars.yoyoEase &&
          (!n._yoyo || !n._repeat) &&
          n._yoyo !== t &&
          (n.timeline
            ? s(n.timeline, t)
            : ((i = n._ease),
              (n._ease = n._yEase),
              (n._yEase = i),
              (n._yoyo = t))),
        (n = n._next);
  },
  is = function (e, t) {
    return (e && (Ot(e) ? e : lt[e] || FE(e))) || t;
  },
  gs = function (e, t, n, i) {
    n === void 0 &&
      (n = function (l) {
        return 1 - t(1 - l);
      }),
      i === void 0 &&
        (i = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        });
    var r = { easeIn: t, easeOut: n, easeInOut: i },
      o;
    return (
      On(e, function (a) {
        (lt[a] = Jn[a] = r), (lt[(o = a.toLowerCase())] = n);
        for (var l in r)
          lt[
            o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
          ] = lt[a + "." + l] = r[l];
      }),
      r
    );
  },
  Qm = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  Kc = function s(e, t, n) {
    var i = t >= 1 ? t : 1,
      r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      o = (r / Jh) * (Math.asin(1 / i) || 0),
      a = function (h) {
        return h === 1 ? 1 : i * Math.pow(2, -10 * h) * uE((h - o) * r) + 1;
      },
      l =
        e === "out"
          ? a
          : e === "in"
          ? function (c) {
              return 1 - a(1 - c);
            }
          : Qm(a);
    return (
      (r = Jh / r),
      (l.config = function (c, h) {
        return s(e, c, h);
      }),
      l
    );
  },
  $c = function s(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function (o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
      },
      i =
        e === "out"
          ? n
          : e === "in"
          ? function (r) {
              return 1 - n(1 - r);
            }
          : Qm(n);
    return (
      (i.config = function (r) {
        return s(e, r);
      }),
      i
    );
  };
On("Linear,Quad,Cubic,Quart,Quint,Strong", function (s, e) {
  var t = e < 5 ? e + 1 : e;
  gs(
    s + ",Power" + (t - 1),
    e
      ? function (n) {
          return Math.pow(n, t);
        }
      : function (n) {
          return n;
        },
    function (n) {
      return 1 - Math.pow(1 - n, t);
    },
    function (n) {
      return n < 0.5
        ? Math.pow(n * 2, t) / 2
        : 1 - Math.pow((1 - n) * 2, t) / 2;
    }
  );
});
lt.Linear.easeNone = lt.none = lt.Linear.easeIn;
gs("Elastic", Kc("in"), Kc("out"), Kc());
(function (s, e) {
  var t = 1 / e,
    n = 2 * t,
    i = 2.5 * t,
    r = function (a) {
      return a < t
        ? s * a * a
        : a < n
        ? s * Math.pow(a - 1.5 / e, 2) + 0.75
        : a < i
        ? s * (a -= 2.25 / e) * a + 0.9375
        : s * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
  gs(
    "Bounce",
    function (o) {
      return 1 - r(1 - o);
    },
    r
  );
})(7.5625, 2.75);
gs("Expo", function (s) {
  return s ? Math.pow(2, 10 * (s - 1)) : 0;
});
gs("Circ", function (s) {
  return -(Sm(1 - s * s) - 1);
});
gs("Sine", function (s) {
  return s === 1 ? 1 : -hE(s * lE) + 1;
});
gs("Back", $c("in"), $c("out"), $c());
lt.SteppedEase =
  lt.steps =
  Jn.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e,
          i = e + (t ? 0 : 1),
          r = t ? 1 : 0,
          o = 1 - At;
        return function (a) {
          return (((i * wa(0, o, a)) | 0) + r) * n;
        };
      },
    };
mo.ease = lt["quad.out"];
On(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (s) {
    return (Ju += s + "," + s + "Params,");
  }
);
var e_ = function (e, t) {
    (this.id = cE++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : Dm),
      (this.set = t ? t.getSetter : rf);
  },
  ga = (function () {
    function s(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        go(this, +t.duration, 1, 1),
        (this.data = t.data),
        Pt && ((this._ctx = Pt), Pt.data.push(this)),
        _a || qn.wake();
    }
    var e = s.prototype;
    return (
      (e.delay = function (n) {
        return n || n === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + n - this._delay),
            (this._delay = n),
            this)
          : this._delay;
      }),
      (e.duration = function (n) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (n) {
        return arguments.length
          ? ((this._dirty = 0),
            go(
              this,
              this._repeat < 0
                ? n
                : (n - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (n, i) {
        if ((vo(), !arguments.length)) return this._tTime;
        var r = this._dp;
        if (r && r.smoothChildTiming && this._ts) {
          for (sc(this, n), !r._dp || r.parent || Om(r, this); r && r.parent; )
            r.parent._time !==
              r._start +
                (r._ts >= 0
                  ? r._tTime / r._ts
                  : (r.totalDuration() - r._tTime) / -r._ts) &&
              r.totalTime(r._tTime, !0),
              (r = r.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && n < this._tDur) ||
              (this._ts < 0 && n > 0) ||
              (!this._tDur && !n)) &&
            wi(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== n ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === At) ||
            (!n && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = n), Lm(this, n, i)),
          this
        );
      }),
      (e.time = function (n, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), n + Kd(this)) %
                (this._dur + this._rDelay) || (n ? this._dur : 0),
              i
            )
          : this._time;
      }),
      (e.totalProgress = function (n, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * n, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.rawTime() > 0
          ? 1
          : 0;
      }),
      (e.progress = function (n, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) +
                Kd(this),
              i
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.rawTime() > 0
          ? 1
          : 0;
      }),
      (e.iteration = function (n, i) {
        var r = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (n - 1) * r, i)
          : this._repeat
          ? _o(this._tTime, r) + 1
          : 1;
      }),
      (e.timeScale = function (n, i) {
        if (!arguments.length) return this._rts === -At ? 0 : this._rts;
        if (this._rts === n) return this;
        var r =
          this.parent && this._ts ? Vl(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +n || 0),
          (this._ts = this._ps || n === -At ? 0 : this._rts),
          this.totalTime(wa(-Math.abs(this._delay), this._tDur, r), i !== !1),
          rc(this),
          vE(this)
        );
      }),
      (e.paused = function (n) {
        return arguments.length
          ? (this._ps !== n &&
              ((this._ps = n),
              n
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (vo(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== At &&
                      (this._tTime -= At)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (n) {
        if (arguments.length) {
          this._start = n;
          var i = this.parent || this._dp;
          return (
            i && (i._sort || !this.parent) && wi(i, this, n - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (n) {
        return (
          this._start +
          (Nn(n) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (n) {
        var i = this.parent || this._dp;
        return i
          ? n &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? Vl(i.rawTime(n), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (n) {
        n === void 0 && (n = pE);
        var i = fn;
        return (
          (fn = n),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(n),
            this.totalTime(-0.01, n.suppressEvents)),
          this.data !== "nested" && n.kill !== !1 && this.kill(),
          (fn = i),
          this
        );
      }),
      (e.globalTime = function (n) {
        for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
          (r = i._start + r / (Math.abs(i._ts) || 1)), (i = i._dp);
        return !this.parent && this._sat ? this._sat.globalTime(n) : r;
      }),
      (e.repeat = function (n) {
        return arguments.length
          ? ((this._repeat = n === 1 / 0 ? -2 : n), $d(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (n) {
        if (arguments.length) {
          var i = this._time;
          return (this._rDelay = n), $d(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (n) {
        return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
      }),
      (e.seek = function (n, i) {
        return this.totalTime(ti(this, n), Nn(i));
      }),
      (e.restart = function (n, i) {
        return this.play().totalTime(n ? -this._delay : 0, Nn(i));
      }),
      (e.play = function (n, i) {
        return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (n, i) {
        return (
          n != null && this.seek(n || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (n, i) {
        return n != null && this.seek(n, i), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (n) {
        return arguments.length
          ? (!!n !== this.reversed() &&
              this.timeScale(-this._rts || (n ? -At : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -At), this;
      }),
      (e.isActive = function () {
        var n = this.parent || this._dp,
          i = this._start,
          r;
        return !!(
          !n ||
          (this._ts &&
            this._initted &&
            n.isActive() &&
            (r = n.rawTime(!0)) >= i &&
            r < this.endTime(!0) - At)
        );
      }),
      (e.eventCallback = function (n, i, r) {
        var o = this.vars;
        return arguments.length > 1
          ? (i
              ? ((o[n] = i),
                r && (o[n + "Params"] = r),
                n === "onUpdate" && (this._onUpdate = i))
              : delete o[n],
            this)
          : o[n];
      }),
      (e.then = function (n) {
        var i = this;
        return new Promise(function (r) {
          var o = Ot(n) ? n : Um,
            a = function () {
              var c = i.then;
              (i.then = null),
                Ot(o) && (o = o(i)) && (o.then || o === i) && (i.then = c),
                r(o),
                (i.then = c);
            };
          (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? a()
            : (i._prom = a);
        });
      }),
      (e.kill = function () {
        Ho(this);
      }),
      s
    );
  })();
ci(ga.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -At,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var En = (function (s) {
  Mm(e, s);
  function e(n, i) {
    var r;
    return (
      n === void 0 && (n = {}),
      (r = s.call(this, n) || this),
      (r.labels = {}),
      (r.smoothChildTiming = !!n.smoothChildTiming),
      (r.autoRemoveChildren = !!n.autoRemoveChildren),
      (r._sort = Nn(n.sortChildren)),
      Lt && wi(n.parent || Lt, $i(r), i),
      n.reversed && r.reverse(),
      n.paused && r.paused(!0),
      n.scrollTrigger && Fm($i(r), n.scrollTrigger),
      r
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (i, r, o) {
      return Jo(0, arguments, this), this;
    }),
    (t.from = function (i, r, o) {
      return Jo(1, arguments, this), this;
    }),
    (t.fromTo = function (i, r, o, a) {
      return Jo(2, arguments, this), this;
    }),
    (t.set = function (i, r, o) {
      return (
        (r.duration = 0),
        (r.parent = this),
        Zo(r).repeatDelay || (r.repeat = 0),
        (r.immediateRender = !!r.immediateRender),
        new Gt(i, r, ti(this, o), 1),
        this
      );
    }),
    (t.call = function (i, r, o) {
      return wi(this, Gt.delayedCall(0, i, r), o);
    }),
    (t.staggerTo = function (i, r, o, a, l, c, h) {
      return (
        (o.duration = r),
        (o.stagger = o.stagger || a),
        (o.onComplete = c),
        (o.onCompleteParams = h),
        (o.parent = this),
        new Gt(i, o, ti(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (i, r, o, a, l, c, h) {
      return (
        (o.runBackwards = 1),
        (Zo(o).immediateRender = Nn(o.immediateRender)),
        this.staggerTo(i, r, o, a, l, c, h)
      );
    }),
    (t.staggerFromTo = function (i, r, o, a, l, c, h, u) {
      return (
        (a.startAt = o),
        (Zo(a).immediateRender = Nn(a.immediateRender)),
        this.staggerTo(i, r, a, l, c, h, u)
      );
    }),
    (t.render = function (i, r, o) {
      var a = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        c = this._dur,
        h = i <= 0 ? 0 : en(i),
        u = this._zTime < 0 != i < 0 && (this._initted || !c),
        f,
        d,
        _,
        g,
        m,
        p,
        M,
        S,
        v,
        C,
        w,
        E;
      if (
        (this !== Lt && h > l && i >= 0 && (h = l), h !== this._tTime || o || u)
      ) {
        if (
          (a !== this._time &&
            c &&
            ((h += this._time - a), (i += this._time - a)),
          (f = h),
          (v = this._start),
          (S = this._ts),
          (p = !S),
          u && (c || (a = this._zTime), (i || !r) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((w = this._yoyo),
            (m = c + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(m * 100 + i, r, o);
          if (
            ((f = en(h % m)),
            h === l
              ? ((g = this._repeat), (f = c))
              : ((g = ~~(h / m)),
                g && g === h / m && ((f = c), g--),
                f > c && (f = c)),
            (C = _o(this._tTime, m)),
            !a &&
              this._tTime &&
              C !== g &&
              this._tTime - C * m - this._dur <= 0 &&
              (C = g),
            w && g & 1 && ((f = c - f), (E = 1)),
            g !== C && !this._lock)
          ) {
            var A = w && C & 1,
              y = A === (w && g & 1);
            if (
              (g < C && (A = !A),
              (a = A ? 0 : h % c ? c : h),
              (this._lock = 1),
              (this.render(a || (E ? 0 : en(g * m)), r, !c)._lock = 0),
              (this._tTime = h),
              !r && this.parent && $n(this, "onRepeat"),
              this.vars.repeatRefresh && !E && (this.invalidate()._lock = 1),
              (a && a !== this._time) ||
                p !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((c = this._dur),
              (l = this._tDur),
              y &&
                ((this._lock = 2),
                (a = A ? c : -1e-4),
                this.render(a, !0),
                this.vars.repeatRefresh && !E && this.invalidate()),
              (this._lock = 0),
              !this._ts && !p)
            )
              return this;
            Jm(this, E);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((M = SE(this, en(a), en(f))), M && (h -= f - (f = M._start))),
          (this._tTime = h),
          (this._time = f),
          (this._act = !S),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (a = 0)),
          !a && f && !r && !g && ($n(this, "onStart"), this._tTime !== h))
        )
          return this;
        if (f >= a && i >= 0)
          for (d = this._first; d; ) {
            if (
              ((_ = d._next), (d._act || f >= d._start) && d._ts && M !== d)
            ) {
              if (d.parent !== this) return this.render(i, r, o);
              if (
                (d.render(
                  d._ts > 0
                    ? (f - d._start) * d._ts
                    : (d._dirty ? d.totalDuration() : d._tDur) +
                        (f - d._start) * d._ts,
                  r,
                  o
                ),
                f !== this._time || (!this._ts && !p))
              ) {
                (M = 0), _ && (h += this._zTime = -At);
                break;
              }
            }
            d = _;
          }
        else {
          d = this._last;
          for (var x = i < 0 ? i : f; d; ) {
            if (((_ = d._prev), (d._act || x <= d._end) && d._ts && M !== d)) {
              if (d.parent !== this) return this.render(i, r, o);
              if (
                (d.render(
                  d._ts > 0
                    ? (x - d._start) * d._ts
                    : (d._dirty ? d.totalDuration() : d._tDur) +
                        (x - d._start) * d._ts,
                  r,
                  o || (fn && (d._initted || d._startAt))
                ),
                f !== this._time || (!this._ts && !p))
              ) {
                (M = 0), _ && (h += this._zTime = x ? -At : At);
                break;
              }
            }
            d = _;
          }
        }
        if (
          M &&
          !r &&
          (this.pause(),
          (M.render(f >= a ? 0 : -At)._zTime = f >= a ? 1 : -1),
          this._ts)
        )
          return (this._start = v), rc(this), this.render(i, r, o);
        this._onUpdate && !r && $n(this, "onUpdate", !0),
          ((h === l && this._tTime >= this.totalDuration()) || (!h && a)) &&
            (v === this._start || Math.abs(S) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !c) &&
                ((h === l && this._ts > 0) || (!h && this._ts < 0)) &&
                Ir(this, 1),
              !r &&
                !(i < 0 && !a) &&
                (h || a || !l) &&
                ($n(
                  this,
                  h === l && i >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(h < l && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (i, r) {
      var o = this;
      if ((ar(r) || (r = ti(this, r, i)), !(i instanceof ga))) {
        if (dn(i))
          return (
            i.forEach(function (a) {
              return o.add(a, r);
            }),
            this
          );
        if (rn(i)) return this.addLabel(i, r);
        if (Ot(i)) i = Gt.delayedCall(0, i);
        else return this;
      }
      return this !== i ? wi(this, i, r) : this;
    }),
    (t.getChildren = function (i, r, o, a) {
      i === void 0 && (i = !0),
        r === void 0 && (r = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -oi);
      for (var l = [], c = this._first; c; )
        c._start >= a &&
          (c instanceof Gt
            ? r && l.push(c)
            : (o && l.push(c), i && l.push.apply(l, c.getChildren(!0, r, o)))),
          (c = c._next);
      return l;
    }),
    (t.getById = function (i) {
      for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
        if (r[o].vars.id === i) return r[o];
    }),
    (t.remove = function (i) {
      return rn(i)
        ? this.removeLabel(i)
        : Ot(i)
        ? this.killTweensOf(i)
        : (ic(this, i),
          i === this._recent && (this._recent = this._last),
          ns(this));
    }),
    (t.totalTime = function (i, r) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = en(
              qn.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts)
            )),
          s.prototype.totalTime.call(this, i, r),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (i, r) {
      return (this.labels[i] = ti(this, r)), this;
    }),
    (t.removeLabel = function (i) {
      return delete this.labels[i], this;
    }),
    (t.addPause = function (i, r, o) {
      var a = Gt.delayedCall(0, r || pa, o);
      return (
        (a.data = "isPause"), (this._hasPause = 1), wi(this, a, ti(this, i))
      );
    }),
    (t.removePause = function (i) {
      var r = this._first;
      for (i = ti(this, i); r; )
        r._start === i && r.data === "isPause" && Ir(r), (r = r._next);
    }),
    (t.killTweensOf = function (i, r, o) {
      for (var a = this.getTweensOf(i, o), l = a.length; l--; )
        Er !== a[l] && a[l].kill(i, r);
      return this;
    }),
    (t.getTweensOf = function (i, r) {
      for (var o = [], a = ai(i), l = this._first, c = ar(r), h; l; )
        l instanceof Gt
          ? mE(l._targets, a) &&
            (c
              ? (!Er || (l._initted && l._ts)) &&
                l.globalTime(0) <= r &&
                l.globalTime(l.totalDuration()) > r
              : !r || l.isActive()) &&
            o.push(l)
          : (h = l.getTweensOf(a, r)).length && o.push.apply(o, h),
          (l = l._next);
      return o;
    }),
    (t.tweenTo = function (i, r) {
      r = r || {};
      var o = this,
        a = ti(o, i),
        l = r,
        c = l.startAt,
        h = l.onStart,
        u = l.onStartParams,
        f = l.immediateRender,
        d,
        _ = Gt.to(
          o,
          ci(
            {
              ease: r.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: a,
              overwrite: "auto",
              duration:
                r.duration ||
                Math.abs(
                  (a - (c && "time" in c ? c.time : o._time)) / o.timeScale()
                ) ||
                At,
              onStart: function () {
                if ((o.pause(), !d)) {
                  var m =
                    r.duration ||
                    Math.abs(
                      (a - (c && "time" in c ? c.time : o._time)) /
                        o.timeScale()
                    );
                  _._dur !== m && go(_, m, 0, 1).render(_._time, !0, !0),
                    (d = 1);
                }
                h && h.apply(_, u || []);
              },
            },
            r
          )
        );
      return f ? _.render(0) : _;
    }),
    (t.tweenFromTo = function (i, r, o) {
      return this.tweenTo(r, ci({ startAt: { time: ti(this, i) } }, o));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (i) {
      return i === void 0 && (i = this._time), Zd(this, ti(this, i));
    }),
    (t.previousLabel = function (i) {
      return i === void 0 && (i = this._time), Zd(this, ti(this, i), 1);
    }),
    (t.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + At);
    }),
    (t.shiftChildren = function (i, r, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, l = this.labels, c; a; )
        a._start >= o && ((a._start += i), (a._end += i)), (a = a._next);
      if (r) for (c in l) l[c] >= o && (l[c] += i);
      return ns(this);
    }),
    (t.invalidate = function (i) {
      var r = this._first;
      for (this._lock = 0; r; ) r.invalidate(i), (r = r._next);
      return s.prototype.invalidate.call(this, i);
    }),
    (t.clear = function (i) {
      i === void 0 && (i = !0);
      for (var r = this._first, o; r; ) (o = r._next), this.remove(r), (r = o);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        ns(this)
      );
    }),
    (t.totalDuration = function (i) {
      var r = 0,
        o = this,
        a = o._last,
        l = oi,
        c,
        h,
        u;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -i : i)
        );
      if (o._dirty) {
        for (u = o.parent; a; )
          (c = a._prev),
            a._dirty && a.totalDuration(),
            (h = a._start),
            h > l && o._sort && a._ts && !o._lock
              ? ((o._lock = 1), (wi(o, a, h - a._delay, 1)._lock = 0))
              : (l = h),
            h < 0 &&
              a._ts &&
              ((r -= h),
              ((!u && !o._dp) || (u && u.smoothChildTiming)) &&
                ((o._start += h / o._ts), (o._time -= h), (o._tTime -= h)),
              o.shiftChildren(-h, !1, -1 / 0),
              (l = 0)),
            a._end > r && a._ts && (r = a._end),
            (a = c);
        go(o, o === Lt && o._time > r ? o._time : r, 1, 1), (o._dirty = 0);
      }
      return o._tDur;
    }),
    (e.updateRoot = function (i) {
      if ((Lt._ts && (Lm(Lt, Vl(i, Lt)), (Pm = qn.frame)), qn.frame >= qd)) {
        qd += Zn.autoSleep || 120;
        var r = Lt._first;
        if ((!r || !r._ts) && Zn.autoSleep && qn._listeners.length < 2) {
          for (; r && !r._ts; ) r = r._next;
          r || qn.sleep();
        }
      }
    }),
    e
  );
})(ga);
ci(En.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var BE = function (e, t, n, i, r, o, a) {
    var l = new Fn(this._pt, e, t, 0, 1, o_, null, r),
      c = 0,
      h = 0,
      u,
      f,
      d,
      _,
      g,
      m,
      p,
      M;
    for (
      l.b = n,
        l.e = i,
        n += "",
        i += "",
        (p = ~i.indexOf("random(")) && (i = ma(i)),
        o && ((M = [n, i]), o(M, e, t), (n = M[0]), (i = M[1])),
        f = n.match(Yc) || [];
      (u = Yc.exec(i));

    )
      (_ = u[0]),
        (g = i.substring(c, u.index)),
        d ? (d = (d + 1) % 5) : g.substr(-5) === "rgba(" && (d = 1),
        _ !== f[h++] &&
          ((m = parseFloat(f[h - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: g || h === 1 ? g : ",",
            s: m,
            c: _.charAt(1) === "=" ? $s(m, _) - m : parseFloat(_) - m,
            m: d && d < 4 ? Math.round : 0,
          }),
          (c = Yc.lastIndex));
    return (
      (l.c = c < i.length ? i.substring(c, i.length) : ""),
      (l.fp = a),
      (bm.test(i) || p) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  ef = function (e, t, n, i, r, o, a, l, c, h) {
    Ot(i) && (i = i(r || 0, e, o));
    var u = e[t],
      f =
        n !== "get"
          ? n
          : Ot(u)
          ? c
            ? e[
                t.indexOf("set") || !Ot(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](c)
            : e[t]()
          : u,
      d = Ot(u) ? (c ? GE : r_) : nf,
      _;
    if (
      (rn(i) &&
        (~i.indexOf("random(") && (i = ma(i)),
        i.charAt(1) === "=" &&
          ((_ = $s(f, i) + (un(f) || 0)), (_ || _ === 0) && (i = _))),
      !h || f !== i || au)
    )
      return !isNaN(f * i) && i !== ""
        ? ((_ = new Fn(
            this._pt,
            e,
            t,
            +f || 0,
            i - (f || 0),
            typeof u == "boolean" ? XE : s_,
            0,
            d
          )),
          c && (_.fp = c),
          a && _.modifier(a, this, e),
          (this._pt = _))
        : (!u && !(t in e) && $u(t, i),
          BE.call(this, e, t, f, i, d, l || Zn.stringFilter, c));
  },
  kE = function (e, t, n, i, r) {
    if (
      (Ot(e) && (e = Qo(e, r, t, n, i)),
      !Fi(e) || (e.style && e.nodeType) || dn(e) || Tm(e))
    )
      return rn(e) ? Qo(e, r, t, n, i) : e;
    var o = {},
      a;
    for (a in e) o[a] = Qo(e[a], r, t, n, i);
    return o;
  },
  t_ = function (e, t, n, i, r, o) {
    var a, l, c, h;
    if (
      Yn[e] &&
      (a = new Yn[e]()).init(
        r,
        a.rawVars ? t[e] : kE(t[e], i, r, o, n),
        n,
        i,
        o
      ) !== !1 &&
      ((n._pt = l = new Fn(n._pt, r, e, 0, 1, a.render, a, 0, a.priority)),
      n !== Gs)
    )
      for (c = n._ptLookup[n._targets.indexOf(r)], h = a._props.length; h--; )
        c[a._props[h]] = l;
    return a;
  },
  Er,
  au,
  tf = function s(e, t, n) {
    var i = e.vars,
      r = i.ease,
      o = i.startAt,
      a = i.immediateRender,
      l = i.lazy,
      c = i.onUpdate,
      h = i.runBackwards,
      u = i.yoyoEase,
      f = i.keyframes,
      d = i.autoRevert,
      _ = e._dur,
      g = e._startAt,
      m = e._targets,
      p = e.parent,
      M = p && p.data === "nested" ? p.vars.targets : m,
      S = e._overwrite === "auto" && !Yu,
      v = e.timeline,
      C,
      w,
      E,
      A,
      y,
      x,
      P,
      I,
      O,
      k,
      G,
      z,
      q;
    if (
      (v && (!f || !r) && (r = "none"),
      (e._ease = is(r, mo.ease)),
      (e._yEase = u ? Zm(is(u === !0 ? r : u, mo.ease)) : 0),
      u &&
        e._yoyo &&
        !e._repeat &&
        ((u = e._yEase), (e._yEase = e._ease), (e._ease = u)),
      (e._from = !v && !!i.runBackwards),
      !v || (f && !i.stagger))
    ) {
      if (
        ((I = m[0] ? ts(m[0]).harness : 0),
        (z = I && i[I.prop]),
        (C = Hl(i, Zu)),
        g &&
          (g._zTime < 0 && g.progress(1),
          t < 0 && h && a && !d ? g.render(-1, !0) : g.revert(h && _ ? El : dE),
          (g._lazy = 0)),
        o)
      ) {
        if (
          (Ir(
            (e._startAt = Gt.set(
              m,
              ci(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: p,
                  immediateRender: !0,
                  lazy: !g && Nn(l),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    c &&
                    function () {
                      return $n(e, "onUpdate");
                    },
                  stagger: 0,
                },
                o
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (fn || (!a && !d)) && e._startAt.revert(El),
          a && _ && t <= 0 && n <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (h && _ && !g) {
        if (
          (t && (a = !1),
          (E = ci(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: a && !g && Nn(l),
              immediateRender: a,
              stagger: 0,
              parent: p,
            },
            C
          )),
          z && (E[I.prop] = z),
          Ir((e._startAt = Gt.set(m, E))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (fn ? e._startAt.revert(El) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !a)
        )
          s(e._startAt, At, At);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (_ && Nn(l)) || (l && !_), w = 0;
        w < m.length;
        w++
      ) {
        if (
          ((y = m[w]),
          (P = y._gsap || Qu(m)[w]._gsap),
          (e._ptLookup[w] = k = {}),
          tu[P.id] && Pr.length && zl(),
          (G = M === m ? w : M.indexOf(y)),
          I &&
            (O = new I()).init(y, z || C, e, G, M) !== !1 &&
            ((e._pt = A =
              new Fn(e._pt, y, O.name, 0, 1, O.render, O, 0, O.priority)),
            O._props.forEach(function (H) {
              k[H] = A;
            }),
            O.priority && (x = 1)),
          !I || z)
        )
          for (E in C)
            Yn[E] && (O = t_(E, C, e, G, y, M))
              ? O.priority && (x = 1)
              : (k[E] = A =
                  ef.call(e, y, E, "get", C[E], G, M, 0, i.stringFilter));
        e._op && e._op[w] && e.kill(y, e._op[w]),
          S &&
            e._pt &&
            ((Er = e),
            Lt.killTweensOf(y, k, e.globalTime(t)),
            (q = !e.parent),
            (Er = 0)),
          e._pt && l && (tu[P.id] = 1);
      }
      x && a_(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = c),
      (e._initted = (!e._op || e._pt) && !q),
      f && t <= 0 && v.render(oi, !0, !0);
  },
  zE = function (e, t, n, i, r, o, a, l) {
    var c = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      h,
      u,
      f,
      d;
    if (!c)
      for (
        c = e._ptCache[t] = [], f = e._ptLookup, d = e._targets.length;
        d--;

      ) {
        if (((h = f[d][t]), h && h.d && h.d._pt))
          for (h = h.d._pt; h && h.p !== t && h.fp !== t; ) h = h._next;
        if (!h)
          return (
            (au = 1),
            (e.vars[t] = "+=0"),
            tf(e, a),
            (au = 0),
            l ? da(t + " not eligible for reset") : 1
          );
        c.push(h);
      }
    for (d = c.length; d--; )
      (u = c[d]),
        (h = u._pt || u),
        (h.s = (i || i === 0) && !r ? i : h.s + (i || 0) + o * h.c),
        (h.c = n - h.s),
        u.e && (u.e = Bt(n) + un(u.e)),
        u.b && (u.b = h.s + un(u.b));
  },
  HE = function (e, t) {
    var n = e[0] ? ts(e[0]).harness : 0,
      i = n && n.aliases,
      r,
      o,
      a,
      l;
    if (!i) return t;
    r = hs({}, t);
    for (o in i)
      if (o in r) for (l = i[o].split(","), a = l.length; a--; ) r[l[a]] = r[o];
    return r;
  },
  VE = function (e, t, n, i) {
    var r = t.ease || i || "power1.inOut",
      o,
      a;
    if (dn(t))
      (a = n[e] || (n[e] = [])),
        t.forEach(function (l, c) {
          return a.push({ t: (c / (t.length - 1)) * 100, v: l, e: r });
        });
    else
      for (o in t)
        (a = n[o] || (n[o] = [])),
          o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: r });
  },
  Qo = function (e, t, n, i, r) {
    return Ot(e)
      ? e.call(t, n, i, r)
      : rn(e) && ~e.indexOf("random(")
      ? ma(e)
      : e;
  },
  n_ = Ju + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  i_ = {};
On(n_ + ",id,stagger,delay,duration,paused,scrollTrigger", function (s) {
  return (i_[s] = 1);
});
var Gt = (function (s) {
  Mm(e, s);
  function e(n, i, r, o) {
    var a;
    typeof i == "number" && ((r.duration = i), (i = r), (r = null)),
      (a = s.call(this, o ? i : Zo(i)) || this);
    var l = a.vars,
      c = l.duration,
      h = l.delay,
      u = l.immediateRender,
      f = l.stagger,
      d = l.overwrite,
      _ = l.keyframes,
      g = l.defaults,
      m = l.scrollTrigger,
      p = l.yoyoEase,
      M = i.parent || Lt,
      S = (dn(n) || Tm(n) ? ar(n[0]) : "length" in i) ? [n] : ai(n),
      v,
      C,
      w,
      E,
      A,
      y,
      x,
      P;
    if (
      ((a._targets = S.length
        ? Qu(S)
        : da(
            "GSAP target " + n + " not found. https://gsap.com",
            !Zn.nullTargetWarn
          ) || []),
      (a._ptLookup = []),
      (a._overwrite = d),
      _ || f || il(c) || il(h))
    ) {
      if (
        ((i = a.vars),
        (v = a.timeline =
          new En({
            data: "nested",
            defaults: g || {},
            targets: M && M.data === "nested" ? M.vars.targets : S,
          })),
        v.kill(),
        (v.parent = v._dp = $i(a)),
        (v._start = 0),
        f || il(c) || il(h))
      ) {
        if (((E = S.length), (x = f && Hm(f)), Fi(f)))
          for (A in f) ~n_.indexOf(A) && (P || (P = {}), (P[A] = f[A]));
        for (C = 0; C < E; C++)
          (w = Hl(i, i_)),
            (w.stagger = 0),
            p && (w.yoyoEase = p),
            P && hs(w, P),
            (y = S[C]),
            (w.duration = +Qo(c, $i(a), C, y, S)),
            (w.delay = (+Qo(h, $i(a), C, y, S) || 0) - a._delay),
            !f &&
              E === 1 &&
              w.delay &&
              ((a._delay = h = w.delay), (a._start += h), (w.delay = 0)),
            v.to(y, w, x ? x(C, y, S) : 0),
            (v._ease = lt.none);
        v.duration() ? (c = h = 0) : (a.timeline = 0);
      } else if (_) {
        Zo(ci(v.vars.defaults, { ease: "none" })),
          (v._ease = is(_.ease || i.ease || "none"));
        var I = 0,
          O,
          k,
          G;
        if (dn(_))
          _.forEach(function (z) {
            return v.to(S, z, ">");
          }),
            v.duration();
        else {
          w = {};
          for (A in _)
            A === "ease" || A === "easeEach" || VE(A, _[A], w, _.easeEach);
          for (A in w)
            for (
              O = w[A].sort(function (z, q) {
                return z.t - q.t;
              }),
                I = 0,
                C = 0;
              C < O.length;
              C++
            )
              (k = O[C]),
                (G = {
                  ease: k.e,
                  duration: ((k.t - (C ? O[C - 1].t : 0)) / 100) * c,
                }),
                (G[A] = k.v),
                v.to(S, G, I),
                (I += G.duration);
          v.duration() < c && v.to({}, { duration: c - v.duration() });
        }
      }
      c || a.duration((c = v.duration()));
    } else a.timeline = 0;
    return (
      d === !0 && !Yu && ((Er = $i(a)), Lt.killTweensOf(S), (Er = 0)),
      wi(M, $i(a), r),
      i.reversed && a.reverse(),
      i.paused && a.paused(!0),
      (u ||
        (!c &&
          !_ &&
          a._start === en(M._time) &&
          Nn(u) &&
          xE($i(a)) &&
          M.data !== "nested")) &&
        ((a._tTime = -At), a.render(Math.max(0, -h) || 0)),
      m && Fm($i(a), m),
      a
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (i, r, o) {
      var a = this._time,
        l = this._tDur,
        c = this._dur,
        h = i < 0,
        u = i > l - At && !h ? l : i < At ? 0 : i,
        f,
        d,
        _,
        g,
        m,
        p,
        M,
        S,
        v;
      if (!c) ME(this, i, r, o);
      else if (
        u !== this._tTime ||
        !i ||
        o ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== h)
      ) {
        if (((f = u), (S = this.timeline), this._repeat)) {
          if (((g = c + this._rDelay), this._repeat < -1 && h))
            return this.totalTime(g * 100 + i, r, o);
          if (
            ((f = en(u % g)),
            u === l
              ? ((_ = this._repeat), (f = c))
              : ((_ = ~~(u / g)),
                _ && _ === en(u / g) && ((f = c), _--),
                f > c && (f = c)),
            (p = this._yoyo && _ & 1),
            p && ((v = this._yEase), (f = c - f)),
            (m = _o(this._tTime, g)),
            f === a && !o && this._initted && _ === m)
          )
            return (this._tTime = u), this;
          _ !== m &&
            (S && this._yEase && Jm(S, p),
            this.vars.repeatRefresh &&
              !p &&
              !this._lock &&
              this._time !== g &&
              this._initted &&
              ((this._lock = o = 1),
              (this.render(en(g * _), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (Bm(this, h ? i : f, o, r, u)) return (this._tTime = 0), this;
          if (a !== this._time && !(o && this.vars.repeatRefresh && _ !== m))
            return this;
          if (c !== this._dur) return this.render(i, r, o);
        }
        if (
          ((this._tTime = u),
          (this._time = f),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = M = (v || this._ease)(f / c)),
          this._from && (this.ratio = M = 1 - M),
          f && !a && !r && !_ && ($n(this, "onStart"), this._tTime !== u))
        )
          return this;
        for (d = this._pt; d; ) d.r(M, d.d), (d = d._next);
        (S && S.render(i < 0 ? i : S._dur * S._ease(f / this._dur), r, o)) ||
          (this._startAt && (this._zTime = i)),
          this._onUpdate &&
            !r &&
            (h && nu(this, i, r, o), $n(this, "onUpdate")),
          this._repeat &&
            _ !== m &&
            this.vars.onRepeat &&
            !r &&
            this.parent &&
            $n(this, "onRepeat"),
          (u === this._tDur || !u) &&
            this._tTime === u &&
            (h && !this._onUpdate && nu(this, i, !0, !0),
            (i || !c) &&
              ((u === this._tDur && this._ts > 0) || (!u && this._ts < 0)) &&
              Ir(this, 1),
            !r &&
              !(h && !a) &&
              (u || a || p) &&
              ($n(this, u === l ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(u < l && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (i) {
      return (
        (!i || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(i),
        s.prototype.invalidate.call(this, i)
      );
    }),
    (t.resetTo = function (i, r, o, a, l) {
      _a || qn.wake(), this._ts || this.play();
      var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        h;
      return (
        this._initted || tf(this, c),
        (h = this._ease(c / this._dur)),
        zE(this, i, r, o, a, h, c, l)
          ? this.resetTo(i, r, o, a, 1)
          : (sc(this, 0),
            this.parent ||
              Nm(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (i, r) {
      if ((r === void 0 && (r = "all"), !i && (!r || r === "all")))
        return (this._lazy = this._pt = 0), this.parent ? Ho(this) : this;
      if (this.timeline) {
        var o = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(i, r, Er && Er.vars.overwrite !== !0)
            ._first || Ho(this),
          this.parent &&
            o !== this.timeline.totalDuration() &&
            go(this, (this._dur * this.timeline._tDur) / o, 0, 1),
          this
        );
      }
      var a = this._targets,
        l = i ? ai(i) : a,
        c = this._ptLookup,
        h = this._pt,
        u,
        f,
        d,
        _,
        g,
        m,
        p;
      if ((!r || r === "all") && gE(a, l))
        return r === "all" && (this._pt = 0), Ho(this);
      for (
        u = this._op = this._op || [],
          r !== "all" &&
            (rn(r) &&
              ((g = {}),
              On(r, function (M) {
                return (g[M] = 1);
              }),
              (r = g)),
            (r = HE(a, r))),
          p = a.length;
        p--;

      )
        if (~l.indexOf(a[p])) {
          (f = c[p]),
            r === "all"
              ? ((u[p] = r), (_ = f), (d = {}))
              : ((d = u[p] = u[p] || {}), (_ = r));
          for (g in _)
            (m = f && f[g]),
              m &&
                ((!("kill" in m.d) || m.d.kill(g) === !0) && ic(this, m, "_pt"),
                delete f[g]),
              d !== "all" && (d[g] = 1);
        }
      return this._initted && !this._pt && h && Ho(this), this;
    }),
    (e.to = function (i, r) {
      return new e(i, r, arguments[2]);
    }),
    (e.from = function (i, r) {
      return Jo(1, arguments);
    }),
    (e.delayedCall = function (i, r, o, a) {
      return new e(r, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: i,
        onComplete: r,
        onReverseComplete: r,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: a,
      });
    }),
    (e.fromTo = function (i, r, o) {
      return Jo(2, arguments);
    }),
    (e.set = function (i, r) {
      return (r.duration = 0), r.repeatDelay || (r.repeat = 0), new e(i, r);
    }),
    (e.killTweensOf = function (i, r, o) {
      return Lt.killTweensOf(i, r, o);
    }),
    e
  );
})(ga);
ci(Gt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
On("staggerTo,staggerFrom,staggerFromTo", function (s) {
  Gt[s] = function () {
    var e = new En(),
      t = ru.call(arguments, 0);
    return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
  };
});
var nf = function (e, t, n) {
    return (e[t] = n);
  },
  r_ = function (e, t, n) {
    return e[t](n);
  },
  GE = function (e, t, n, i) {
    return e[t](i.fp, n);
  },
  WE = function (e, t, n) {
    return e.setAttribute(t, n);
  },
  rf = function (e, t) {
    return Ot(e[t]) ? r_ : qu(e[t]) && e.setAttribute ? WE : nf;
  },
  s_ = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  XE = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  o_ = function (e, t) {
    var n = t._pt,
      i = "";
    if (!e && t.b) i = t.b;
    else if (e === 1 && t.e) i = t.e;
    else {
      for (; n; )
        (i =
          n.p +
          (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) +
          i),
          (n = n._next);
      i += t.c;
    }
    t.set(t.t, t.p, i, t);
  },
  sf = function (e, t) {
    for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
  },
  YE = function (e, t, n, i) {
    for (var r = this._pt, o; r; )
      (o = r._next), r.p === i && r.modifier(e, t, n), (r = o);
  },
  qE = function (e) {
    for (var t = this._pt, n, i; t; )
      (i = t._next),
        (t.p === e && !t.op) || t.op === e
          ? ic(this, t, "_pt")
          : t.dep || (n = 1),
        (t = i);
    return !n;
  },
  jE = function (e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
  },
  a_ = function (e) {
    for (var t = e._pt, n, i, r, o; t; ) {
      for (n = t._next, i = r; i && i.pr > t.pr; ) i = i._next;
      (t._prev = i ? i._prev : o) ? (t._prev._next = t) : (r = t),
        (t._next = i) ? (i._prev = t) : (o = t),
        (t = n);
    }
    e._pt = r;
  },
  Fn = (function () {
    function s(t, n, i, r, o, a, l, c, h) {
      (this.t = n),
        (this.s = r),
        (this.c = o),
        (this.p = i),
        (this.r = a || s_),
        (this.d = l || this),
        (this.set = c || nf),
        (this.pr = h || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = s.prototype;
    return (
      (e.modifier = function (n, i, r) {
        (this.mSet = this.mSet || this.set),
          (this.set = jE),
          (this.m = n),
          (this.mt = r),
          (this.tween = i);
      }),
      s
    );
  })();
On(
  Ju +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (s) {
    return (Zu[s] = 1);
  }
);
Jn.TweenMax = Jn.TweenLite = Gt;
Jn.TimelineLite = Jn.TimelineMax = En;
Lt = new En({
  sortChildren: !1,
  defaults: mo,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
Zn.stringFilter = $m;
var rs = [],
  Al = {},
  KE = [],
  Qd = 0,
  $E = 0,
  Zc = function (e) {
    return (Al[e] || KE).map(function (t) {
      return t();
    });
  },
  lu = function () {
    var e = Date.now(),
      t = [];
    e - Qd > 2 &&
      (Zc("matchMediaInit"),
      rs.forEach(function (n) {
        var i = n.queries,
          r = n.conditions,
          o,
          a,
          l,
          c;
        for (a in i)
          (o = Ti.matchMedia(i[a]).matches),
            o && (l = 1),
            o !== r[a] && ((r[a] = o), (c = 1));
        c && (n.revert(), l && t.push(n));
      }),
      Zc("matchMediaRevert"),
      t.forEach(function (n) {
        return n.onMatch(n, function (i) {
          return n.add(null, i);
        });
      }),
      (Qd = e),
      Zc("matchMedia"));
  },
  l_ = (function () {
    function s(t, n) {
      (this.selector = n && su(n)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = $E++),
        t && this.add(t);
    }
    var e = s.prototype;
    return (
      (e.add = function (n, i, r) {
        Ot(n) && ((r = i), (i = n), (n = Ot));
        var o = this,
          a = function () {
            var c = Pt,
              h = o.selector,
              u;
            return (
              c && c !== o && c.data.push(o),
              r && (o.selector = su(r)),
              (Pt = o),
              (u = i.apply(o, arguments)),
              Ot(u) && o._r.push(u),
              (Pt = c),
              (o.selector = h),
              (o.isReverted = !1),
              u
            );
          };
        return (
          (o.last = a),
          n === Ot
            ? a(o, function (l) {
                return o.add(null, l);
              })
            : n
            ? (o[n] = a)
            : a
        );
      }),
      (e.ignore = function (n) {
        var i = Pt;
        (Pt = null), n(this), (Pt = i);
      }),
      (e.getTweens = function () {
        var n = [];
        return (
          this.data.forEach(function (i) {
            return i instanceof s
              ? n.push.apply(n, i.getTweens())
              : i instanceof Gt &&
                  !(i.parent && i.parent.data === "nested") &&
                  n.push(i);
          }),
          n
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (n, i) {
        var r = this;
        if (
          (n
            ? (function () {
                for (var a = r.getTweens(), l = r.data.length, c; l--; )
                  (c = r.data[l]),
                    c.data === "isFlip" &&
                      (c.revert(),
                      c.getChildren(!0, !0, !1).forEach(function (h) {
                        return a.splice(a.indexOf(h), 1);
                      }));
                for (
                  a
                    .map(function (h) {
                      return {
                        g:
                          h._dur ||
                          h._delay ||
                          (h._sat && !h._sat.vars.immediateRender)
                            ? h.globalTime(0)
                            : -1 / 0,
                        t: h,
                      };
                    })
                    .sort(function (h, u) {
                      return u.g - h.g || -1 / 0;
                    })
                    .forEach(function (h) {
                      return h.t.revert(n);
                    }),
                    l = r.data.length;
                  l--;

                )
                  (c = r.data[l]),
                    c instanceof En
                      ? c.data !== "nested" &&
                        (c.scrollTrigger && c.scrollTrigger.revert(), c.kill())
                      : !(c instanceof Gt) && c.revert && c.revert(n);
                r._r.forEach(function (h) {
                  return h(n, r);
                }),
                  (r.isReverted = !0);
              })()
            : this.data.forEach(function (a) {
                return a.kill && a.kill();
              }),
          this.clear(),
          i)
        )
          for (var o = rs.length; o--; )
            rs[o].id === this.id && rs.splice(o, 1);
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      s
    );
  })(),
  ZE = (function () {
    function s(t) {
      (this.contexts = []), (this.scope = t), Pt && Pt.data.push(this);
    }
    var e = s.prototype;
    return (
      (e.add = function (n, i, r) {
        Fi(n) || (n = { matches: n });
        var o = new l_(0, r || this.scope),
          a = (o.conditions = {}),
          l,
          c,
          h;
        Pt && !o.selector && (o.selector = Pt.selector),
          this.contexts.push(o),
          (i = o.add("onMatch", i)),
          (o.queries = n);
        for (c in n)
          c === "all"
            ? (h = 1)
            : ((l = Ti.matchMedia(n[c])),
              l &&
                (rs.indexOf(o) < 0 && rs.push(o),
                (a[c] = l.matches) && (h = 1),
                l.addListener
                  ? l.addListener(lu)
                  : l.addEventListener("change", lu)));
        return (
          h &&
            i(o, function (u) {
              return o.add(null, u);
            }),
          this
        );
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      (e.kill = function (n) {
        this.contexts.forEach(function (i) {
          return i.kill(n, !0);
        });
      }),
      s
    );
  })(),
  Gl = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      t.forEach(function (i) {
        return qm(i);
      });
    },
    timeline: function (e) {
      return new En(e);
    },
    getTweensOf: function (e, t) {
      return Lt.getTweensOf(e, t);
    },
    getProperty: function (e, t, n, i) {
      rn(e) && (e = ai(e)[0]);
      var r = ts(e || {}).get,
        o = n ? Um : Im;
      return (
        n === "native" && (n = ""),
        e &&
          (t
            ? o(((Yn[t] && Yn[t].get) || r)(e, t, n, i))
            : function (a, l, c) {
                return o(((Yn[a] && Yn[a].get) || r)(e, a, l, c));
              })
      );
    },
    quickSetter: function (e, t, n) {
      if (((e = ai(e)), e.length > 1)) {
        var i = e.map(function (h) {
            return kn.quickSetter(h, t, n);
          }),
          r = i.length;
        return function (h) {
          for (var u = r; u--; ) i[u](h);
        };
      }
      e = e[0] || {};
      var o = Yn[t],
        a = ts(e),
        l = (a.harness && (a.harness.aliases || {})[t]) || t,
        c = o
          ? function (h) {
              var u = new o();
              (Gs._pt = 0),
                u.init(e, n ? h + n : h, Gs, 0, [e]),
                u.render(1, u),
                Gs._pt && sf(1, Gs);
            }
          : a.set(e, l);
      return o
        ? c
        : function (h) {
            return c(e, l, n ? h + n : h, a, 1);
          };
    },
    quickTo: function (e, t, n) {
      var i,
        r = kn.to(
          e,
          hs(((i = {}), (i[t] = "+=0.1"), (i.paused = !0), i), n || {})
        ),
        o = function (l, c, h) {
          return r.resetTo(t, l, c, h);
        };
      return (o.tween = r), o;
    },
    isTweening: function (e) {
      return Lt.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = is(e.ease, mo.ease)), jd(mo, e || {});
    },
    config: function (e) {
      return jd(Zn, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        n = e.effect,
        i = e.plugins,
        r = e.defaults,
        o = e.extendTimeline;
      (i || "").split(",").forEach(function (a) {
        return (
          a && !Yn[a] && !Jn[a] && da(t + " effect requires " + a + " plugin.")
        );
      }),
        (qc[t] = function (a, l, c) {
          return n(ai(a), ci(l || {}, r), c);
        }),
        o &&
          (En.prototype[t] = function (a, l, c) {
            return this.add(qc[t](a, Fi(l) ? l : (c = l) && {}, this), c);
          });
    },
    registerEase: function (e, t) {
      lt[e] = is(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? is(e, t) : lt;
    },
    getById: function (e) {
      return Lt.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var n = new En(e),
        i,
        r;
      for (
        n.smoothChildTiming = Nn(e.smoothChildTiming),
          Lt.remove(n),
          n._dp = 0,
          n._time = n._tTime = Lt._time,
          i = Lt._first;
        i;

      )
        (r = i._next),
          (t ||
            !(
              !i._dur &&
              i instanceof Gt &&
              i.vars.onComplete === i._targets[0]
            )) &&
            wi(n, i, i._start - i._delay),
          (i = r);
      return wi(Lt, n, 0), n;
    },
    context: function (e, t) {
      return e ? new l_(e, t) : Pt;
    },
    matchMedia: function (e) {
      return new ZE(e);
    },
    matchMediaRefresh: function () {
      return (
        rs.forEach(function (e) {
          var t = e.conditions,
            n,
            i;
          for (i in t) t[i] && ((t[i] = !1), (n = 1));
          n && e.revert();
        }) || lu()
      );
    },
    addEventListener: function (e, t) {
      var n = Al[e] || (Al[e] = []);
      ~n.indexOf(t) || n.push(t);
    },
    removeEventListener: function (e, t) {
      var n = Al[e],
        i = n && n.indexOf(t);
      i >= 0 && n.splice(i, 1);
    },
    utils: {
      wrap: CE,
      wrapYoyo: PE,
      distribute: Hm,
      random: Gm,
      snap: Vm,
      normalize: RE,
      getUnit: un,
      clamp: EE,
      splitColor: jm,
      toArray: ai,
      selector: su,
      mapRange: Xm,
      pipe: AE,
      unitize: wE,
      interpolate: DE,
      shuffle: zm,
    },
    install: Rm,
    effects: qc,
    ticker: qn,
    updateRoot: En.updateRoot,
    plugins: Yn,
    globalTimeline: Lt,
    core: {
      PropTween: Fn,
      globals: Cm,
      Tween: Gt,
      Timeline: En,
      Animation: ga,
      getCache: ts,
      _removeLinkedListItem: ic,
      reverting: function () {
        return fn;
      },
      context: function (e) {
        return e && Pt && (Pt.data.push(e), (e._ctx = Pt)), Pt;
      },
      suppressOverwrites: function (e) {
        return (Yu = e);
      },
    },
  };
On("to,from,fromTo,delayedCall,set,killTweensOf", function (s) {
  return (Gl[s] = Gt[s]);
});
qn.add(En.updateRoot);
Gs = Gl.to({}, { duration: 0 });
var JE = function (e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
      n = n._next;
    return n;
  },
  QE = function (e, t) {
    var n = e._targets,
      i,
      r,
      o;
    for (i in t)
      for (r = n.length; r--; )
        (o = e._ptLookup[r][i]),
          o &&
            (o = o.d) &&
            (o._pt && (o = JE(o, i)),
            o && o.modifier && o.modifier(t[i], e, n[r], i));
  },
  Jc = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (i, r, o) {
        o._onInit = function (a) {
          var l, c;
          if (
            (rn(r) &&
              ((l = {}),
              On(r, function (h) {
                return (l[h] = 1);
              }),
              (r = l)),
            t)
          ) {
            l = {};
            for (c in r) l[c] = t(r[c]);
            r = l;
          }
          QE(a, r);
        };
      },
    };
  },
  kn =
    Gl.registerPlugin(
      {
        name: "attr",
        init: function (e, t, n, i, r) {
          var o, a, l;
          this.tween = n;
          for (o in t)
            (l = e.getAttribute(o) || ""),
              (a = this.add(
                e,
                "setAttribute",
                (l || 0) + "",
                t[o],
                i,
                r,
                0,
                0,
                o
              )),
              (a.op = o),
              (a.b = l),
              this._props.push(o);
        },
        render: function (e, t) {
          for (var n = t._pt; n; )
            fn ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
        },
      },
      {
        name: "endArray",
        init: function (e, t) {
          for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
        },
      },
      Jc("roundProps", ou),
      Jc("modifiers"),
      Jc("snap", Vm)
    ) || Gl;
Gt.version = En.version = kn.version = "3.12.5";
wm = 1;
ju() && vo();
lt.Power0;
lt.Power1;
lt.Power2;
lt.Power3;
lt.Power4;
lt.Linear;
lt.Quad;
lt.Cubic;
lt.Quart;
lt.Quint;
lt.Strong;
lt.Elastic;
lt.Back;
lt.SteppedEase;
lt.Bounce;
lt.Sine;
lt.Expo;
lt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var ep,
  br,
  Zs,
  of,
  Qr,
  tp,
  af,
  eb = function () {
    return typeof window < "u";
  },
  lr = {},
  qr = 180 / Math.PI,
  Js = Math.PI / 180,
  Ns = Math.atan2,
  np = 1e8,
  lf = /([A-Z])/g,
  tb = /(left|right|width|margin|padding|x)/i,
  nb = /[\s,\(]\S/,
  Pi = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  cu = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  ib = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  rb = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  sb = function (e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  c_ = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  h_ = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  ob = function (e, t, n) {
    return (e.style[t] = n);
  },
  ab = function (e, t, n) {
    return e.style.setProperty(t, n);
  },
  lb = function (e, t, n) {
    return (e._gsap[t] = n);
  },
  cb = function (e, t, n) {
    return (e._gsap.scaleX = e._gsap.scaleY = n);
  },
  hb = function (e, t, n, i, r) {
    var o = e._gsap;
    (o.scaleX = o.scaleY = n), o.renderTransform(r, o);
  },
  ub = function (e, t, n, i, r) {
    var o = e._gsap;
    (o[t] = n), o.renderTransform(r, o);
  },
  It = "transform",
  Bn = It + "Origin",
  fb = function s(e, t) {
    var n = this,
      i = this.target,
      r = i.style,
      o = i._gsap;
    if (e in lr && r) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = Pi[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (a) {
                return (n.tfm[a] = Zi(i, a));
              })
            : (this.tfm[e] = o.x ? o[e] : Zi(i, e)),
          e === Bn && (this.tfm.zOrigin = o.zOrigin);
      else
        return Pi.transform.split(",").forEach(function (a) {
          return s.call(n, a, t);
        });
      if (this.props.indexOf(It) >= 0) return;
      o.svg &&
        ((this.svgo = i.getAttribute("data-svg-origin")),
        this.props.push(Bn, t, "")),
        (e = It);
    }
    (r || t) && this.props.push(e, t, r[e]);
  },
  u_ = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  db = function () {
    var e = this.props,
      t = this.target,
      n = t.style,
      i = t._gsap,
      r,
      o;
    for (r = 0; r < e.length; r += 3)
      e[r + 1]
        ? (t[e[r]] = e[r + 2])
        : e[r + 2]
        ? (n[e[r]] = e[r + 2])
        : n.removeProperty(
            e[r].substr(0, 2) === "--"
              ? e[r]
              : e[r].replace(lf, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (o in this.tfm) i[o] = this.tfm[o];
      i.svg &&
        (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (r = af()),
        (!r || !r.isStart) &&
          !n[It] &&
          (u_(n),
          i.zOrigin &&
            n[Bn] &&
            ((n[Bn] += " " + i.zOrigin + "px"),
            (i.zOrigin = 0),
            i.renderTransform()),
          (i.uncache = 1));
    }
  },
  f_ = function (e, t) {
    var n = { target: e, props: [], revert: db, save: fb };
    return (
      e._gsap || kn.core.getCache(e),
      t &&
        t.split(",").forEach(function (i) {
          return n.save(i);
        }),
      n
    );
  },
  d_,
  hu = function (e, t) {
    var n = br.createElementNS
      ? br.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : br.createElement(e);
    return n && n.style ? n : br.createElement(e);
  },
  Ii = function s(e, t, n) {
    var i = getComputedStyle(e);
    return (
      i[t] ||
      i.getPropertyValue(t.replace(lf, "-$1").toLowerCase()) ||
      i.getPropertyValue(t) ||
      (!n && s(e, xo(t) || t, 1)) ||
      ""
    );
  },
  ip = "O,Moz,ms,Ms,Webkit".split(","),
  xo = function (e, t, n) {
    var i = t || Qr,
      r = i.style,
      o = 5;
    if (e in r && !n) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      o-- && !(ip[o] + e in r);

    );
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? ip[o] : "") + e;
  },
  uu = function () {
    eb() &&
      window.document &&
      ((ep = window),
      (br = ep.document),
      (Zs = br.documentElement),
      (Qr = hu("div") || { style: {} }),
      hu("div"),
      (It = xo(It)),
      (Bn = It + "Origin"),
      (Qr.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (d_ = !!xo("perspective")),
      (af = kn.core.reverting),
      (of = 1));
  },
  Qc = function s(e) {
    var t = hu(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      n = this.parentNode,
      i = this.nextSibling,
      r = this.style.cssText,
      o;
    if (
      (Zs.appendChild(t),
      t.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        (o = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = s);
      } catch {}
    else this._gsapBBox && (o = this._gsapBBox());
    return (
      n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
      Zs.removeChild(t),
      (this.style.cssText = r),
      o
    );
  },
  rp = function (e, t) {
    for (var n = t.length; n--; )
      if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
  },
  p_ = function (e) {
    var t;
    try {
      t = e.getBBox();
    } catch {
      t = Qc.call(e, !0);
    }
    return (
      (t && (t.width || t.height)) || e.getBBox === Qc || (t = Qc.call(e, !0)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +rp(e, ["x", "cx", "x1"]) || 0,
            y: +rp(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  m_ = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && p_(e));
  },
  us = function (e, t) {
    if (t) {
      var n = e.style,
        i;
      t in lr && t !== Bn && (t = It),
        n.removeProperty
          ? ((i = t.substr(0, 2)),
            (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
            n.removeProperty(
              i === "--" ? t : t.replace(lf, "-$1").toLowerCase()
            ))
          : n.removeAttribute(t);
    }
  },
  Ar = function (e, t, n, i, r, o) {
    var a = new Fn(e._pt, t, n, 0, 1, o ? h_ : c_);
    return (e._pt = a), (a.b = i), (a.e = r), e._props.push(n), a;
  },
  sp = { deg: 1, rad: 1, turn: 1 },
  pb = { grid: 1, flex: 1 },
  Ur = function s(e, t, n, i) {
    var r = parseFloat(n) || 0,
      o = (n + "").trim().substr((r + "").length) || "px",
      a = Qr.style,
      l = tb.test(t),
      c = e.tagName.toLowerCase() === "svg",
      h = (c ? "client" : "offset") + (l ? "Width" : "Height"),
      u = 100,
      f = i === "px",
      d = i === "%",
      _,
      g,
      m,
      p;
    if (i === o || !r || sp[i] || sp[o]) return r;
    if (
      (o !== "px" && !f && (r = s(e, t, n, "px")),
      (p = e.getCTM && m_(e)),
      (d || o === "%") && (lr[t] || ~t.indexOf("adius")))
    )
      return (
        (_ = p ? e.getBBox()[l ? "width" : "height"] : e[h]),
        Bt(d ? (r / _) * u : (r / 100) * _)
      );
    if (
      ((a[l ? "width" : "height"] = u + (f ? o : i)),
      (g =
        ~t.indexOf("adius") || (i === "em" && e.appendChild && !c)
          ? e
          : e.parentNode),
      p && (g = (e.ownerSVGElement || {}).parentNode),
      (!g || g === br || !g.appendChild) && (g = br.body),
      (m = g._gsap),
      m && d && m.width && l && m.time === qn.time && !m.uncache)
    )
      return Bt((r / m.width) * u);
    if (d && (t === "height" || t === "width")) {
      var M = e.style[t];
      (e.style[t] = u + i), (_ = e[h]), M ? (e.style[t] = M) : us(e, t);
    } else
      (d || o === "%") &&
        !pb[Ii(g, "display")] &&
        (a.position = Ii(e, "position")),
        g === e && (a.position = "static"),
        g.appendChild(Qr),
        (_ = Qr[h]),
        g.removeChild(Qr),
        (a.position = "absolute");
    return (
      l && d && ((m = ts(g)), (m.time = qn.time), (m.width = g[h])),
      Bt(f ? (_ * r) / u : _ && r ? (u / _) * r : 0)
    );
  },
  Zi = function (e, t, n, i) {
    var r;
    return (
      of || uu(),
      t in Pi &&
        t !== "transform" &&
        ((t = Pi[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      lr[t] && t !== "transform"
        ? ((r = xa(e, i)),
          (r =
            t !== "transformOrigin"
              ? r[t]
              : r.svg
              ? r.origin
              : Xl(Ii(e, Bn)) + " " + r.zOrigin + "px"))
        : ((r = e.style[t]),
          (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) &&
            (r =
              (Wl[t] && Wl[t](e, t, n)) ||
              Ii(e, t) ||
              Dm(e, t) ||
              (t === "opacity" ? 1 : 0))),
      n && !~(r + "").trim().indexOf(" ") ? Ur(e, t, r, n) + n : r
    );
  },
  mb = function (e, t, n, i) {
    if (!n || n === "none") {
      var r = xo(t, e, 1),
        o = r && Ii(e, r, 1);
      o && o !== n
        ? ((t = r), (n = o))
        : t === "borderColor" && (n = Ii(e, "borderTopColor"));
    }
    var a = new Fn(this._pt, e.style, t, 0, 1, o_),
      l = 0,
      c = 0,
      h,
      u,
      f,
      d,
      _,
      g,
      m,
      p,
      M,
      S,
      v,
      C;
    if (
      ((a.b = n),
      (a.e = i),
      (n += ""),
      (i += ""),
      i === "auto" &&
        ((g = e.style[t]),
        (e.style[t] = i),
        (i = Ii(e, t) || i),
        g ? (e.style[t] = g) : us(e, t)),
      (h = [n, i]),
      $m(h),
      (n = h[0]),
      (i = h[1]),
      (f = n.match(Vs) || []),
      (C = i.match(Vs) || []),
      C.length)
    ) {
      for (; (u = Vs.exec(i)); )
        (m = u[0]),
          (M = i.substring(l, u.index)),
          _
            ? (_ = (_ + 1) % 5)
            : (M.substr(-5) === "rgba(" || M.substr(-5) === "hsla(") && (_ = 1),
          m !== (g = f[c++] || "") &&
            ((d = parseFloat(g) || 0),
            (v = g.substr((d + "").length)),
            m.charAt(1) === "=" && (m = $s(d, m) + v),
            (p = parseFloat(m)),
            (S = m.substr((p + "").length)),
            (l = Vs.lastIndex - S.length),
            S ||
              ((S = S || Zn.units[t] || v),
              l === i.length && ((i += S), (a.e += S))),
            v !== S && (d = Ur(e, t, g, S) || 0),
            (a._pt = {
              _next: a._pt,
              p: M || c === 1 ? M : ",",
              s: d,
              c: p - d,
              m: (_ && _ < 4) || t === "zIndex" ? Math.round : 0,
            }));
      a.c = l < i.length ? i.substring(l, i.length) : "";
    } else a.r = t === "display" && i === "none" ? h_ : c_;
    return bm.test(i) && (a.e = 0), (this._pt = a), a;
  },
  op = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  _b = function (e) {
    var t = e.split(" "),
      n = t[0],
      i = t[1] || "50%";
    return (
      (n === "top" || n === "bottom" || i === "left" || i === "right") &&
        ((e = n), (n = i), (i = e)),
      (t[0] = op[n] || n),
      (t[1] = op[i] || i),
      t.join(" ")
    );
  },
  gb = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var n = t.t,
        i = n.style,
        r = t.u,
        o = n._gsap,
        a,
        l,
        c;
      if (r === "all" || r === !0) (i.cssText = ""), (l = 1);
      else
        for (r = r.split(","), c = r.length; --c > -1; )
          (a = r[c]),
            lr[a] && ((l = 1), (a = a === "transformOrigin" ? Bn : It)),
            us(n, a);
      l &&
        (us(n, It),
        o &&
          (o.svg && n.removeAttribute("transform"),
          xa(n, 1),
          (o.uncache = 1),
          u_(i)));
    }
  },
  Wl = {
    clearProps: function (e, t, n, i, r) {
      if (r.data !== "isFromStart") {
        var o = (e._pt = new Fn(e._pt, t, n, 0, 0, gb));
        return (o.u = i), (o.pr = -10), (o.tween = r), e._props.push(n), 1;
      }
    },
  },
  va = [1, 0, 0, 1, 0, 0],
  __ = {},
  g_ = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  ap = function (e) {
    var t = Ii(e, It);
    return g_(t) ? va : t.substr(7).match(Em).map(Bt);
  },
  cf = function (e, t) {
    var n = e._gsap || ts(e),
      i = e.style,
      r = ap(e),
      o,
      a,
      l,
      c;
    return n.svg && e.getAttribute("transform")
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (r = [l.a, l.b, l.c, l.d, l.e, l.f]),
        r.join(",") === "1,0,0,1,0,0" ? va : r)
      : (r === va &&
          !e.offsetParent &&
          e !== Zs &&
          !n.svg &&
          ((l = i.display),
          (i.display = "block"),
          (o = e.parentNode),
          (!o || !e.offsetParent) &&
            ((c = 1), (a = e.nextElementSibling), Zs.appendChild(e)),
          (r = ap(e)),
          l ? (i.display = l) : us(e, "display"),
          c &&
            (a
              ? o.insertBefore(e, a)
              : o
              ? o.appendChild(e)
              : Zs.removeChild(e))),
        t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
  },
  fu = function (e, t, n, i, r, o) {
    var a = e._gsap,
      l = r || cf(e, !0),
      c = a.xOrigin || 0,
      h = a.yOrigin || 0,
      u = a.xOffset || 0,
      f = a.yOffset || 0,
      d = l[0],
      _ = l[1],
      g = l[2],
      m = l[3],
      p = l[4],
      M = l[5],
      S = t.split(" "),
      v = parseFloat(S[0]) || 0,
      C = parseFloat(S[1]) || 0,
      w,
      E,
      A,
      y;
    n
      ? l !== va &&
        (E = d * m - _ * g) &&
        ((A = v * (m / E) + C * (-g / E) + (g * M - m * p) / E),
        (y = v * (-_ / E) + C * (d / E) - (d * M - _ * p) / E),
        (v = A),
        (C = y))
      : ((w = p_(e)),
        (v = w.x + (~S[0].indexOf("%") ? (v / 100) * w.width : v)),
        (C = w.y + (~(S[1] || S[0]).indexOf("%") ? (C / 100) * w.height : C))),
      i || (i !== !1 && a.smooth)
        ? ((p = v - c),
          (M = C - h),
          (a.xOffset = u + (p * d + M * g) - p),
          (a.yOffset = f + (p * _ + M * m) - M))
        : (a.xOffset = a.yOffset = 0),
      (a.xOrigin = v),
      (a.yOrigin = C),
      (a.smooth = !!i),
      (a.origin = t),
      (a.originIsAbsolute = !!n),
      (e.style[Bn] = "0px 0px"),
      o &&
        (Ar(o, a, "xOrigin", c, v),
        Ar(o, a, "yOrigin", h, C),
        Ar(o, a, "xOffset", u, a.xOffset),
        Ar(o, a, "yOffset", f, a.yOffset)),
      e.setAttribute("data-svg-origin", v + " " + C);
  },
  xa = function (e, t) {
    var n = e._gsap || new e_(e);
    if ("x" in n && !t && !n.uncache) return n;
    var i = e.style,
      r = n.scaleX < 0,
      o = "px",
      a = "deg",
      l = getComputedStyle(e),
      c = Ii(e, Bn) || "0",
      h,
      u,
      f,
      d,
      _,
      g,
      m,
      p,
      M,
      S,
      v,
      C,
      w,
      E,
      A,
      y,
      x,
      P,
      I,
      O,
      k,
      G,
      z,
      q,
      H,
      ee,
      D,
      oe,
      Me,
      Ue,
      K,
      te;
    return (
      (h = u = f = g = m = p = M = S = v = 0),
      (d = _ = 1),
      (n.svg = !!(e.getCTM && m_(e))),
      l.translate &&
        ((l.translate !== "none" ||
          l.scale !== "none" ||
          l.rotate !== "none") &&
          (i[It] =
            (l.translate !== "none"
              ? "translate3d(" +
                (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
            (l.scale !== "none"
              ? "scale(" + l.scale.split(" ").join(",") + ") "
              : "") +
            (l[It] !== "none" ? l[It] : "")),
        (i.scale = i.rotate = i.translate = "none")),
      (E = cf(e, n.svg)),
      n.svg &&
        (n.uncache
          ? ((H = e.getBBox()),
            (c = n.xOrigin - H.x + "px " + (n.yOrigin - H.y) + "px"),
            (q = ""))
          : (q = !t && e.getAttribute("data-svg-origin")),
        fu(e, q || c, !!q || n.originIsAbsolute, n.smooth !== !1, E)),
      (C = n.xOrigin || 0),
      (w = n.yOrigin || 0),
      E !== va &&
        ((P = E[0]),
        (I = E[1]),
        (O = E[2]),
        (k = E[3]),
        (h = G = E[4]),
        (u = z = E[5]),
        E.length === 6
          ? ((d = Math.sqrt(P * P + I * I)),
            (_ = Math.sqrt(k * k + O * O)),
            (g = P || I ? Ns(I, P) * qr : 0),
            (M = O || k ? Ns(O, k) * qr + g : 0),
            M && (_ *= Math.abs(Math.cos(M * Js))),
            n.svg && ((h -= C - (C * P + w * O)), (u -= w - (C * I + w * k))))
          : ((te = E[6]),
            (Ue = E[7]),
            (D = E[8]),
            (oe = E[9]),
            (Me = E[10]),
            (K = E[11]),
            (h = E[12]),
            (u = E[13]),
            (f = E[14]),
            (A = Ns(te, Me)),
            (m = A * qr),
            A &&
              ((y = Math.cos(-A)),
              (x = Math.sin(-A)),
              (q = G * y + D * x),
              (H = z * y + oe * x),
              (ee = te * y + Me * x),
              (D = G * -x + D * y),
              (oe = z * -x + oe * y),
              (Me = te * -x + Me * y),
              (K = Ue * -x + K * y),
              (G = q),
              (z = H),
              (te = ee)),
            (A = Ns(-O, Me)),
            (p = A * qr),
            A &&
              ((y = Math.cos(-A)),
              (x = Math.sin(-A)),
              (q = P * y - D * x),
              (H = I * y - oe * x),
              (ee = O * y - Me * x),
              (K = k * x + K * y),
              (P = q),
              (I = H),
              (O = ee)),
            (A = Ns(I, P)),
            (g = A * qr),
            A &&
              ((y = Math.cos(A)),
              (x = Math.sin(A)),
              (q = P * y + I * x),
              (H = G * y + z * x),
              (I = I * y - P * x),
              (z = z * y - G * x),
              (P = q),
              (G = H)),
            m &&
              Math.abs(m) + Math.abs(g) > 359.9 &&
              ((m = g = 0), (p = 180 - p)),
            (d = Bt(Math.sqrt(P * P + I * I + O * O))),
            (_ = Bt(Math.sqrt(z * z + te * te))),
            (A = Ns(G, z)),
            (M = Math.abs(A) > 2e-4 ? A * qr : 0),
            (v = K ? 1 / (K < 0 ? -K : K) : 0)),
        n.svg &&
          ((q = e.getAttribute("transform")),
          (n.forceCSS = e.setAttribute("transform", "") || !g_(Ii(e, It))),
          q && e.setAttribute("transform", q))),
      Math.abs(M) > 90 &&
        Math.abs(M) < 270 &&
        (r
          ? ((d *= -1), (M += g <= 0 ? 180 : -180), (g += g <= 0 ? 180 : -180))
          : ((_ *= -1), (M += M <= 0 ? 180 : -180))),
      (t = t || n.uncache),
      (n.x =
        h -
        ((n.xPercent =
          h &&
          ((!t && n.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0)))
          ? (e.offsetWidth * n.xPercent) / 100
          : 0) +
        o),
      (n.y =
        u -
        ((n.yPercent =
          u &&
          ((!t && n.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0)))
          ? (e.offsetHeight * n.yPercent) / 100
          : 0) +
        o),
      (n.z = f + o),
      (n.scaleX = Bt(d)),
      (n.scaleY = Bt(_)),
      (n.rotation = Bt(g) + a),
      (n.rotationX = Bt(m) + a),
      (n.rotationY = Bt(p) + a),
      (n.skewX = M + a),
      (n.skewY = S + a),
      (n.transformPerspective = v + o),
      (n.zOrigin = parseFloat(c.split(" ")[2]) || (!t && n.zOrigin) || 0) &&
        (i[Bn] = Xl(c)),
      (n.xOffset = n.yOffset = 0),
      (n.force3D = Zn.force3D),
      (n.renderTransform = n.svg ? xb : d_ ? v_ : vb),
      (n.uncache = 0),
      n
    );
  },
  Xl = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  eh = function (e, t, n) {
    var i = un(t);
    return Bt(parseFloat(t) + parseFloat(Ur(e, "x", n + "px", i))) + i;
  },
  vb = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      v_(e, t);
  },
  Wr = "0deg",
  No = "0px",
  Xr = ") ",
  v_ = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      r = n.yPercent,
      o = n.x,
      a = n.y,
      l = n.z,
      c = n.rotation,
      h = n.rotationY,
      u = n.rotationX,
      f = n.skewX,
      d = n.skewY,
      _ = n.scaleX,
      g = n.scaleY,
      m = n.transformPerspective,
      p = n.force3D,
      M = n.target,
      S = n.zOrigin,
      v = "",
      C = (p === "auto" && e && e !== 1) || p === !0;
    if (S && (u !== Wr || h !== Wr)) {
      var w = parseFloat(h) * Js,
        E = Math.sin(w),
        A = Math.cos(w),
        y;
      (w = parseFloat(u) * Js),
        (y = Math.cos(w)),
        (o = eh(M, o, E * y * -S)),
        (a = eh(M, a, -Math.sin(w) * -S)),
        (l = eh(M, l, A * y * -S + S));
    }
    m !== No && (v += "perspective(" + m + Xr),
      (i || r) && (v += "translate(" + i + "%, " + r + "%) "),
      (C || o !== No || a !== No || l !== No) &&
        (v +=
          l !== No || C
            ? "translate3d(" + o + ", " + a + ", " + l + ") "
            : "translate(" + o + ", " + a + Xr),
      c !== Wr && (v += "rotate(" + c + Xr),
      h !== Wr && (v += "rotateY(" + h + Xr),
      u !== Wr && (v += "rotateX(" + u + Xr),
      (f !== Wr || d !== Wr) && (v += "skew(" + f + ", " + d + Xr),
      (_ !== 1 || g !== 1) && (v += "scale(" + _ + ", " + g + Xr),
      (M.style[It] = v || "translate(0, 0)");
  },
  xb = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      r = n.yPercent,
      o = n.x,
      a = n.y,
      l = n.rotation,
      c = n.skewX,
      h = n.skewY,
      u = n.scaleX,
      f = n.scaleY,
      d = n.target,
      _ = n.xOrigin,
      g = n.yOrigin,
      m = n.xOffset,
      p = n.yOffset,
      M = n.forceCSS,
      S = parseFloat(o),
      v = parseFloat(a),
      C,
      w,
      E,
      A,
      y;
    (l = parseFloat(l)),
      (c = parseFloat(c)),
      (h = parseFloat(h)),
      h && ((h = parseFloat(h)), (c += h), (l += h)),
      l || c
        ? ((l *= Js),
          (c *= Js),
          (C = Math.cos(l) * u),
          (w = Math.sin(l) * u),
          (E = Math.sin(l - c) * -f),
          (A = Math.cos(l - c) * f),
          c &&
            ((h *= Js),
            (y = Math.tan(c - h)),
            (y = Math.sqrt(1 + y * y)),
            (E *= y),
            (A *= y),
            h &&
              ((y = Math.tan(h)),
              (y = Math.sqrt(1 + y * y)),
              (C *= y),
              (w *= y))),
          (C = Bt(C)),
          (w = Bt(w)),
          (E = Bt(E)),
          (A = Bt(A)))
        : ((C = u), (A = f), (w = E = 0)),
      ((S && !~(o + "").indexOf("px")) || (v && !~(a + "").indexOf("px"))) &&
        ((S = Ur(d, "x", o, "px")), (v = Ur(d, "y", a, "px"))),
      (_ || g || m || p) &&
        ((S = Bt(S + _ - (_ * C + g * E) + m)),
        (v = Bt(v + g - (_ * w + g * A) + p))),
      (i || r) &&
        ((y = d.getBBox()),
        (S = Bt(S + (i / 100) * y.width)),
        (v = Bt(v + (r / 100) * y.height))),
      (y =
        "matrix(" + C + "," + w + "," + E + "," + A + "," + S + "," + v + ")"),
      d.setAttribute("transform", y),
      M && (d.style[It] = y);
  },
  yb = function (e, t, n, i, r) {
    var o = 360,
      a = rn(r),
      l = parseFloat(r) * (a && ~r.indexOf("rad") ? qr : 1),
      c = l - i,
      h = i + c + "deg",
      u,
      f;
    return (
      a &&
        ((u = r.split("_")[1]),
        u === "short" && ((c %= o), c !== c % (o / 2) && (c += c < 0 ? o : -o)),
        u === "cw" && c < 0
          ? (c = ((c + o * np) % o) - ~~(c / o) * o)
          : u === "ccw" && c > 0 && (c = ((c - o * np) % o) - ~~(c / o) * o)),
      (e._pt = f = new Fn(e._pt, t, n, i, c, ib)),
      (f.e = h),
      (f.u = "deg"),
      e._props.push(n),
      f
    );
  },
  lp = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  Mb = function (e, t, n) {
    var i = lp({}, n._gsap),
      r = "perspective,force3D,transformOrigin,svgOrigin",
      o = n.style,
      a,
      l,
      c,
      h,
      u,
      f,
      d,
      _;
    i.svg
      ? ((c = n.getAttribute("transform")),
        n.setAttribute("transform", ""),
        (o[It] = t),
        (a = xa(n, 1)),
        us(n, It),
        n.setAttribute("transform", c))
      : ((c = getComputedStyle(n)[It]),
        (o[It] = t),
        (a = xa(n, 1)),
        (o[It] = c));
    for (l in lr)
      (c = i[l]),
        (h = a[l]),
        c !== h &&
          r.indexOf(l) < 0 &&
          ((d = un(c)),
          (_ = un(h)),
          (u = d !== _ ? Ur(n, l, c, _) : parseFloat(c)),
          (f = parseFloat(h)),
          (e._pt = new Fn(e._pt, a, l, u, f - u, cu)),
          (e._pt.u = _ || 0),
          e._props.push(l));
    lp(a, i);
  };
On("padding,margin,Width,Radius", function (s, e) {
  var t = "Top",
    n = "Right",
    i = "Bottom",
    r = "Left",
    o = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function (a) {
      return e < 2 ? s + a : "border" + a + s;
    });
  Wl[e > 1 ? "border" + s : s] = function (a, l, c, h, u) {
    var f, d;
    if (arguments.length < 4)
      return (
        (f = o.map(function (_) {
          return Zi(a, _, c);
        })),
        (d = f.join(" ")),
        d.split(f[0]).length === 5 ? f[0] : d
      );
    (f = (h + "").split(" ")),
      (d = {}),
      o.forEach(function (_, g) {
        return (d[_] = f[g] = f[g] || f[((g - 1) / 2) | 0]);
      }),
      a.init(l, d, u);
  };
});
var x_ = {
  name: "css",
  register: uu,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, n, i, r) {
    var o = this._props,
      a = e.style,
      l = n.vars.startAt,
      c,
      h,
      u,
      f,
      d,
      _,
      g,
      m,
      p,
      M,
      S,
      v,
      C,
      w,
      E,
      A;
    of || uu(),
      (this.styles = this.styles || f_(e)),
      (A = this.styles.props),
      (this.tween = n);
    for (g in t)
      if (g !== "autoRound" && ((h = t[g]), !(Yn[g] && t_(g, t, n, i, e, r)))) {
        if (
          ((d = typeof h),
          (_ = Wl[g]),
          d === "function" && ((h = h.call(n, i, e, r)), (d = typeof h)),
          d === "string" && ~h.indexOf("random(") && (h = ma(h)),
          _)
        )
          _(this, e, g, h, n) && (E = 1);
        else if (g.substr(0, 2) === "--")
          (c = (getComputedStyle(e).getPropertyValue(g) + "").trim()),
            (h += ""),
            (Dr.lastIndex = 0),
            Dr.test(c) || ((m = un(c)), (p = un(h))),
            p ? m !== p && (c = Ur(e, g, c, p) + p) : m && (h += m),
            this.add(a, "setProperty", c, h, i, r, 0, 0, g),
            o.push(g),
            A.push(g, 0, a[g]);
        else if (d !== "undefined") {
          if (
            (l && g in l
              ? ((c = typeof l[g] == "function" ? l[g].call(n, i, e, r) : l[g]),
                rn(c) && ~c.indexOf("random(") && (c = ma(c)),
                un(c + "") ||
                  c === "auto" ||
                  (c += Zn.units[g] || un(Zi(e, g)) || ""),
                (c + "").charAt(1) === "=" && (c = Zi(e, g)))
              : (c = Zi(e, g)),
            (f = parseFloat(c)),
            (M = d === "string" && h.charAt(1) === "=" && h.substr(0, 2)),
            M && (h = h.substr(2)),
            (u = parseFloat(h)),
            g in Pi &&
              (g === "autoAlpha" &&
                (f === 1 && Zi(e, "visibility") === "hidden" && u && (f = 0),
                A.push("visibility", 0, a.visibility),
                Ar(
                  this,
                  a,
                  "visibility",
                  f ? "inherit" : "hidden",
                  u ? "inherit" : "hidden",
                  !u
                )),
              g !== "scale" &&
                g !== "transform" &&
                ((g = Pi[g]), ~g.indexOf(",") && (g = g.split(",")[0]))),
            (S = g in lr),
            S)
          ) {
            if (
              (this.styles.save(g),
              v ||
                ((C = e._gsap),
                (C.renderTransform && !t.parseTransform) ||
                  xa(e, t.parseTransform),
                (w = t.smoothOrigin !== !1 && C.smooth),
                (v = this._pt =
                  new Fn(this._pt, a, It, 0, 1, C.renderTransform, C, 0, -1)),
                (v.dep = 1)),
              g === "scale")
            )
              (this._pt = new Fn(
                this._pt,
                C,
                "scaleY",
                C.scaleY,
                (M ? $s(C.scaleY, M + u) : u) - C.scaleY || 0,
                cu
              )),
                (this._pt.u = 0),
                o.push("scaleY", g),
                (g += "X");
            else if (g === "transformOrigin") {
              A.push(Bn, 0, a[Bn]),
                (h = _b(h)),
                C.svg
                  ? fu(e, h, 0, w, 0, this)
                  : ((p = parseFloat(h.split(" ")[2]) || 0),
                    p !== C.zOrigin && Ar(this, C, "zOrigin", C.zOrigin, p),
                    Ar(this, a, g, Xl(c), Xl(h)));
              continue;
            } else if (g === "svgOrigin") {
              fu(e, h, 1, w, 0, this);
              continue;
            } else if (g in __) {
              yb(this, C, g, f, M ? $s(f, M + h) : h);
              continue;
            } else if (g === "smoothOrigin") {
              Ar(this, C, "smooth", C.smooth, h);
              continue;
            } else if (g === "force3D") {
              C[g] = h;
              continue;
            } else if (g === "transform") {
              Mb(this, h, e);
              continue;
            }
          } else g in a || (g = xo(g) || g);
          if (S || ((u || u === 0) && (f || f === 0) && !nb.test(h) && g in a))
            (m = (c + "").substr((f + "").length)),
              u || (u = 0),
              (p = un(h) || (g in Zn.units ? Zn.units[g] : m)),
              m !== p && (f = Ur(e, g, c, p)),
              (this._pt = new Fn(
                this._pt,
                S ? C : a,
                g,
                f,
                (M ? $s(f, M + u) : u) - f,
                !S && (p === "px" || g === "zIndex") && t.autoRound !== !1
                  ? sb
                  : cu
              )),
              (this._pt.u = p || 0),
              m !== p && p !== "%" && ((this._pt.b = c), (this._pt.r = rb));
          else if (g in a) mb.call(this, e, g, c, M ? M + h : h);
          else if (g in e) this.add(e, g, c || e[g], M ? M + h : h, i, r);
          else if (g !== "parseTransform") {
            $u(g, h);
            continue;
          }
          S || (g in a ? A.push(g, 0, a[g]) : A.push(g, 1, c || e[g])),
            o.push(g);
        }
      }
    E && a_(this);
  },
  render: function (e, t) {
    if (t.tween._time || !af())
      for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
    else t.styles.revert();
  },
  get: Zi,
  aliases: Pi,
  getSetter: function (e, t, n) {
    var i = Pi[t];
    return (
      i && i.indexOf(",") < 0 && (t = i),
      t in lr && t !== Bn && (e._gsap.x || Zi(e, "x"))
        ? n && tp === n
          ? t === "scale"
            ? cb
            : lb
          : (tp = n || {}) && (t === "scale" ? hb : ub)
        : e.style && !qu(e.style[t])
        ? ob
        : ~t.indexOf("-")
        ? ab
        : rf(e, t)
    );
  },
  core: { _removeProperty: us, _getMatrix: cf },
};
kn.utils.checkPrefix = xo;
kn.core.getStyleSaver = f_;
(function (s, e, t, n) {
  var i = On(s + "," + e + "," + t, function (r) {
    lr[r] = 1;
  });
  On(e, function (r) {
    (Zn.units[r] = "deg"), (__[r] = 1);
  }),
    (Pi[i[13]] = s + "," + e),
    On(n, function (r) {
      var o = r.split(":");
      Pi[o[1]] = i[o[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
On(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (s) {
    Zn.units[s] = "px";
  }
);
kn.registerPlugin(x_);
var ss = kn.registerPlugin(x_) || kn;
ss.core.Tween;
function y_(s, e, t) {
  return Math.max(s, Math.min(e, t));
}
class Sb {
  constructor() {
    (this.isRunning = !1),
      (this.value = 0),
      (this.from = 0),
      (this.to = 0),
      (this.duration = 0),
      (this.currentTime = 0);
  }
  advance(e) {
    var t;
    if (!this.isRunning) return;
    let n = !1;
    if (this.duration && this.easing) {
      this.currentTime += e;
      const i = y_(0, this.currentTime / this.duration, 1);
      n = i >= 1;
      const r = n ? 1 : this.easing(i);
      this.value = this.from + (this.to - this.from) * r;
    } else
      this.lerp
        ? ((this.value = (function (r, o, a, l) {
            return (function (h, u, f) {
              return (1 - f) * h + f * u;
            })(r, o, 1 - Math.exp(-a * l));
          })(this.value, this.to, 60 * this.lerp, e)),
          Math.round(this.value) === this.to &&
            ((this.value = this.to), (n = !0)))
        : ((this.value = this.to), (n = !0));
    n && this.stop(),
      (t = this.onUpdate) === null ||
        t === void 0 ||
        t.call(this, this.value, n);
  }
  stop() {
    this.isRunning = !1;
  }
  fromTo(e, t, { lerp: n, duration: i, easing: r, onStart: o, onUpdate: a }) {
    (this.from = this.value = e),
      (this.to = t),
      (this.lerp = n),
      (this.duration = i),
      (this.easing = r),
      (this.currentTime = 0),
      (this.isRunning = !0),
      o == null || o(),
      (this.onUpdate = a);
  }
}
class Tb {
  constructor({
    wrapper: e,
    content: t,
    autoResize: n = !0,
    debounce: i = 250,
  } = {}) {
    (this.width = 0),
      (this.height = 0),
      (this.scrollWidth = 0),
      (this.scrollHeight = 0),
      (this.resize = () => {
        this.onWrapperResize(), this.onContentResize();
      }),
      (this.onWrapperResize = () => {
        this.wrapper === window
          ? ((this.width = window.innerWidth),
            (this.height = window.innerHeight))
          : this.wrapper instanceof HTMLElement &&
            ((this.width = this.wrapper.clientWidth),
            (this.height = this.wrapper.clientHeight));
      }),
      (this.onContentResize = () => {
        this.wrapper === window
          ? ((this.scrollHeight = this.content.scrollHeight),
            (this.scrollWidth = this.content.scrollWidth))
          : this.wrapper instanceof HTMLElement &&
            ((this.scrollHeight = this.wrapper.scrollHeight),
            (this.scrollWidth = this.wrapper.scrollWidth));
      }),
      (this.wrapper = e),
      (this.content = t),
      n &&
        ((this.debouncedResize = (function (o, a) {
          let l;
          return function () {
            let c = arguments,
              h = this;
            clearTimeout(l),
              (l = setTimeout(function () {
                o.apply(h, c);
              }, a));
          };
        })(this.resize, i)),
        this.wrapper === window
          ? window.addEventListener("resize", this.debouncedResize, !1)
          : ((this.wrapperResizeObserver = new ResizeObserver(
              this.debouncedResize
            )),
            this.wrapperResizeObserver.observe(this.wrapper)),
        (this.contentResizeObserver = new ResizeObserver(this.debouncedResize)),
        this.contentResizeObserver.observe(this.content)),
      this.resize();
  }
  destroy() {
    var e, t;
    (e = this.wrapperResizeObserver) === null || e === void 0 || e.disconnect(),
      (t = this.contentResizeObserver) === null ||
        t === void 0 ||
        t.disconnect(),
      window.removeEventListener("resize", this.debouncedResize, !1);
  }
  get limit() {
    return {
      x: this.scrollWidth - this.width,
      y: this.scrollHeight - this.height,
    };
  }
}
class M_ {
  constructor() {
    this.events = {};
  }
  emit(e, ...t) {
    let n = this.events[e] || [];
    for (let i = 0, r = n.length; i < r; i++) n[i](...t);
  }
  on(e, t) {
    var n;
    return (
      (!((n = this.events[e]) === null || n === void 0) && n.push(t)) ||
        (this.events[e] = [t]),
      () => {
        var i;
        this.events[e] =
          (i = this.events[e]) === null || i === void 0
            ? void 0
            : i.filter((r) => t !== r);
      }
    );
  }
  off(e, t) {
    var n;
    this.events[e] =
      (n = this.events[e]) === null || n === void 0
        ? void 0
        : n.filter((i) => t !== i);
  }
  destroy() {
    this.events = {};
  }
}
const cp = 100 / 6;
class Eb {
  constructor(e, { wheelMultiplier: t = 1, touchMultiplier: n = 1 }) {
    (this.lastDelta = { x: 0, y: 0 }),
      (this.windowWidth = 0),
      (this.windowHeight = 0),
      (this.onTouchStart = (i) => {
        const { clientX: r, clientY: o } = i.targetTouches
          ? i.targetTouches[0]
          : i;
        (this.touchStart.x = r),
          (this.touchStart.y = o),
          (this.lastDelta = { x: 0, y: 0 }),
          this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: i });
      }),
      (this.onTouchMove = (i) => {
        var r, o, a, l;
        const { clientX: c, clientY: h } = i.targetTouches
            ? i.targetTouches[0]
            : i,
          u =
            -(
              c -
              ((o =
                (r = this.touchStart) === null || r === void 0
                  ? void 0
                  : r.x) !== null && o !== void 0
                ? o
                : 0)
            ) * this.touchMultiplier,
          f =
            -(
              h -
              ((l =
                (a = this.touchStart) === null || a === void 0
                  ? void 0
                  : a.y) !== null && l !== void 0
                ? l
                : 0)
            ) * this.touchMultiplier;
        (this.touchStart.x = c),
          (this.touchStart.y = h),
          (this.lastDelta = { x: u, y: f }),
          this.emitter.emit("scroll", { deltaX: u, deltaY: f, event: i });
      }),
      (this.onTouchEnd = (i) => {
        this.emitter.emit("scroll", {
          deltaX: this.lastDelta.x,
          deltaY: this.lastDelta.y,
          event: i,
        });
      }),
      (this.onWheel = (i) => {
        let { deltaX: r, deltaY: o, deltaMode: a } = i;
        (r *= a === 1 ? cp : a === 2 ? this.windowWidth : 1),
          (o *= a === 1 ? cp : a === 2 ? this.windowHeight : 1),
          (r *= this.wheelMultiplier),
          (o *= this.wheelMultiplier),
          this.emitter.emit("scroll", { deltaX: r, deltaY: o, event: i });
      }),
      (this.onWindowResize = () => {
        (this.windowWidth = window.innerWidth),
          (this.windowHeight = window.innerHeight);
      }),
      (this.element = e),
      (this.wheelMultiplier = t),
      (this.touchMultiplier = n),
      (this.touchStart = { x: null, y: null }),
      (this.emitter = new M_()),
      window.addEventListener("resize", this.onWindowResize, !1),
      this.onWindowResize(),
      this.element.addEventListener("wheel", this.onWheel, { passive: !1 }),
      this.element.addEventListener("touchstart", this.onTouchStart, {
        passive: !1,
      }),
      this.element.addEventListener("touchmove", this.onTouchMove, {
        passive: !1,
      }),
      this.element.addEventListener("touchend", this.onTouchEnd, {
        passive: !1,
      });
  }
  on(e, t) {
    return this.emitter.on(e, t);
  }
  destroy() {
    this.emitter.destroy(),
      window.removeEventListener("resize", this.onWindowResize, !1),
      this.element.removeEventListener("wheel", this.onWheel),
      this.element.removeEventListener("touchstart", this.onTouchStart),
      this.element.removeEventListener("touchmove", this.onTouchMove),
      this.element.removeEventListener("touchend", this.onTouchEnd);
  }
}
class bb {
  constructor({
    wrapper: e = window,
    content: t = document.documentElement,
    wheelEventsTarget: n = e,
    eventsTarget: i = n,
    smoothWheel: r = !0,
    syncTouch: o = !1,
    syncTouchLerp: a = 0.075,
    touchInertiaMultiplier: l = 35,
    duration: c,
    easing: h = (C) => Math.min(1, 1.001 - Math.pow(2, -10 * C)),
    lerp: u = 0.1,
    infinite: f = !1,
    orientation: d = "vertical",
    gestureOrientation: _ = "vertical",
    touchMultiplier: g = 1,
    wheelMultiplier: m = 1,
    autoResize: p = !0,
    prevent: M,
    virtualScroll: S,
    __experimental__naiveDimensions: v = !1,
  } = {}) {
    (this.__isScrolling = !1),
      (this.__isStopped = !1),
      (this.__isLocked = !1),
      (this.userData = {}),
      (this.lastVelocity = 0),
      (this.velocity = 0),
      (this.direction = 0),
      (this.onPointerDown = (C) => {
        C.button === 1 && this.reset();
      }),
      (this.onVirtualScroll = (C) => {
        if (
          typeof this.options.virtualScroll == "function" &&
          this.options.virtualScroll(C) === !1
        )
          return;
        const { deltaX: w, deltaY: E, event: A } = C;
        if (
          (this.emitter.emit("virtual-scroll", {
            deltaX: w,
            deltaY: E,
            event: A,
          }),
          A.ctrlKey)
        )
          return;
        const y = A.type.includes("touch"),
          x = A.type.includes("wheel");
        if (
          ((this.isTouching =
            A.type === "touchstart" || A.type === "touchmove"),
          this.options.syncTouch &&
            y &&
            A.type === "touchstart" &&
            !this.isStopped &&
            !this.isLocked)
        )
          return void this.reset();
        const P = w === 0 && E === 0,
          I =
            (this.options.gestureOrientation === "vertical" && E === 0) ||
            (this.options.gestureOrientation === "horizontal" && w === 0);
        if (P || I) return;
        let O = A.composedPath();
        O = O.slice(0, O.indexOf(this.rootElement));
        const k = this.options.prevent;
        if (
          O.find((H) => {
            var ee, D, oe, Me, Ue;
            return (
              H instanceof Element &&
              ((typeof k == "function" && (k == null ? void 0 : k(H))) ||
                ((ee = H.hasAttribute) === null || ee === void 0
                  ? void 0
                  : ee.call(H, "data-lenis-prevent")) ||
                (y &&
                  ((D = H.hasAttribute) === null || D === void 0
                    ? void 0
                    : D.call(H, "data-lenis-prevent-touch"))) ||
                (x &&
                  ((oe = H.hasAttribute) === null || oe === void 0
                    ? void 0
                    : oe.call(H, "data-lenis-prevent-wheel"))) ||
                (((Me = H.classList) === null || Me === void 0
                  ? void 0
                  : Me.contains("lenis")) &&
                  !(
                    !((Ue = H.classList) === null || Ue === void 0) &&
                    Ue.contains("lenis-stopped")
                  )))
            );
          })
        )
          return;
        if (this.isStopped || this.isLocked) return void A.preventDefault();
        if (!((this.options.syncTouch && y) || (this.options.smoothWheel && x)))
          return (this.isScrolling = "native"), void this.animate.stop();
        A.preventDefault();
        let G = E;
        this.options.gestureOrientation === "both"
          ? (G = Math.abs(E) > Math.abs(w) ? E : w)
          : this.options.gestureOrientation === "horizontal" && (G = w);
        const z = y && this.options.syncTouch,
          q = y && A.type === "touchend" && Math.abs(G) > 5;
        q && (G = this.velocity * this.options.touchInertiaMultiplier),
          this.scrollTo(
            this.targetScroll + G,
            Object.assign(
              { programmatic: !1 },
              z
                ? { lerp: q ? this.options.syncTouchLerp : 1 }
                : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing,
                  }
            )
          );
      }),
      (this.onNativeScroll = () => {
        if (
          (clearTimeout(this.__resetVelocityTimeout),
          delete this.__resetVelocityTimeout,
          this.__preventNextNativeScrollEvent)
        )
          delete this.__preventNextNativeScrollEvent;
        else if (this.isScrolling === !1 || this.isScrolling === "native") {
          const C = this.animatedScroll;
          (this.animatedScroll = this.targetScroll = this.actualScroll),
            (this.lastVelocity = this.velocity),
            (this.velocity = this.animatedScroll - C),
            (this.direction = Math.sign(this.animatedScroll - C)),
            (this.isScrolling = "native"),
            this.emit(),
            this.velocity !== 0 &&
              (this.__resetVelocityTimeout = setTimeout(() => {
                (this.lastVelocity = this.velocity),
                  (this.velocity = 0),
                  (this.isScrolling = !1),
                  this.emit();
              }, 400));
        }
      }),
      (window.lenisVersion = "1.1.9"),
      (e && e !== document.documentElement && e !== document.body) ||
        (e = window),
      (this.options = {
        wrapper: e,
        content: t,
        wheelEventsTarget: n,
        eventsTarget: i,
        smoothWheel: r,
        syncTouch: o,
        syncTouchLerp: a,
        touchInertiaMultiplier: l,
        duration: c,
        easing: h,
        lerp: u,
        infinite: f,
        gestureOrientation: _,
        orientation: d,
        touchMultiplier: g,
        wheelMultiplier: m,
        autoResize: p,
        prevent: M,
        virtualScroll: S,
        __experimental__naiveDimensions: v,
      }),
      (this.animate = new Sb()),
      (this.emitter = new M_()),
      (this.dimensions = new Tb({ wrapper: e, content: t, autoResize: p })),
      this.updateClassName(),
      (this.userData = {}),
      (this.time = 0),
      (this.velocity = this.lastVelocity = 0),
      (this.isLocked = !1),
      (this.isStopped = !1),
      (this.isScrolling = !1),
      (this.targetScroll = this.animatedScroll = this.actualScroll),
      this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
      this.options.wrapper.addEventListener(
        "pointerdown",
        this.onPointerDown,
        !1
      ),
      (this.virtualScroll = new Eb(i, {
        touchMultiplier: g,
        wheelMultiplier: m,
      })),
      this.virtualScroll.on("scroll", this.onVirtualScroll);
  }
  destroy() {
    this.emitter.destroy(),
      this.options.wrapper.removeEventListener(
        "scroll",
        this.onNativeScroll,
        !1
      ),
      this.options.wrapper.removeEventListener(
        "pointerdown",
        this.onPointerDown,
        !1
      ),
      this.virtualScroll.destroy(),
      this.dimensions.destroy(),
      this.cleanUpClassName();
  }
  on(e, t) {
    return this.emitter.on(e, t);
  }
  off(e, t) {
    return this.emitter.off(e, t);
  }
  setScroll(e) {
    this.isHorizontal
      ? (this.rootElement.scrollLeft = e)
      : (this.rootElement.scrollTop = e);
  }
  resize() {
    this.dimensions.resize();
  }
  emit() {
    this.emitter.emit("scroll", this);
  }
  reset() {
    (this.isLocked = !1),
      (this.isScrolling = !1),
      (this.animatedScroll = this.targetScroll = this.actualScroll),
      (this.lastVelocity = this.velocity = 0),
      this.animate.stop();
  }
  start() {
    this.isStopped && ((this.isStopped = !1), this.reset());
  }
  stop() {
    this.isStopped ||
      ((this.isStopped = !0), this.animate.stop(), this.reset());
  }
  raf(e) {
    const t = e - (this.time || e);
    (this.time = e), this.animate.advance(0.001 * t);
  }
  scrollTo(
    e,
    {
      offset: t = 0,
      immediate: n = !1,
      lock: i = !1,
      duration: r = this.options.duration,
      easing: o = this.options.easing,
      lerp: a = this.options.lerp,
      onStart: l,
      onComplete: c,
      force: h = !1,
      programmatic: u = !0,
      userData: f = {},
    } = {}
  ) {
    if ((!this.isStopped && !this.isLocked) || h) {
      if (typeof e == "string" && ["top", "left", "start"].includes(e)) e = 0;
      else if (typeof e == "string" && ["bottom", "right", "end"].includes(e))
        e = this.limit;
      else {
        let d;
        if (
          (typeof e == "string"
            ? (d = document.querySelector(e))
            : e instanceof HTMLElement && e != null && e.nodeType && (d = e),
          d)
        ) {
          if (this.options.wrapper !== window) {
            const g = this.rootElement.getBoundingClientRect();
            t -= this.isHorizontal ? g.left : g.top;
          }
          const _ = d.getBoundingClientRect();
          e = (this.isHorizontal ? _.left : _.top) + this.animatedScroll;
        }
      }
      if (
        typeof e == "number" &&
        ((e += t),
        (e = Math.round(e)),
        this.options.infinite
          ? u && (this.targetScroll = this.animatedScroll = this.scroll)
          : (e = y_(0, e, this.limit)),
        e !== this.targetScroll)
      ) {
        if (((this.userData = f), n))
          return (
            (this.animatedScroll = this.targetScroll = e),
            this.setScroll(this.scroll),
            this.reset(),
            this.preventNextNativeScrollEvent(),
            this.emit(),
            c == null || c(this),
            void (this.userData = {})
          );
        u || (this.targetScroll = e),
          this.animate.fromTo(this.animatedScroll, e, {
            duration: r,
            easing: o,
            lerp: a,
            onStart: () => {
              i && (this.isLocked = !0),
                (this.isScrolling = "smooth"),
                l == null || l(this);
            },
            onUpdate: (d, _) => {
              (this.isScrolling = "smooth"),
                (this.lastVelocity = this.velocity),
                (this.velocity = d - this.animatedScroll),
                (this.direction = Math.sign(this.velocity)),
                (this.animatedScroll = d),
                this.setScroll(this.scroll),
                u && (this.targetScroll = d),
                _ || this.emit(),
                _ &&
                  (this.reset(),
                  this.emit(),
                  c == null || c(this),
                  (this.userData = {}),
                  this.preventNextNativeScrollEvent());
            },
          });
      }
    }
  }
  preventNextNativeScrollEvent() {
    (this.__preventNextNativeScrollEvent = !0),
      requestAnimationFrame(() => {
        delete this.__preventNextNativeScrollEvent;
      });
  }
  get rootElement() {
    return this.options.wrapper === window
      ? document.documentElement
      : this.options.wrapper;
  }
  get limit() {
    return this.options.__experimental__naiveDimensions
      ? this.isHorizontal
        ? this.rootElement.scrollWidth - this.rootElement.clientWidth
        : this.rootElement.scrollHeight - this.rootElement.clientHeight
      : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
  }
  get isHorizontal() {
    return this.options.orientation === "horizontal";
  }
  get actualScroll() {
    return this.isHorizontal
      ? this.rootElement.scrollLeft
      : this.rootElement.scrollTop;
  }
  get scroll() {
    return this.options.infinite
      ? (function (t, n) {
          return ((t % n) + n) % n;
        })(this.animatedScroll, this.limit)
      : this.animatedScroll;
  }
  get progress() {
    return this.limit === 0 ? 1 : this.scroll / this.limit;
  }
  get isScrolling() {
    return this.__isScrolling;
  }
  set isScrolling(e) {
    this.__isScrolling !== e &&
      ((this.__isScrolling = e), this.updateClassName());
  }
  get isStopped() {
    return this.__isStopped;
  }
  set isStopped(e) {
    this.__isStopped !== e && ((this.__isStopped = e), this.updateClassName());
  }
  get isLocked() {
    return this.__isLocked;
  }
  set isLocked(e) {
    this.__isLocked !== e && ((this.__isLocked = e), this.updateClassName());
  }
  get isSmooth() {
    return this.isScrolling === "smooth";
  }
  get className() {
    let e = "lenis";
    return (
      this.isStopped && (e += " lenis-stopped"),
      this.isLocked && (e += " lenis-locked"),
      this.isScrolling && (e += " lenis-scrolling"),
      this.isScrolling === "smooth" && (e += " lenis-smooth"),
      e
    );
  }
  updateClassName() {
    this.cleanUpClassName(),
      (this.rootElement.className =
        `${this.rootElement.className} ${this.className}`.trim());
  }
  cleanUpClassName() {
    this.rootElement.className = this.rootElement.className
      .replace(/lenis(-\w+)?/g, "")
      .trim();
  }
}
function du() {
  return (
    (du = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t) ({}).hasOwnProperty.call(t, n) && (s[n] = t[n]);
          }
          return s;
        }),
    du.apply(null, arguments)
  );
}
class hp {
  constructor({
    scrollElements: e,
    rootMargin: t = "-1px -1px -1px -1px",
    IORaf: n,
  }) {
    (this.scrollElements = void 0),
      (this.rootMargin = void 0),
      (this.IORaf = void 0),
      (this.observer = void 0),
      (this.scrollElements = e),
      (this.rootMargin = t),
      (this.IORaf = n),
      this._init();
  }
  _init() {
    this.observer = new IntersectionObserver(
      (e) => {
        e.forEach((t) => {
          const n = this.scrollElements.find((i) => i.$el === t.target);
          t.isIntersecting
            ? (n && (n.isAlreadyIntersected = !0), this._setInview(t))
            : n && n.isAlreadyIntersected && this._setOutOfView(t);
        });
      },
      { rootMargin: this.rootMargin }
    );
    for (const e of this.scrollElements) this.observe(e.$el);
  }
  destroy() {
    this.observer.disconnect();
  }
  observe(e) {
    e && this.observer.observe(e);
  }
  unobserve(e) {
    e && this.observer.unobserve(e);
  }
  _setInview(e) {
    const t = this.scrollElements.find((n) => n.$el === e.target);
    this.IORaf && (t == null || t.setInteractivityOn()),
      !this.IORaf && (t == null || t.setInview());
  }
  _setOutOfView(e) {
    const t = this.scrollElements.find((n) => n.$el === e.target);
    this.IORaf && (t == null || t.setInteractivityOff()),
      !this.IORaf && (t == null || t.setOutOfView()),
      (t != null && t.attributes.scrollRepeat) ||
        this.IORaf ||
        this.unobserve(e.target);
  }
}
function up(s, e, t, n, i) {
  return t + (((i - s) / (e - s)) * (n - t) || 0);
}
function fp(s, e) {
  return s.reduce((t, n) => (Math.abs(n - e) < Math.abs(t - e) ? n : t));
}
class Ab {
  constructor({
    $el: e,
    id: t,
    modularInstance: n,
    subscribeElementUpdateFn: i,
    unsubscribeElementUpdateFn: r,
    needRaf: o,
    scrollOrientation: a,
  }) {
    var l, c, h, u, f;
    (this.$el = void 0),
      (this.id = void 0),
      (this.needRaf = void 0),
      (this.attributes = void 0),
      (this.scrollOrientation = void 0),
      (this.isAlreadyIntersected = void 0),
      (this.intersection = void 0),
      (this.metrics = void 0),
      (this.currentScroll = void 0),
      (this.translateValue = void 0),
      (this.progress = void 0),
      (this.lastProgress = void 0),
      (this.modularInstance = void 0),
      (this.progressModularModules = void 0),
      (this.isInview = void 0),
      (this.isInteractive = void 0),
      (this.isInFold = void 0),
      (this.isFirstResize = void 0),
      (this.subscribeElementUpdateFn = void 0),
      (this.unsubscribeElementUpdateFn = void 0),
      (this.$el = e),
      (this.id = t),
      (this.needRaf = o),
      (this.scrollOrientation = a),
      (this.modularInstance = n),
      (this.subscribeElementUpdateFn = i),
      (this.unsubscribeElementUpdateFn = r),
      (this.attributes = {
        scrollClass:
          (l = this.$el.dataset.scrollClass) != null ? l : "is-inview",
        scrollOffset: (c = this.$el.dataset.scrollOffset) != null ? c : "0,0",
        scrollPosition:
          (h = this.$el.dataset.scrollPosition) != null ? h : "start,end",
        scrollModuleProgress: this.$el.dataset.scrollModuleProgress != null,
        scrollCssProgress: this.$el.dataset.scrollCssProgress != null,
        scrollEventProgress:
          (u = this.$el.dataset.scrollEventProgress) != null ? u : null,
        scrollSpeed:
          this.$el.dataset.scrollSpeed != null
            ? parseFloat(this.$el.dataset.scrollSpeed)
            : null,
        scrollRepeat: this.$el.dataset.scrollRepeat != null,
        scrollCall: (f = this.$el.dataset.scrollCall) != null ? f : null,
        scrollCallSelf: this.$el.dataset.scrollCallSelf != null,
        scrollIgnoreFold: this.$el.dataset.scrollIgnoreFold != null,
        scrollEnableTouchSpeed: this.$el.dataset.scrollEnableTouchSpeed != null,
      }),
      (this.intersection = { start: 0, end: 0 }),
      (this.metrics = { offsetStart: 0, offsetEnd: 0, bcr: {} }),
      (this.currentScroll =
        this.scrollOrientation === "vertical"
          ? window.scrollY
          : window.scrollX),
      (this.translateValue = 0),
      (this.progress = 0),
      (this.lastProgress = null),
      (this.progressModularModules = []),
      (this.isInview = !1),
      (this.isInteractive = !1),
      (this.isAlreadyIntersected = !1),
      (this.isInFold = !1),
      (this.isFirstResize = !0),
      this._init();
  }
  _init() {
    this.needRaf &&
      (this.modularInstance &&
        this.attributes.scrollModuleProgress &&
        this._getProgressModularModules(),
      this._resize());
  }
  onResize({ currentScroll: e }) {
    (this.currentScroll = e), this._resize();
  }
  onRender({ currentScroll: e, smooth: t }) {
    const n =
      this.scrollOrientation === "vertical"
        ? window.innerHeight
        : window.innerWidth;
    if (
      ((this.currentScroll = e),
      this._computeProgress(),
      this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed))
    )
      if (this.attributes.scrollEnableTouchSpeed || t) {
        if (this.isInFold) {
          const i = Math.max(0, this.progress);
          this.translateValue = i * n * this.attributes.scrollSpeed * -1;
        } else {
          const i = up(0, 1, -1, 1, this.progress);
          this.translateValue = i * n * this.attributes.scrollSpeed * -1;
        }
        this.$el.style.transform =
          this.scrollOrientation === "vertical"
            ? `translate3d(0, ${this.translateValue}px, 0)`
            : `translate3d(${this.translateValue}px, 0, 0)`;
      } else
        this.translateValue &&
          (this.$el.style.transform = "translate3d(0, 0, 0)"),
          (this.translateValue = 0);
  }
  setInview() {
    if (this.isInview) return;
    (this.isInview = !0), this.$el.classList.add(this.attributes.scrollClass);
    const e = this._getScrollCallFrom();
    this.attributes.scrollCall && this._dispatchCall("enter", e);
  }
  setOutOfView() {
    if (!this.isInview || !this.attributes.scrollRepeat) return;
    (this.isInview = !1),
      this.$el.classList.remove(this.attributes.scrollClass);
    const e = this._getScrollCallFrom();
    this.attributes.scrollCall && this._dispatchCall("leave", e);
  }
  setInteractivityOn() {
    this.isInteractive ||
      ((this.isInteractive = !0), this.subscribeElementUpdateFn(this));
  }
  setInteractivityOff() {
    this.isInteractive &&
      ((this.isInteractive = !1),
      this.unsubscribeElementUpdateFn(this),
      this.lastProgress != null &&
        this._computeProgress(fp([0, 1], this.lastProgress)));
  }
  _resize() {
    (this.metrics.bcr = this.$el.getBoundingClientRect()),
      this._computeMetrics(),
      this._computeIntersection(),
      this.isFirstResize &&
        ((this.isFirstResize = !1), this.isInFold && this.setInview());
  }
  _computeMetrics() {
    const { top: e, left: t, height: n, width: i } = this.metrics.bcr,
      r =
        this.scrollOrientation === "vertical"
          ? window.innerHeight
          : window.innerWidth,
      o = this.scrollOrientation === "vertical" ? n : i;
    (this.metrics.offsetStart =
      this.currentScroll +
      (this.scrollOrientation === "vertical" ? e : t) -
      this.translateValue),
      (this.metrics.offsetEnd = this.metrics.offsetStart + o),
      (this.isInFold =
        this.metrics.offsetStart < r && !this.attributes.scrollIgnoreFold);
  }
  _computeIntersection() {
    const e =
        this.scrollOrientation === "vertical"
          ? window.innerHeight
          : window.innerWidth,
      t =
        this.scrollOrientation === "vertical"
          ? this.metrics.bcr.height
          : this.metrics.bcr.width,
      n = this.attributes.scrollOffset.split(","),
      i = n[0] != null ? n[0].trim() : "0",
      r = n[1] != null ? n[1].trim() : "0",
      o = this.attributes.scrollPosition.split(",");
    let a = o[0] != null ? o[0].trim() : "start";
    const l = o[1] != null ? o[1].trim() : "end",
      c = i.includes("%")
        ? e * parseInt(i.replace("%", "").trim()) * 0.01
        : parseInt(i),
      h = r.includes("%")
        ? e * parseInt(r.replace("%", "").trim()) * 0.01
        : parseInt(r);
    switch ((this.isInFold && (a = "fold"), a)) {
      case "start":
      default:
        this.intersection.start = this.metrics.offsetStart - e + c;
        break;
      case "middle":
        this.intersection.start = this.metrics.offsetStart - e + c + 0.5 * t;
        break;
      case "end":
        this.intersection.start = this.metrics.offsetStart - e + c + t;
        break;
      case "fold":
        this.intersection.start = 0;
    }
    switch (l) {
      case "start":
        this.intersection.end = this.metrics.offsetStart - h;
        break;
      case "middle":
        this.intersection.end = this.metrics.offsetStart - h + 0.5 * t;
        break;
      default:
        this.intersection.end = this.metrics.offsetStart - h + t;
    }
    if (this.intersection.end <= this.intersection.start)
      switch (l) {
        case "start":
        default:
          this.intersection.end = this.intersection.start + 1;
          break;
        case "middle":
          this.intersection.end = this.intersection.start + 0.5 * t;
          break;
        case "end":
          this.intersection.end = this.intersection.start + t;
      }
  }
  _computeProgress(e) {
    const t =
      e ??
      ((n = up(
        this.intersection.start,
        this.intersection.end,
        0,
        1,
        this.currentScroll
      )) < 0
        ? 0
        : n > 1
        ? 1
        : n);
    var n;
    if (((this.progress = t), t != this.lastProgress)) {
      if (
        ((this.lastProgress = t),
        this.attributes.scrollCssProgress && this._setCssProgress(t),
        this.attributes.scrollEventProgress && this._setCustomEventProgress(t),
        this.attributes.scrollModuleProgress)
      )
        for (const i of this.progressModularModules)
          this.modularInstance &&
            this.modularInstance.call(
              "onScrollProgress",
              t,
              i.moduleName,
              i.moduleId
            );
      t > 0 && t < 1 && this.setInview(),
        t === 0 && this.setOutOfView(),
        t === 1 && this.setOutOfView();
    }
  }
  _setCssProgress(e = 0) {
    this.$el.style.setProperty("--progress", e.toString());
  }
  _setCustomEventProgress(e = 0) {
    const t = this.attributes.scrollEventProgress;
    if (!t) return;
    const n = new CustomEvent(t, { detail: { target: this.$el, progress: e } });
    window.dispatchEvent(n);
  }
  _getProgressModularModules() {
    if (!this.modularInstance) return;
    const e = Object.keys(this.$el.dataset).filter((n) => n.includes("module")),
      t = Object.entries(this.modularInstance.modules);
    if (e.length)
      for (const n of e) {
        const i = this.$el.dataset[n];
        if (!i) return;
        for (const r of t) {
          const [o, a] = r;
          i in a &&
            this.progressModularModules.push({ moduleName: o, moduleId: i });
        }
      }
  }
  _getScrollCallFrom() {
    const e = fp(
      [this.intersection.start, this.intersection.end],
      this.currentScroll
    );
    return this.intersection.start === e ? "start" : "end";
  }
  _dispatchCall(e, t) {
    var n, i;
    const r = (n = this.attributes.scrollCall) == null ? void 0 : n.split(","),
      o = (i = this.attributes) == null ? void 0 : i.scrollCallSelf;
    if (r && r.length > 1) {
      var a;
      const [l, c, h] = r;
      let u;
      (u = o ? this.$el.dataset[`module${c.trim()}`] : h),
        this.modularInstance &&
          this.modularInstance.call(
            l.trim(),
            { target: this.$el, way: e, from: t },
            c.trim(),
            (a = u) == null ? void 0 : a.trim()
          );
    } else if (r) {
      const [l] = r,
        c = new CustomEvent(l, {
          detail: { target: this.$el, way: e, from: t },
        });
      window.dispatchEvent(c);
    }
  }
}
const wb = [
  "scrollOffset",
  "scrollPosition",
  "scrollModuleProgress",
  "scrollCssProgress",
  "scrollEventProgress",
  "scrollSpeed",
];
class Rb {
  constructor({
    $el: e,
    modularInstance: t,
    triggerRootMargin: n,
    rafRootMargin: i,
    scrollOrientation: r,
  }) {
    (this.$scrollContainer = void 0),
      (this.modularInstance = void 0),
      (this.triggerRootMargin = void 0),
      (this.rafRootMargin = void 0),
      (this.scrollElements = void 0),
      (this.triggeredScrollElements = void 0),
      (this.RAFScrollElements = void 0),
      (this.scrollElementsToUpdate = void 0),
      (this.IOTriggerInstance = void 0),
      (this.IORafInstance = void 0),
      (this.scrollOrientation = void 0),
      e
        ? ((this.$scrollContainer = e),
          (this.modularInstance = t),
          (this.scrollOrientation = r),
          (this.triggerRootMargin = n ?? "-1px -1px -1px -1px"),
          (this.rafRootMargin = i ?? "100% 100% 100% 100%"),
          (this.scrollElements = []),
          (this.triggeredScrollElements = []),
          (this.RAFScrollElements = []),
          (this.scrollElementsToUpdate = []),
          this._init())
        : console.error("Please provide a DOM Element as scrollContainer");
  }
  _init() {
    const e = this.$scrollContainer.querySelectorAll("[data-scroll]"),
      t = Array.from(e);
    this._subscribeScrollElements(t),
      (this.IOTriggerInstance = new hp({
        scrollElements: [...this.triggeredScrollElements],
        rootMargin: this.triggerRootMargin,
        IORaf: !1,
      })),
      (this.IORafInstance = new hp({
        scrollElements: [...this.RAFScrollElements],
        rootMargin: this.rafRootMargin,
        IORaf: !0,
      }));
  }
  destroy() {
    this.IOTriggerInstance.destroy(),
      this.IORafInstance.destroy(),
      this._unsubscribeAllScrollElements();
  }
  onResize({ currentScroll: e }) {
    for (const t of this.RAFScrollElements) t.onResize({ currentScroll: e });
  }
  onRender({ currentScroll: e, smooth: t }) {
    for (const n of this.scrollElementsToUpdate)
      n.onRender({ currentScroll: e, smooth: t });
  }
  removeScrollElements(e) {
    const t = e.querySelectorAll("[data-scroll]");
    if (t.length) {
      for (let n = 0; n < this.triggeredScrollElements.length; n++) {
        const i = this.triggeredScrollElements[n];
        Array.from(t).indexOf(i.$el) > -1 &&
          (this.IOTriggerInstance.unobserve(i.$el),
          this.triggeredScrollElements.splice(n, 1));
      }
      for (let n = 0; n < this.RAFScrollElements.length; n++) {
        const i = this.RAFScrollElements[n];
        Array.from(t).indexOf(i.$el) > -1 &&
          (this.IORafInstance.unobserve(i.$el),
          this.RAFScrollElements.splice(n, 1));
      }
      t.forEach((n) => {
        const i = this.scrollElementsToUpdate.find((o) => o.$el === n),
          r = this.scrollElements.find((o) => o.$el === n);
        i && this._unsubscribeElementUpdate(i),
          r &&
            (this.scrollElements = this.scrollElements.filter(
              (o) => o.id != r.id
            ));
      });
    }
  }
  addScrollElements(e) {
    const t = e.querySelectorAll("[data-scroll]"),
      n = [];
    this.scrollElements.forEach((o) => {
      n.push(o.id);
    });
    const i = Math.max(...n, 0) + 1,
      r = Array.from(t);
    this._subscribeScrollElements(r, i, !0);
  }
  _subscribeScrollElements(e, t = 0, n = !1) {
    for (let i = 0; i < e.length; i++) {
      const r = e[i],
        o = this._checkRafNeeded(r),
        a = new Ab({
          $el: r,
          id: t + i,
          scrollOrientation: this.scrollOrientation,
          modularInstance: this.modularInstance,
          subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),
          unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this),
          needRaf: o,
        });
      this.scrollElements.push(a),
        o
          ? (this.RAFScrollElements.push(a),
            n &&
              (this.IORafInstance.scrollElements.push(a),
              this.IORafInstance.observe(a.$el)))
          : (this.triggeredScrollElements.push(a),
            n &&
              (this.IOTriggerInstance.scrollElements.push(a),
              this.IOTriggerInstance.observe(a.$el)));
    }
  }
  _unsubscribeAllScrollElements() {
    (this.scrollElements = []),
      (this.RAFScrollElements = []),
      (this.triggeredScrollElements = []),
      (this.scrollElementsToUpdate = []);
  }
  _subscribeElementUpdate(e) {
    this.scrollElementsToUpdate.push(e);
  }
  _unsubscribeElementUpdate(e) {
    this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(
      (t) => t.id != e.id
    );
  }
  _checkRafNeeded(e) {
    let t = [...wb];
    const n = (i) => {
      t = t.filter((r) => r != i);
    };
    if (e.dataset.scrollOffset) {
      if (
        e.dataset.scrollOffset
          .split(",")
          .map((i) => i.replace("%", "").trim())
          .join(",") != "0,0"
      )
        return !0;
      n("scrollOffset");
    } else n("scrollOffset");
    if (e.dataset.scrollPosition) {
      if (e.dataset.scrollPosition.trim() != "top,bottom") return !0;
      n("scrollPosition");
    } else n("scrollPosition");
    if (e.dataset.scrollSpeed && !isNaN(parseFloat(e.dataset.scrollSpeed)))
      return !0;
    n("scrollSpeed");
    for (const i of t) if (i in e.dataset) return !0;
    return !1;
  }
}
class Cb {
  constructor({ resizeElements: e, resizeCallback: t = () => {} }) {
    (this.$resizeElements = void 0),
      (this.isFirstObserve = void 0),
      (this.observer = void 0),
      (this.resizeCallback = void 0),
      (this.$resizeElements = e),
      (this.resizeCallback = t),
      (this.isFirstObserve = !0),
      this._init();
  }
  _init() {
    this.observer = new ResizeObserver((e) => {
      var t;
      !this.isFirstObserve &&
        ((t = this.resizeCallback) == null || t.call(this)),
        (this.isFirstObserve = !1);
    });
    for (const e of this.$resizeElements) this.observer.observe(e);
  }
  destroy() {
    this.observer.disconnect();
  }
}
class Pb {
  constructor({
    lenisOptions: e = {},
    modularInstance: t,
    triggerRootMargin: n,
    rafRootMargin: i,
    autoResize: r = !0,
    autoStart: o = !0,
    scrollCallback: a = () => {},
    initCustomTicker: l,
    destroyCustomTicker: c,
  } = {}) {
    (this.rafPlaying = void 0),
      (this.lenisInstance = void 0),
      (this.coreInstance = void 0),
      (this.lenisOptions = void 0),
      (this.modularInstance = void 0),
      (this.triggerRootMargin = void 0),
      (this.rafRootMargin = void 0),
      (this.rafInstance = void 0),
      (this.autoResize = void 0),
      (this.autoStart = void 0),
      (this.ROInstance = void 0),
      (this.initCustomTicker = void 0),
      (this.destroyCustomTicker = void 0),
      (this._onRenderBind = void 0),
      (this._onResizeBind = void 0),
      (this._onScrollToBind = void 0);
    for (const [h] of Object.entries(e))
      ["wrapper", "content", "infinite"].includes(h) &&
        console.warn(
          `Warning: Key "${h}" is not possible to edit in Locomotive Scroll.`
        );
    Object.assign(this, {
      lenisOptions: e,
      modularInstance: t,
      triggerRootMargin: n,
      rafRootMargin: i,
      autoResize: r,
      autoStart: o,
      scrollCallback: a,
      initCustomTicker: l,
      destroyCustomTicker: c,
    }),
      (this._onRenderBind = this._onRender.bind(this)),
      (this._onScrollToBind = this._onScrollTo.bind(this)),
      (this._onResizeBind = this._onResize.bind(this)),
      (this.rafPlaying = !1),
      this._init();
  }
  _init() {
    var e;
    (this.lenisInstance = new bb(
      du({}, this.lenisOptions, {
        wrapper: window,
        content: document.documentElement,
        infinite: !1,
      })
    )),
      (e = this.lenisInstance) == null || e.on("scroll", this.scrollCallback),
      document.documentElement.setAttribute(
        "data-scroll-orientation",
        this.lenisInstance.options.orientation
      ),
      requestAnimationFrame(() => {
        (this.coreInstance = new Rb({
          $el: this.lenisInstance.rootElement,
          modularInstance: this.modularInstance,
          triggerRootMargin: this.triggerRootMargin,
          rafRootMargin: this.rafRootMargin,
          scrollOrientation: this.lenisInstance.options.orientation,
        })),
          this._bindEvents(),
          this.initCustomTicker && !this.destroyCustomTicker
            ? console.warn(
                "initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble."
              )
            : !this.initCustomTicker &&
              this.destroyCustomTicker &&
              console.warn(
                "destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."
              ),
          this.autoStart && this.start();
      });
  }
  destroy() {
    var e;
    this.stop(),
      this._unbindEvents(),
      this.lenisInstance.destroy(),
      (e = this.coreInstance) == null || e.destroy(),
      requestAnimationFrame(() => {
        var t;
        (t = this.coreInstance) == null || t.destroy();
      });
  }
  _bindEvents() {
    this._bindScrollToEvents(),
      this.autoResize &&
        ("ResizeObserver" in window
          ? (this.ROInstance = new Cb({
              resizeElements: [document.body],
              resizeCallback: this._onResizeBind,
            }))
          : window.addEventListener("resize", this._onResizeBind));
  }
  _unbindEvents() {
    this._unbindScrollToEvents(),
      this.autoResize &&
        ("ResizeObserver" in window
          ? this.ROInstance && this.ROInstance.destroy()
          : window.removeEventListener("resize", this._onResizeBind));
  }
  _bindScrollToEvents(e) {
    const t = e || this.lenisInstance.rootElement,
      n = t == null ? void 0 : t.querySelectorAll("[data-scroll-to]");
    n != null &&
      n.length &&
      n.forEach((i) => {
        i.addEventListener("click", this._onScrollToBind, !1);
      });
  }
  _unbindScrollToEvents(e) {
    const t = e || this.lenisInstance.rootElement,
      n = t == null ? void 0 : t.querySelectorAll("[data-scroll-to]");
    n != null &&
      n.length &&
      n.forEach((i) => {
        i.removeEventListener("click", this._onScrollToBind, !1);
      });
  }
  _onResize() {
    requestAnimationFrame(() => {
      var e;
      (e = this.coreInstance) == null ||
        e.onResize({ currentScroll: this.lenisInstance.scroll });
    });
  }
  _onRender() {
    var e, t;
    (e = this.lenisInstance) == null || e.raf(Date.now()),
      (t = this.coreInstance) == null ||
        t.onRender({
          currentScroll: this.lenisInstance.scroll,
          smooth: this.lenisInstance.options.smoothWheel,
        });
  }
  _onScrollTo(e) {
    var t;
    e.preventDefault();
    const n = (t = e.currentTarget) != null ? t : null;
    if (!n) return;
    const i = n.getAttribute("data-scroll-to-href") || n.getAttribute("href"),
      r = n.getAttribute("data-scroll-to-offset") || 0,
      o =
        n.getAttribute("data-scroll-to-duration") ||
        this.lenisInstance.options.duration;
    i &&
      this.scrollTo(i, {
        offset: typeof r == "string" ? parseInt(r) : r,
        duration: typeof o == "string" ? parseInt(o) : o,
      });
  }
  start() {
    var e;
    this.rafPlaying ||
      ((e = this.lenisInstance) == null || e.start(),
      (this.rafPlaying = !0),
      this.initCustomTicker
        ? this.initCustomTicker(this._onRenderBind)
        : this._raf());
  }
  stop() {
    var e;
    this.rafPlaying &&
      ((e = this.lenisInstance) == null || e.stop(),
      (this.rafPlaying = !1),
      this.destroyCustomTicker
        ? this.destroyCustomTicker(this._onRenderBind)
        : this.rafInstance && cancelAnimationFrame(this.rafInstance));
  }
  removeScrollElements(e) {
    var t;
    e
      ? (this._unbindScrollToEvents(e),
        (t = this.coreInstance) == null || t.removeScrollElements(e))
      : console.error("Please provide a DOM Element as $oldContainer");
  }
  addScrollElements(e) {
    var t;
    e
      ? ((t = this.coreInstance) == null || t.addScrollElements(e),
        requestAnimationFrame(() => {
          this._bindScrollToEvents(e);
        }))
      : console.error("Please provide a DOM Element as $newContainer");
  }
  resize() {
    this._onResizeBind();
  }
  scrollTo(e, t) {
    var n;
    (n = this.lenisInstance) == null ||
      n.scrollTo(e, {
        offset: t == null ? void 0 : t.offset,
        lerp: t == null ? void 0 : t.lerp,
        duration: t == null ? void 0 : t.duration,
        immediate: t == null ? void 0 : t.immediate,
        lock: t == null ? void 0 : t.lock,
        force: t == null ? void 0 : t.force,
        easing: t == null ? void 0 : t.easing,
        onComplete: t == null ? void 0 : t.onComplete,
      });
  }
  _raf() {
    this._onRenderBind(),
      (this.rafInstance = requestAnimationFrame(() => this._raf()));
  }
}
function Db(s, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    (n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      "value" in n && (n.writable = !0),
      Object.defineProperty(s, n.key, n);
  }
}
function Lb(s, e, t) {
  return e && Db(s.prototype, e), s;
}
/*!
 * Observer 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var on,
  wl,
  jn,
  wr,
  Rr,
  Qs,
  S_,
  jr,
  ea,
  T_,
  tr,
  pi,
  E_,
  b_ = function () {
    return (
      on ||
      (typeof window < "u" && (on = window.gsap) && on.registerPlugin && on)
    );
  },
  A_ = 1,
  Ws = [],
  nt = [],
  Ui = [],
  ta = Date.now,
  pu = function (e, t) {
    return t;
  },
  Ib = function () {
    var e = ea.core,
      t = e.bridge || {},
      n = e._scrollers,
      i = e._proxies;
    n.push.apply(n, nt),
      i.push.apply(i, Ui),
      (nt = n),
      (Ui = i),
      (pu = function (o, a) {
        return t[o](a);
      });
  },
  Lr = function (e, t) {
    return ~Ui.indexOf(e) && Ui[Ui.indexOf(e) + 1][t];
  },
  na = function (e) {
    return !!~T_.indexOf(e);
  },
  vn = function (e, t, n, i, r) {
    return e.addEventListener(t, n, { passive: i !== !1, capture: !!r });
  },
  gn = function (e, t, n, i) {
    return e.removeEventListener(t, n, !!i);
  },
  rl = "scrollLeft",
  sl = "scrollTop",
  mu = function () {
    return (tr && tr.isPressed) || nt.cache++;
  },
  Yl = function (e, t) {
    var n = function i(r) {
      if (r || r === 0) {
        A_ && (jn.history.scrollRestoration = "manual");
        var o = tr && tr.isPressed;
        (r = i.v = Math.round(r) || (tr && tr.iOS ? 1 : 0)),
          e(r),
          (i.cacheID = nt.cache),
          o && pu("ss", r);
      } else
        (t || nt.cache !== i.cacheID || pu("ref")) &&
          ((i.cacheID = nt.cache), (i.v = e()));
      return i.v + i.offset;
    };
    return (n.offset = 0), e && n;
  },
  bn = {
    s: rl,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: Yl(function (s) {
      return arguments.length
        ? jn.scrollTo(s, qt.sc())
        : jn.pageXOffset || wr[rl] || Rr[rl] || Qs[rl] || 0;
    }),
  },
  qt = {
    s: sl,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: bn,
    sc: Yl(function (s) {
      return arguments.length
        ? jn.scrollTo(bn.sc(), s)
        : jn.pageYOffset || wr[sl] || Rr[sl] || Qs[sl] || 0;
    }),
  },
  Pn = function (e, t) {
    return (
      ((t && t._ctx && t._ctx.selector) || on.utils.toArray)(e)[0] ||
      (typeof e == "string" && on.config().nullTargetWarn !== !1
        ? console.warn("Element not found:", e)
        : null)
    );
  },
  Nr = function (e, t) {
    var n = t.s,
      i = t.sc;
    na(e) && (e = wr.scrollingElement || Rr);
    var r = nt.indexOf(e),
      o = i === qt.sc ? 1 : 2;
    !~r && (r = nt.push(e) - 1), nt[r + o] || vn(e, "scroll", mu);
    var a = nt[r + o],
      l =
        a ||
        (nt[r + o] =
          Yl(Lr(e, n), !0) ||
          (na(e)
            ? i
            : Yl(function (c) {
                return arguments.length ? (e[n] = c) : e[n];
              })));
    return (
      (l.target = e),
      a || (l.smooth = on.getProperty(e, "scrollBehavior") === "smooth"),
      l
    );
  },
  _u = function (e, t, n) {
    var i = e,
      r = e,
      o = ta(),
      a = o,
      l = t || 50,
      c = Math.max(500, l * 3),
      h = function (_, g) {
        var m = ta();
        g || m - o > l
          ? ((r = i), (i = _), (a = o), (o = m))
          : n
          ? (i += _)
          : (i = r + ((_ - r) / (m - a)) * (o - a));
      },
      u = function () {
        (r = i = n ? 0 : i), (a = o = 0);
      },
      f = function (_) {
        var g = a,
          m = r,
          p = ta();
        return (
          (_ || _ === 0) && _ !== i && h(_),
          o === a || p - a > c
            ? 0
            : ((i + (n ? m : -m)) / ((n ? p : o) - g)) * 1e3
        );
      };
    return { update: h, reset: u, getVelocity: f };
  },
  Oo = function (e, t) {
    return (
      t && !e._gsapAllow && e.preventDefault(),
      e.changedTouches ? e.changedTouches[0] : e
    );
  },
  dp = function (e) {
    var t = Math.max.apply(Math, e),
      n = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(n) ? t : n;
  },
  w_ = function () {
    (ea = on.core.globals().ScrollTrigger), ea && ea.core && Ib();
  },
  R_ = function (e) {
    return (
      (on = e || b_()),
      !wl &&
        on &&
        typeof document < "u" &&
        document.body &&
        ((jn = window),
        (wr = document),
        (Rr = wr.documentElement),
        (Qs = wr.body),
        (T_ = [jn, wr, Rr, Qs]),
        on.utils.clamp,
        (E_ = on.core.context || function () {}),
        (jr = "onpointerenter" in Qs ? "pointer" : "mouse"),
        (S_ = kt.isTouch =
          jn.matchMedia &&
          jn.matchMedia("(hover: none), (pointer: coarse)").matches
            ? 1
            : "ontouchstart" in jn ||
              navigator.maxTouchPoints > 0 ||
              navigator.msMaxTouchPoints > 0
            ? 2
            : 0),
        (pi = kt.eventTypes =
          (
            "ontouchstart" in Rr
              ? "touchstart,touchmove,touchcancel,touchend"
              : "onpointerdown" in Rr
              ? "pointerdown,pointermove,pointercancel,pointerup"
              : "mousedown,mousemove,mouseup,mouseup"
          ).split(",")),
        setTimeout(function () {
          return (A_ = 0);
        }, 500),
        w_(),
        (wl = 1)),
      wl
    );
  };
bn.op = qt;
nt.cache = 0;
var kt = (function () {
  function s(t) {
    this.init(t);
  }
  var e = s.prototype;
  return (
    (e.init = function (n) {
      wl || R_(on) || console.warn("Please gsap.registerPlugin(Observer)"),
        ea || w_();
      var i = n.tolerance,
        r = n.dragMinimum,
        o = n.type,
        a = n.target,
        l = n.lineHeight,
        c = n.debounce,
        h = n.preventDefault,
        u = n.onStop,
        f = n.onStopDelay,
        d = n.ignore,
        _ = n.wheelSpeed,
        g = n.event,
        m = n.onDragStart,
        p = n.onDragEnd,
        M = n.onDrag,
        S = n.onPress,
        v = n.onRelease,
        C = n.onRight,
        w = n.onLeft,
        E = n.onUp,
        A = n.onDown,
        y = n.onChangeX,
        x = n.onChangeY,
        P = n.onChange,
        I = n.onToggleX,
        O = n.onToggleY,
        k = n.onHover,
        G = n.onHoverEnd,
        z = n.onMove,
        q = n.ignoreCheck,
        H = n.isNormalizer,
        ee = n.onGestureStart,
        D = n.onGestureEnd,
        oe = n.onWheel,
        Me = n.onEnable,
        Ue = n.onDisable,
        K = n.onClick,
        te = n.scrollSpeed,
        ge = n.capture,
        ne = n.allowClicks,
        Ee = n.lockAxis,
        we = n.onLockAxis;
      (this.target = a = Pn(a) || Rr),
        (this.vars = n),
        d && (d = on.utils.toArray(d)),
        (i = i || 1e-9),
        (r = r || 0),
        (_ = _ || 1),
        (te = te || 1),
        (o = o || "wheel,touch,pointer"),
        (c = c !== !1),
        l || (l = parseFloat(jn.getComputedStyle(Qs).lineHeight) || 22);
      var Ve,
        Qe,
        Ge,
        Le,
        U,
        Mt,
        Fe,
        V = this,
        be = 0,
        st = 0,
        Re = n.passive || !h,
        R = Nr(a, bn),
        T = Nr(a, qt),
        Y = R(),
        Q = T(),
        J =
          ~o.indexOf("touch") &&
          !~o.indexOf("pointer") &&
          pi[0] === "pointerdown",
        $ = na(a),
        ue = a.ownerDocument || wr,
        le = [0, 0, 0],
        pe = [0, 0, 0],
        Ye = 0,
        ie = function () {
          return (Ye = ta());
        },
        ae = function (Ae, Ke) {
          return (
            ((V.event = Ae) && d && ~d.indexOf(Ae.target)) ||
            (Ke && J && Ae.pointerType !== "touch") ||
            (q && q(Ae, Ke))
          );
        },
        Ne = function () {
          V._vx.reset(), V._vy.reset(), Qe.pause(), u && u(V);
        },
        Ie = function () {
          var Ae = (V.deltaX = dp(le)),
            Ke = (V.deltaY = dp(pe)),
            me = Math.abs(Ae) >= i,
            We = Math.abs(Ke) >= i;
          P && (me || We) && P(V, Ae, Ke, le, pe),
            me &&
              (C && V.deltaX > 0 && C(V),
              w && V.deltaX < 0 && w(V),
              y && y(V),
              I && V.deltaX < 0 != be < 0 && I(V),
              (be = V.deltaX),
              (le[0] = le[1] = le[2] = 0)),
            We &&
              (A && V.deltaY > 0 && A(V),
              E && V.deltaY < 0 && E(V),
              x && x(V),
              O && V.deltaY < 0 != st < 0 && O(V),
              (st = V.deltaY),
              (pe[0] = pe[1] = pe[2] = 0)),
            (Le || Ge) && (z && z(V), Ge && (M(V), (Ge = !1)), (Le = !1)),
            Mt && !(Mt = !1) && we && we(V),
            U && (oe(V), (U = !1)),
            (Ve = 0);
        },
        xe = function (Ae, Ke, me) {
          (le[me] += Ae),
            (pe[me] += Ke),
            V._vx.update(Ae),
            V._vy.update(Ke),
            c ? Ve || (Ve = requestAnimationFrame(Ie)) : Ie();
        },
        je = function (Ae, Ke) {
          Ee &&
            !Fe &&
            ((V.axis = Fe = Math.abs(Ae) > Math.abs(Ke) ? "x" : "y"),
            (Mt = !0)),
            Fe !== "y" && ((le[2] += Ae), V._vx.update(Ae, !0)),
            Fe !== "x" && ((pe[2] += Ke), V._vy.update(Ke, !0)),
            c ? Ve || (Ve = requestAnimationFrame(Ie)) : Ie();
        },
        Oe = function (Ae) {
          if (!ae(Ae, 1)) {
            Ae = Oo(Ae, h);
            var Ke = Ae.clientX,
              me = Ae.clientY,
              We = Ke - V.x,
              Ce = me - V.y,
              ze = V.isDragging;
            (V.x = Ke),
              (V.y = me),
              (ze ||
                Math.abs(V.startX - Ke) >= r ||
                Math.abs(V.startY - me) >= r) &&
                (M && (Ge = !0),
                ze || (V.isDragging = !0),
                je(We, Ce),
                ze || (m && m(V)));
          }
        },
        ct = (V.onPress = function (ve) {
          ae(ve, 1) ||
            (ve && ve.button) ||
            ((V.axis = Fe = null),
            Qe.pause(),
            (V.isPressed = !0),
            (ve = Oo(ve)),
            (be = st = 0),
            (V.startX = V.x = ve.clientX),
            (V.startY = V.y = ve.clientY),
            V._vx.reset(),
            V._vy.reset(),
            vn(H ? a : ue, pi[1], Oe, Re, !0),
            (V.deltaX = V.deltaY = 0),
            S && S(V));
        }),
        L = (V.onRelease = function (ve) {
          if (!ae(ve, 1)) {
            gn(H ? a : ue, pi[1], Oe, !0);
            var Ae = !isNaN(V.y - V.startY),
              Ke = V.isDragging,
              me =
                Ke &&
                (Math.abs(V.x - V.startX) > 3 || Math.abs(V.y - V.startY) > 3),
              We = Oo(ve);
            !me &&
              Ae &&
              (V._vx.reset(),
              V._vy.reset(),
              h &&
                ne &&
                on.delayedCall(0.08, function () {
                  if (ta() - Ye > 300 && !ve.defaultPrevented) {
                    if (ve.target.click) ve.target.click();
                    else if (ue.createEvent) {
                      var Ce = ue.createEvent("MouseEvents");
                      Ce.initMouseEvent(
                        "click",
                        !0,
                        !0,
                        jn,
                        1,
                        We.screenX,
                        We.screenY,
                        We.clientX,
                        We.clientY,
                        !1,
                        !1,
                        !1,
                        !1,
                        0,
                        null
                      ),
                        ve.target.dispatchEvent(Ce);
                    }
                  }
                })),
              (V.isDragging = V.isGesturing = V.isPressed = !1),
              u && Ke && !H && Qe.restart(!0),
              p && Ke && p(V),
              v && v(V, me);
          }
        }),
        he = function (Ae) {
          return (
            Ae.touches &&
            Ae.touches.length > 1 &&
            (V.isGesturing = !0) &&
            ee(Ae, V.isDragging)
          );
        },
        j = function () {
          return (V.isGesturing = !1) || D(V);
        },
        Z = function (Ae) {
          if (!ae(Ae)) {
            var Ke = R(),
              me = T();
            xe((Ke - Y) * te, (me - Q) * te, 1),
              (Y = Ke),
              (Q = me),
              u && Qe.restart(!0);
          }
        },
        ce = function (Ae) {
          if (!ae(Ae)) {
            (Ae = Oo(Ae, h)), oe && (U = !0);
            var Ke =
              (Ae.deltaMode === 1
                ? l
                : Ae.deltaMode === 2
                ? jn.innerHeight
                : 1) * _;
            xe(Ae.deltaX * Ke, Ae.deltaY * Ke, 0), u && !H && Qe.restart(!0);
          }
        },
        fe = function (Ae) {
          if (!ae(Ae)) {
            var Ke = Ae.clientX,
              me = Ae.clientY,
              We = Ke - V.x,
              Ce = me - V.y;
            (V.x = Ke),
              (V.y = me),
              (Le = !0),
              u && Qe.restart(!0),
              (We || Ce) && je(We, Ce);
          }
        },
        Be = function (Ae) {
          (V.event = Ae), k(V);
        },
        ht = function (Ae) {
          (V.event = Ae), G(V);
        },
        Nt = function (Ae) {
          return ae(Ae) || (Oo(Ae, h) && K(V));
        };
      (Qe = V._dc = on.delayedCall(f || 0.25, Ne).pause()),
        (V.deltaX = V.deltaY = 0),
        (V._vx = _u(0, 50, !0)),
        (V._vy = _u(0, 50, !0)),
        (V.scrollX = R),
        (V.scrollY = T),
        (V.isDragging = V.isGesturing = V.isPressed = !1),
        E_(this),
        (V.enable = function (ve) {
          return (
            V.isEnabled ||
              (vn($ ? ue : a, "scroll", mu),
              o.indexOf("scroll") >= 0 && vn($ ? ue : a, "scroll", Z, Re, ge),
              o.indexOf("wheel") >= 0 && vn(a, "wheel", ce, Re, ge),
              ((o.indexOf("touch") >= 0 && S_) || o.indexOf("pointer") >= 0) &&
                (vn(a, pi[0], ct, Re, ge),
                vn(ue, pi[2], L),
                vn(ue, pi[3], L),
                ne && vn(a, "click", ie, !0, !0),
                K && vn(a, "click", Nt),
                ee && vn(ue, "gesturestart", he),
                D && vn(ue, "gestureend", j),
                k && vn(a, jr + "enter", Be),
                G && vn(a, jr + "leave", ht),
                z && vn(a, jr + "move", fe)),
              (V.isEnabled = !0),
              ve && ve.type && ct(ve),
              Me && Me(V)),
            V
          );
        }),
        (V.disable = function () {
          V.isEnabled &&
            (Ws.filter(function (ve) {
              return ve !== V && na(ve.target);
            }).length || gn($ ? ue : a, "scroll", mu),
            V.isPressed &&
              (V._vx.reset(), V._vy.reset(), gn(H ? a : ue, pi[1], Oe, !0)),
            gn($ ? ue : a, "scroll", Z, ge),
            gn(a, "wheel", ce, ge),
            gn(a, pi[0], ct, ge),
            gn(ue, pi[2], L),
            gn(ue, pi[3], L),
            gn(a, "click", ie, !0),
            gn(a, "click", Nt),
            gn(ue, "gesturestart", he),
            gn(ue, "gestureend", j),
            gn(a, jr + "enter", Be),
            gn(a, jr + "leave", ht),
            gn(a, jr + "move", fe),
            (V.isEnabled = V.isPressed = V.isDragging = !1),
            Ue && Ue(V));
        }),
        (V.kill = V.revert =
          function () {
            V.disable();
            var ve = Ws.indexOf(V);
            ve >= 0 && Ws.splice(ve, 1), tr === V && (tr = 0);
          }),
        Ws.push(V),
        H && na(a) && (tr = V),
        V.enable(g);
    }),
    Lb(s, [
      {
        key: "velocityX",
        get: function () {
          return this._vx.getVelocity();
        },
      },
      {
        key: "velocityY",
        get: function () {
          return this._vy.getVelocity();
        },
      },
    ]),
    s
  );
})();
kt.version = "3.12.5";
kt.create = function (s) {
  return new kt(s);
};
kt.register = R_;
kt.getAll = function () {
  return Ws.slice();
};
kt.getById = function (s) {
  return Ws.filter(function (e) {
    return e.vars.id === s;
  })[0];
};
b_() && on.registerPlugin(kt);
/*!
 * ScrollTrigger 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Se,
  Bs,
  ot,
  Dt,
  mi,
  Ct,
  C_,
  ql,
  ya,
  ia,
  Go,
  ol,
  cn,
  oc,
  gu,
  Mn,
  pp,
  mp,
  ks,
  P_,
  th,
  D_,
  yn,
  vu,
  L_,
  I_,
  xr,
  xu,
  hf,
  eo,
  uf,
  jl,
  yu,
  nh,
  al = 1,
  hn = Date.now,
  ih = hn(),
  li = 0,
  Wo = 0,
  _p = function (e, t, n) {
    var i = Xn(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return (n["_" + t + "Clamp"] = i), i ? e.substr(6, e.length - 7) : e;
  },
  gp = function (e, t) {
    return t && (!Xn(e) || e.substr(0, 6) !== "clamp(")
      ? "clamp(" + e + ")"
      : e;
  },
  Ub = function s() {
    return Wo && requestAnimationFrame(s);
  },
  vp = function () {
    return (oc = 1);
  },
  xp = function () {
    return (oc = 0);
  },
  Ei = function (e) {
    return e;
  },
  Xo = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  U_ = function () {
    return typeof window < "u";
  },
  N_ = function () {
    return Se || (U_() && (Se = window.gsap) && Se.registerPlugin && Se);
  },
  fs = function (e) {
    return !!~C_.indexOf(e);
  },
  O_ = function (e) {
    return (
      (e === "Height" ? uf : ot["inner" + e]) ||
      mi["client" + e] ||
      Ct["client" + e]
    );
  },
  F_ = function (e) {
    return (
      Lr(e, "getBoundingClientRect") ||
      (fs(e)
        ? function () {
            return (Ll.width = ot.innerWidth), (Ll.height = uf), Ll;
          }
        : function () {
            return Qi(e);
          })
    );
  },
  Nb = function (e, t, n) {
    var i = n.d,
      r = n.d2,
      o = n.a;
    return (o = Lr(e, "getBoundingClientRect"))
      ? function () {
          return o()[i];
        }
      : function () {
          return (t ? O_(r) : e["client" + r]) || 0;
        };
  },
  Ob = function (e, t) {
    return !t || ~Ui.indexOf(e)
      ? F_(e)
      : function () {
          return Ll;
        };
  },
  Di = function (e, t) {
    var n = t.s,
      i = t.d2,
      r = t.d,
      o = t.a;
    return Math.max(
      0,
      (n = "scroll" + i) && (o = Lr(e, n))
        ? o() - F_(e)()[r]
        : fs(e)
        ? (mi[n] || Ct[n]) - O_(i)
        : e[n] - e["offset" + i]
    );
  },
  ll = function (e, t) {
    for (var n = 0; n < ks.length; n += 3)
      (!t || ~t.indexOf(ks[n + 1])) && e(ks[n], ks[n + 1], ks[n + 2]);
  },
  Xn = function (e) {
    return typeof e == "string";
  },
  An = function (e) {
    return typeof e == "function";
  },
  Yo = function (e) {
    return typeof e == "number";
  },
  Kr = function (e) {
    return typeof e == "object";
  },
  Fo = function (e, t, n) {
    return e && e.progress(t ? 0 : 1) && n && e.pause();
  },
  rh = function (e, t) {
    if (e.enabled) {
      var n = e._ctx
        ? e._ctx.add(function () {
            return t(e);
          })
        : t(e);
      n && n.totalTime && (e.callbackAnimation = n);
    }
  },
  Os = Math.abs,
  B_ = "left",
  k_ = "top",
  ff = "right",
  df = "bottom",
  os = "width",
  as = "height",
  ra = "Right",
  sa = "Left",
  oa = "Top",
  aa = "Bottom",
  Vt = "padding",
  ii = "margin",
  yo = "Width",
  pf = "Height",
  Yt = "px",
  ri = function (e) {
    return ot.getComputedStyle(e);
  },
  Fb = function (e) {
    var t = ri(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
  },
  yp = function (e, t) {
    for (var n in t) n in e || (e[n] = t[n]);
    return e;
  },
  Qi = function (e, t) {
    var n =
        t &&
        ri(e)[gu] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        Se.to(e, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0,
        }).progress(1),
      i = e.getBoundingClientRect();
    return n && n.progress(0).kill(), i;
  },
  Kl = function (e, t) {
    var n = t.d2;
    return e["offset" + n] || e["client" + n] || 0;
  },
  z_ = function (e) {
    var t = [],
      n = e.labels,
      i = e.duration(),
      r;
    for (r in n) t.push(n[r] / i);
    return t;
  },
  Bb = function (e) {
    return function (t) {
      return Se.utils.snap(z_(e), t);
    };
  },
  mf = function (e) {
    var t = Se.utils.snap(e),
      n =
        Array.isArray(e) &&
        e.slice(0).sort(function (i, r) {
          return i - r;
        });
    return n
      ? function (i, r, o) {
          o === void 0 && (o = 0.001);
          var a;
          if (!r) return t(i);
          if (r > 0) {
            for (i -= o, a = 0; a < n.length; a++) if (n[a] >= i) return n[a];
            return n[a - 1];
          } else for (a = n.length, i += o; a--; ) if (n[a] <= i) return n[a];
          return n[0];
        }
      : function (i, r, o) {
          o === void 0 && (o = 0.001);
          var a = t(i);
          return !r || Math.abs(a - i) < o || a - i < 0 == r < 0
            ? a
            : t(r < 0 ? i - e : i + e);
        };
  },
  kb = function (e) {
    return function (t, n) {
      return mf(z_(e))(t, n.direction);
    };
  },
  cl = function (e, t, n, i) {
    return n.split(",").forEach(function (r) {
      return e(t, r, i);
    });
  },
  Jt = function (e, t, n, i, r) {
    return e.addEventListener(t, n, { passive: !i, capture: !!r });
  },
  Zt = function (e, t, n, i) {
    return e.removeEventListener(t, n, !!i);
  },
  hl = function (e, t, n) {
    (n = n && n.wheelHandler), n && (e(t, "wheel", n), e(t, "touchmove", n));
  },
  Mp = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  ul = { toggleActions: "play", anticipatePin: 0 },
  $l = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  Rl = function (e, t) {
    if (Xn(e)) {
      var n = e.indexOf("="),
        i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
      ~n && (e.indexOf("%") > n && (i *= t / 100), (e = e.substr(0, n - 1))),
        (e =
          i +
          (e in $l
            ? $l[e] * t
            : ~e.indexOf("%")
            ? (parseFloat(e) * t) / 100
            : parseFloat(e) || 0));
    }
    return e;
  },
  fl = function (e, t, n, i, r, o, a, l) {
    var c = r.startColor,
      h = r.endColor,
      u = r.fontSize,
      f = r.indent,
      d = r.fontWeight,
      _ = Dt.createElement("div"),
      g = fs(n) || Lr(n, "pinType") === "fixed",
      m = e.indexOf("scroller") !== -1,
      p = g ? Ct : n,
      M = e.indexOf("start") !== -1,
      S = M ? c : h,
      v =
        "border-color:" +
        S +
        ";font-size:" +
        u +
        ";color:" +
        S +
        ";font-weight:" +
        d +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (v += "position:" + ((m || l) && g ? "fixed;" : "absolute;")),
      (m || l || !g) &&
        (v += (i === qt ? ff : df) + ":" + (o + parseFloat(f)) + "px;"),
      a &&
        (v +=
          "box-sizing:border-box;text-align:left;width:" +
          a.offsetWidth +
          "px;"),
      (_._isStart = M),
      _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
      (_.style.cssText = v),
      (_.innerText = t || t === 0 ? e + "-" + t : e),
      p.children[0] ? p.insertBefore(_, p.children[0]) : p.appendChild(_),
      (_._offset = _["offset" + i.op.d2]),
      Cl(_, 0, i, M),
      _
    );
  },
  Cl = function (e, t, n, i) {
    var r = { display: "block" },
      o = n[i ? "os2" : "p2"],
      a = n[i ? "p2" : "os2"];
    (e._isFlipped = i),
      (r[n.a + "Percent"] = i ? -100 : 0),
      (r[n.a] = i ? "1px" : 0),
      (r["border" + o + yo] = 1),
      (r["border" + a + yo] = 0),
      (r[n.p] = t + "px"),
      Se.set(e, r);
  },
  tt = [],
  Mu = {},
  Ma,
  Sp = function () {
    return hn() - li > 34 && (Ma || (Ma = requestAnimationFrame(rr)));
  },
  Fs = function () {
    (!yn || !yn.isPressed || yn.startX > Ct.clientWidth) &&
      (nt.cache++,
      yn ? Ma || (Ma = requestAnimationFrame(rr)) : rr(),
      li || ps("scrollStart"),
      (li = hn()));
  },
  sh = function () {
    (I_ = ot.innerWidth), (L_ = ot.innerHeight);
  },
  qo = function () {
    nt.cache++,
      !cn &&
        !D_ &&
        !Dt.fullscreenElement &&
        !Dt.webkitFullscreenElement &&
        (!vu ||
          I_ !== ot.innerWidth ||
          Math.abs(ot.innerHeight - L_) > ot.innerHeight * 0.25) &&
        ql.restart(!0);
  },
  ds = {},
  zb = [],
  H_ = function s() {
    return Zt(rt, "scrollEnd", s) || es(!0);
  },
  ps = function (e) {
    return (
      (ds[e] &&
        ds[e].map(function (t) {
          return t();
        })) ||
      zb
    );
  },
  Wn = [],
  V_ = function (e) {
    for (var t = 0; t < Wn.length; t += 5)
      (!e || (Wn[t + 4] && Wn[t + 4].query === e)) &&
        ((Wn[t].style.cssText = Wn[t + 1]),
        Wn[t].getBBox && Wn[t].setAttribute("transform", Wn[t + 2] || ""),
        (Wn[t + 3].uncache = 1));
  },
  _f = function (e, t) {
    var n;
    for (Mn = 0; Mn < tt.length; Mn++)
      (n = tt[Mn]),
        n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
    (jl = !0), t && V_(t), t || ps("revert");
  },
  G_ = function (e, t) {
    nt.cache++,
      (t || !Sn) &&
        nt.forEach(function (n) {
          return An(n) && n.cacheID++ && (n.rec = 0);
        }),
      Xn(e) && (ot.history.scrollRestoration = hf = e);
  },
  Sn,
  ls = 0,
  Tp,
  Hb = function () {
    if (Tp !== ls) {
      var e = (Tp = ls);
      requestAnimationFrame(function () {
        return e === ls && es(!0);
      });
    }
  },
  W_ = function () {
    Ct.appendChild(eo),
      (uf = (!yn && eo.offsetHeight) || ot.innerHeight),
      Ct.removeChild(eo);
  },
  Ep = function (e) {
    return ya(
      ".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end"
    ).forEach(function (t) {
      return (t.style.display = e ? "none" : "block");
    });
  },
  es = function (e, t) {
    if (li && !e && !jl) {
      Jt(rt, "scrollEnd", H_);
      return;
    }
    W_(),
      (Sn = rt.isRefreshing = !0),
      nt.forEach(function (i) {
        return An(i) && ++i.cacheID && (i.rec = i());
      });
    var n = ps("refreshInit");
    P_ && rt.sort(),
      t || _f(),
      nt.forEach(function (i) {
        An(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0));
      }),
      tt.slice(0).forEach(function (i) {
        return i.refresh();
      }),
      (jl = !1),
      tt.forEach(function (i) {
        if (i._subPinOffset && i.pin) {
          var r = i.vars.horizontal ? "offsetWidth" : "offsetHeight",
            o = i.pin[r];
          i.revert(!0, 1), i.adjustPinSpacing(i.pin[r] - o), i.refresh();
        }
      }),
      (yu = 1),
      Ep(!0),
      tt.forEach(function (i) {
        var r = Di(i.scroller, i._dir),
          o = i.vars.end === "max" || (i._endClamp && i.end > r),
          a = i._startClamp && i.start >= r;
        (o || a) &&
          i.setPositions(
            a ? r - 1 : i.start,
            o ? Math.max(a ? r : i.start + 1, r) : i.end,
            !0
          );
      }),
      Ep(!1),
      (yu = 0),
      n.forEach(function (i) {
        return i && i.render && i.render(-1);
      }),
      nt.forEach(function (i) {
        An(i) &&
          (i.smooth &&
            requestAnimationFrame(function () {
              return (i.target.style.scrollBehavior = "smooth");
            }),
          i.rec && i(i.rec));
      }),
      G_(hf, 1),
      ql.pause(),
      ls++,
      (Sn = 2),
      rr(2),
      tt.forEach(function (i) {
        return An(i.vars.onRefresh) && i.vars.onRefresh(i);
      }),
      (Sn = rt.isRefreshing = !1),
      ps("refresh");
  },
  Su = 0,
  Pl = 1,
  la,
  rr = function (e) {
    if (e === 2 || (!Sn && !jl)) {
      (rt.isUpdating = !0), la && la.update(0);
      var t = tt.length,
        n = hn(),
        i = n - ih >= 50,
        r = t && tt[0].scroll();
      if (
        ((Pl = Su > r ? -1 : 1),
        Sn || (Su = r),
        i &&
          (li && !oc && n - li > 200 && ((li = 0), ps("scrollEnd")),
          (Go = ih),
          (ih = n)),
        Pl < 0)
      ) {
        for (Mn = t; Mn-- > 0; ) tt[Mn] && tt[Mn].update(0, i);
        Pl = 1;
      } else for (Mn = 0; Mn < t; Mn++) tt[Mn] && tt[Mn].update(0, i);
      rt.isUpdating = !1;
    }
    Ma = 0;
  },
  Tu = [
    B_,
    k_,
    df,
    ff,
    ii + aa,
    ii + ra,
    ii + oa,
    ii + sa,
    "display",
    "flexShrink",
    "float",
    "zIndex",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRowStart",
    "gridRowEnd",
    "gridArea",
    "justifySelf",
    "alignSelf",
    "placeSelf",
    "order",
  ],
  Dl = Tu.concat([
    os,
    as,
    "boxSizing",
    "max" + yo,
    "max" + pf,
    "position",
    ii,
    Vt,
    Vt + oa,
    Vt + ra,
    Vt + aa,
    Vt + sa,
  ]),
  Vb = function (e, t, n) {
    to(n);
    var i = e._gsap;
    if (i.spacerIsNative) to(i.spacerState);
    else if (e._gsap.swappedIn) {
      var r = t.parentNode;
      r && (r.insertBefore(e, t), r.removeChild(t));
    }
    e._gsap.swappedIn = !1;
  },
  oh = function (e, t, n, i) {
    if (!e._gsap.swappedIn) {
      for (var r = Tu.length, o = t.style, a = e.style, l; r--; )
        (l = Tu[r]), (o[l] = n[l]);
      (o.position = n.position === "absolute" ? "absolute" : "relative"),
        n.display === "inline" && (o.display = "inline-block"),
        (a[df] = a[ff] = "auto"),
        (o.flexBasis = n.flexBasis || "auto"),
        (o.overflow = "visible"),
        (o.boxSizing = "border-box"),
        (o[os] = Kl(e, bn) + Yt),
        (o[as] = Kl(e, qt) + Yt),
        (o[Vt] = a[ii] = a[k_] = a[B_] = "0"),
        to(i),
        (a[os] = a["max" + yo] = n[os]),
        (a[as] = a["max" + pf] = n[as]),
        (a[Vt] = n[Vt]),
        e.parentNode !== t &&
          (e.parentNode.insertBefore(t, e), t.appendChild(e)),
        (e._gsap.swappedIn = !0);
    }
  },
  Gb = /([A-Z])/g,
  to = function (e) {
    if (e) {
      var t = e.t.style,
        n = e.length,
        i = 0,
        r,
        o;
      for ((e.t._gsap || Se.core.getCache(e.t)).uncache = 1; i < n; i += 2)
        (o = e[i + 1]),
          (r = e[i]),
          o
            ? (t[r] = o)
            : t[r] && t.removeProperty(r.replace(Gb, "-$1").toLowerCase());
    }
  },
  dl = function (e) {
    for (var t = Dl.length, n = e.style, i = [], r = 0; r < t; r++)
      i.push(Dl[r], n[Dl[r]]);
    return (i.t = e), i;
  },
  Wb = function (e, t, n) {
    for (var i = [], r = e.length, o = n ? 8 : 0, a; o < r; o += 2)
      (a = e[o]), i.push(a, a in t ? t[a] : e[o + 1]);
    return (i.t = e.t), i;
  },
  Ll = { left: 0, top: 0 },
  bp = function (e, t, n, i, r, o, a, l, c, h, u, f, d, _) {
    An(e) && (e = e(l)),
      Xn(e) &&
        e.substr(0, 3) === "max" &&
        (e = f + (e.charAt(4) === "=" ? Rl("0" + e.substr(3), n) : 0));
    var g = d ? d.time() : 0,
      m,
      p,
      M;
    if ((d && d.seek(0), isNaN(e) || (e = +e), Yo(e)))
      d &&
        (e = Se.utils.mapRange(
          d.scrollTrigger.start,
          d.scrollTrigger.end,
          0,
          f,
          e
        )),
        a && Cl(a, n, i, !0);
    else {
      An(t) && (t = t(l));
      var S = (e || "0").split(" "),
        v,
        C,
        w,
        E;
      (M = Pn(t, l) || Ct),
        (v = Qi(M) || {}),
        (!v || (!v.left && !v.top)) &&
          ri(M).display === "none" &&
          ((E = M.style.display),
          (M.style.display = "block"),
          (v = Qi(M)),
          E ? (M.style.display = E) : M.style.removeProperty("display")),
        (C = Rl(S[0], v[i.d])),
        (w = Rl(S[1] || "0", n)),
        (e = v[i.p] - c[i.p] - h + C + r - w),
        a && Cl(a, w, i, n - w < 20 || (a._isStart && w > 20)),
        (n -= n - w);
    }
    if ((_ && ((l[_] = e || -0.001), e < 0 && (e = 0)), o)) {
      var A = e + n,
        y = o._isStart;
      (m = "scroll" + i.d2),
        Cl(
          o,
          A,
          i,
          (y && A > 20) ||
            (!y && (u ? Math.max(Ct[m], mi[m]) : o.parentNode[m]) <= A + 1)
        ),
        u &&
          ((c = Qi(a)),
          u && (o.style[i.op.p] = c[i.op.p] - i.op.m - o._offset + Yt));
    }
    return (
      d &&
        M &&
        ((m = Qi(M)),
        d.seek(f),
        (p = Qi(M)),
        (d._caScrollDist = m[i.p] - p[i.p]),
        (e = (e / d._caScrollDist) * f)),
      d && d.seek(g),
      d ? e : Math.round(e)
    );
  },
  Xb = /(webkit|moz|length|cssText|inset)/i,
  Ap = function (e, t, n, i) {
    if (e.parentNode !== t) {
      var r = e.style,
        o,
        a;
      if (t === Ct) {
        (e._stOrig = r.cssText), (a = ri(e));
        for (o in a)
          !+o &&
            !Xb.test(o) &&
            a[o] &&
            typeof r[o] == "string" &&
            o !== "0" &&
            (r[o] = a[o]);
        (r.top = n), (r.left = i);
      } else r.cssText = e._stOrig;
      (Se.core.getCache(e).uncache = 1), t.appendChild(e);
    }
  },
  X_ = function (e, t, n) {
    var i = t,
      r = i;
    return function (o) {
      var a = Math.round(e());
      return (
        a !== i &&
          a !== r &&
          Math.abs(a - i) > 3 &&
          Math.abs(a - r) > 3 &&
          ((o = a), n && n()),
        (r = i),
        (i = o),
        o
      );
    };
  },
  pl = function (e, t, n) {
    var i = {};
    (i[t.p] = "+=" + n), Se.set(e, i);
  },
  wp = function (e, t) {
    var n = Nr(e, t),
      i = "_scroll" + t.p2,
      r = function o(a, l, c, h, u) {
        var f = o.tween,
          d = l.onComplete,
          _ = {};
        c = c || n();
        var g = X_(n, c, function () {
          f.kill(), (o.tween = 0);
        });
        return (
          (u = (h && u) || 0),
          (h = h || a - c),
          f && f.kill(),
          (l[i] = a),
          (l.inherit = !1),
          (l.modifiers = _),
          (_[i] = function () {
            return g(c + h * f.ratio + u * f.ratio * f.ratio);
          }),
          (l.onUpdate = function () {
            nt.cache++, o.tween && rr();
          }),
          (l.onComplete = function () {
            (o.tween = 0), d && d.call(f);
          }),
          (f = o.tween = Se.to(e, l)),
          f
        );
      };
    return (
      (e[i] = n),
      (n.wheelHandler = function () {
        return r.tween && r.tween.kill() && (r.tween = 0);
      }),
      Jt(e, "wheel", n.wheelHandler),
      rt.isTouch && Jt(e, "touchmove", n.wheelHandler),
      r
    );
  },
  rt = (function () {
    function s(t, n) {
      Bs ||
        s.register(Se) ||
        console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        xu(this),
        this.init(t, n);
    }
    var e = s.prototype;
    return (
      (e.init = function (n, i) {
        if (
          ((this.progress = this.start = 0),
          this.vars && this.kill(!0, !0),
          !Wo)
        ) {
          this.update = this.refresh = this.kill = Ei;
          return;
        }
        n = yp(Xn(n) || Yo(n) || n.nodeType ? { trigger: n } : n, ul);
        var r = n,
          o = r.onUpdate,
          a = r.toggleClass,
          l = r.id,
          c = r.onToggle,
          h = r.onRefresh,
          u = r.scrub,
          f = r.trigger,
          d = r.pin,
          _ = r.pinSpacing,
          g = r.invalidateOnRefresh,
          m = r.anticipatePin,
          p = r.onScrubComplete,
          M = r.onSnapComplete,
          S = r.once,
          v = r.snap,
          C = r.pinReparent,
          w = r.pinSpacer,
          E = r.containerAnimation,
          A = r.fastScrollEnd,
          y = r.preventOverlaps,
          x =
            n.horizontal || (n.containerAnimation && n.horizontal !== !1)
              ? bn
              : qt,
          P = !u && u !== 0,
          I = Pn(n.scroller || ot),
          O = Se.core.getCache(I),
          k = fs(I),
          G =
            ("pinType" in n
              ? n.pinType
              : Lr(I, "pinType") || (k && "fixed")) === "fixed",
          z = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack],
          q = P && n.toggleActions.split(" "),
          H = "markers" in n ? n.markers : ul.markers,
          ee = k ? 0 : parseFloat(ri(I)["border" + x.p2 + yo]) || 0,
          D = this,
          oe =
            n.onRefreshInit &&
            function () {
              return n.onRefreshInit(D);
            },
          Me = Nb(I, k, x),
          Ue = Ob(I, k),
          K = 0,
          te = 0,
          ge = 0,
          ne = Nr(I, x),
          Ee,
          we,
          Ve,
          Qe,
          Ge,
          Le,
          U,
          Mt,
          Fe,
          V,
          be,
          st,
          Re,
          R,
          T,
          Y,
          Q,
          J,
          $,
          ue,
          le,
          pe,
          Ye,
          ie,
          ae,
          Ne,
          Ie,
          xe,
          je,
          Oe,
          ct,
          L,
          he,
          j,
          Z,
          ce,
          fe,
          Be,
          ht;
        if (
          ((D._startClamp = D._endClamp = !1),
          (D._dir = x),
          (m *= 45),
          (D.scroller = I),
          (D.scroll = E ? E.time.bind(E) : ne),
          (Qe = ne()),
          (D.vars = n),
          (i = i || n.animation),
          "refreshPriority" in n &&
            ((P_ = 1), n.refreshPriority === -9999 && (la = D)),
          (O.tweenScroll = O.tweenScroll || {
            top: wp(I, qt),
            left: wp(I, bn),
          }),
          (D.tweenTo = Ee = O.tweenScroll[x.p]),
          (D.scrubDuration = function (me) {
            (he = Yo(me) && me),
              he
                ? L
                  ? L.duration(me)
                  : (L = Se.to(i, {
                      ease: "expo",
                      totalProgress: "+=0",
                      inherit: !1,
                      duration: he,
                      paused: !0,
                      onComplete: function () {
                        return p && p(D);
                      },
                    }))
                : (L && L.progress(1).kill(), (L = 0));
          }),
          i &&
            ((i.vars.lazy = !1),
            (i._initted && !D.isReverted) ||
              (i.vars.immediateRender !== !1 &&
                n.immediateRender !== !1 &&
                i.duration() &&
                i.render(0, !0, !0)),
            (D.animation = i.pause()),
            (i.scrollTrigger = D),
            D.scrubDuration(u),
            (Oe = 0),
            l || (l = i.vars.id)),
          v &&
            ((!Kr(v) || v.push) && (v = { snapTo: v }),
            "scrollBehavior" in Ct.style &&
              Se.set(k ? [Ct, mi] : I, { scrollBehavior: "auto" }),
            nt.forEach(function (me) {
              return (
                An(me) &&
                me.target === (k ? Dt.scrollingElement || mi : I) &&
                (me.smooth = !1)
              );
            }),
            (Ve = An(v.snapTo)
              ? v.snapTo
              : v.snapTo === "labels"
              ? Bb(i)
              : v.snapTo === "labelsDirectional"
              ? kb(i)
              : v.directional !== !1
              ? function (me, We) {
                  return mf(v.snapTo)(me, hn() - te < 500 ? 0 : We.direction);
                }
              : Se.utils.snap(v.snapTo)),
            (j = v.duration || { min: 0.1, max: 2 }),
            (j = Kr(j) ? ia(j.min, j.max) : ia(j, j)),
            (Z = Se.delayedCall(v.delay || he / 2 || 0.1, function () {
              var me = ne(),
                We = hn() - te < 500,
                Ce = Ee.tween;
              if (
                (We || Math.abs(D.getVelocity()) < 10) &&
                !Ce &&
                !oc &&
                K !== me
              ) {
                var ze = (me - Le) / R,
                  Ft = i && !P ? i.totalProgress() : ze,
                  et = We ? 0 : ((Ft - ct) / (hn() - Go)) * 1e3 || 0,
                  bt = Se.utils.clamp(-ze, 1 - ze, (Os(et / 2) * et) / 0.185),
                  Wt = ze + (v.inertia === !1 ? 0 : bt),
                  St,
                  Tt,
                  dt = v,
                  zn = dt.onStart,
                  wt = dt.onInterrupt,
                  mn = dt.onComplete;
                if (
                  ((St = Ve(Wt, D)),
                  Yo(St) || (St = Wt),
                  (Tt = Math.round(Le + St * R)),
                  me <= U && me >= Le && Tt !== me)
                ) {
                  if (Ce && !Ce._initted && Ce.data <= Os(Tt - me)) return;
                  v.inertia === !1 && (bt = St - ze),
                    Ee(
                      Tt,
                      {
                        duration: j(
                          Os(
                            (Math.max(Os(Wt - Ft), Os(St - Ft)) * 0.185) /
                              et /
                              0.05 || 0
                          )
                        ),
                        ease: v.ease || "power3",
                        data: Os(Tt - me),
                        onInterrupt: function () {
                          return Z.restart(!0) && wt && wt(D);
                        },
                        onComplete: function () {
                          D.update(),
                            (K = ne()),
                            i &&
                              (L
                                ? L.resetTo(
                                    "totalProgress",
                                    St,
                                    i._tTime / i._tDur
                                  )
                                : i.progress(St)),
                            (Oe = ct =
                              i && !P ? i.totalProgress() : D.progress),
                            M && M(D),
                            mn && mn(D);
                        },
                      },
                      me,
                      bt * R,
                      Tt - me - bt * R
                    ),
                    zn && zn(D, Ee.tween);
                }
              } else D.isActive && K !== me && Z.restart(!0);
            }).pause())),
          l && (Mu[l] = D),
          (f = D.trigger = Pn(f || (d !== !0 && d))),
          (ht = f && f._gsap && f._gsap.stRevert),
          ht && (ht = ht(D)),
          (d = d === !0 ? f : Pn(d)),
          Xn(a) && (a = { targets: f, className: a }),
          d &&
            (_ === !1 ||
              _ === ii ||
              (_ =
                !_ &&
                d.parentNode &&
                d.parentNode.style &&
                ri(d.parentNode).display === "flex"
                  ? !1
                  : Vt),
            (D.pin = d),
            (we = Se.core.getCache(d)),
            we.spacer
              ? (T = we.pinState)
              : (w &&
                  ((w = Pn(w)),
                  w && !w.nodeType && (w = w.current || w.nativeElement),
                  (we.spacerIsNative = !!w),
                  w && (we.spacerState = dl(w))),
                (we.spacer = J = w || Dt.createElement("div")),
                J.classList.add("pin-spacer"),
                l && J.classList.add("pin-spacer-" + l),
                (we.pinState = T = dl(d))),
            n.force3D !== !1 && Se.set(d, { force3D: !0 }),
            (D.spacer = J = we.spacer),
            (je = ri(d)),
            (ie = je[_ + x.os2]),
            (ue = Se.getProperty(d)),
            (le = Se.quickSetter(d, x.a, Yt)),
            oh(d, J, je),
            (Q = dl(d))),
          H)
        ) {
          (st = Kr(H) ? yp(H, Mp) : Mp),
            (V = fl("scroller-start", l, I, x, st, 0)),
            (be = fl("scroller-end", l, I, x, st, 0, V)),
            ($ = V["offset" + x.op.d2]);
          var Nt = Pn(Lr(I, "content") || I);
          (Mt = this.markerStart = fl("start", l, Nt, x, st, $, 0, E)),
            (Fe = this.markerEnd = fl("end", l, Nt, x, st, $, 0, E)),
            E && (Be = Se.quickSetter([Mt, Fe], x.a, Yt)),
            !G &&
              !(Ui.length && Lr(I, "fixedMarkers") === !0) &&
              (Fb(k ? Ct : I),
              Se.set([V, be], { force3D: !0 }),
              (Ne = Se.quickSetter(V, x.a, Yt)),
              (xe = Se.quickSetter(be, x.a, Yt)));
        }
        if (E) {
          var ve = E.vars.onUpdate,
            Ae = E.vars.onUpdateParams;
          E.eventCallback("onUpdate", function () {
            D.update(0, 0, 1), ve && ve.apply(E, Ae || []);
          });
        }
        if (
          ((D.previous = function () {
            return tt[tt.indexOf(D) - 1];
          }),
          (D.next = function () {
            return tt[tt.indexOf(D) + 1];
          }),
          (D.revert = function (me, We) {
            if (!We) return D.kill(!0);
            var Ce = me !== !1 || !D.enabled,
              ze = cn;
            Ce !== D.isReverted &&
              (Ce &&
                ((ce = Math.max(ne(), D.scroll.rec || 0)),
                (ge = D.progress),
                (fe = i && i.progress())),
              Mt &&
                [Mt, Fe, V, be].forEach(function (Ft) {
                  return (Ft.style.display = Ce ? "none" : "block");
                }),
              Ce && ((cn = D), D.update(Ce)),
              d &&
                (!C || !D.isActive) &&
                (Ce ? Vb(d, J, T) : oh(d, J, ri(d), ae)),
              Ce || D.update(Ce),
              (cn = ze),
              (D.isReverted = Ce));
          }),
          (D.refresh = function (me, We, Ce, ze) {
            if (!((cn || !D.enabled) && !We)) {
              if (d && me && li) {
                Jt(s, "scrollEnd", H_);
                return;
              }
              !Sn && oe && oe(D),
                (cn = D),
                Ee.tween && !Ce && (Ee.tween.kill(), (Ee.tween = 0)),
                L && L.pause(),
                g && i && i.revert({ kill: !1 }).invalidate(),
                D.isReverted || D.revert(!0, !0),
                (D._subPinOffset = !1);
              var Ft = Me(),
                et = Ue(),
                bt = E ? E.duration() : Di(I, x),
                Wt = R <= 0.01,
                St = 0,
                Tt = ze || 0,
                dt = Kr(Ce) ? Ce.end : n.end,
                zn = n.endTrigger || f,
                wt = Kr(Ce)
                  ? Ce.start
                  : n.start || (n.start === 0 || !f ? 0 : d ? "0 0" : "0 100%"),
                mn = (D.pinnedContainer =
                  n.pinnedContainer && Pn(n.pinnedContainer, D)),
                b = (f && Math.max(0, tt.indexOf(D))) || 0,
                N = b,
                W,
                X,
                B,
                re,
                se,
                de,
                ye,
                ke,
                Xe,
                Te,
                qe,
                ut,
                pt;
              for (
                H &&
                Kr(Ce) &&
                ((ut = Se.getProperty(V, x.p)), (pt = Se.getProperty(be, x.p)));
                N--;

              )
                (de = tt[N]),
                  de.end || de.refresh(0, 1) || (cn = D),
                  (ye = de.pin),
                  ye &&
                    (ye === f || ye === d || ye === mn) &&
                    !de.isReverted &&
                    (Te || (Te = []), Te.unshift(de), de.revert(!0, !0)),
                  de !== tt[N] && (b--, N--);
              for (
                An(wt) && (wt = wt(D)),
                  wt = _p(wt, "start", D),
                  Le =
                    bp(
                      wt,
                      f,
                      Ft,
                      x,
                      ne(),
                      Mt,
                      V,
                      D,
                      et,
                      ee,
                      G,
                      bt,
                      E,
                      D._startClamp && "_startClamp"
                    ) || (d ? -0.001 : 0),
                  An(dt) && (dt = dt(D)),
                  Xn(dt) &&
                    !dt.indexOf("+=") &&
                    (~dt.indexOf(" ")
                      ? (dt = (Xn(wt) ? wt.split(" ")[0] : "") + dt)
                      : ((St = Rl(dt.substr(2), Ft)),
                        (dt = Xn(wt)
                          ? wt
                          : (E
                              ? Se.utils.mapRange(
                                  0,
                                  E.duration(),
                                  E.scrollTrigger.start,
                                  E.scrollTrigger.end,
                                  Le
                                )
                              : Le) + St),
                        (zn = f))),
                  dt = _p(dt, "end", D),
                  U =
                    Math.max(
                      Le,
                      bp(
                        dt || (zn ? "100% 0" : bt),
                        zn,
                        Ft,
                        x,
                        ne() + St,
                        Fe,
                        be,
                        D,
                        et,
                        ee,
                        G,
                        bt,
                        E,
                        D._endClamp && "_endClamp"
                      )
                    ) || -0.001,
                  St = 0,
                  N = b;
                N--;

              )
                (de = tt[N]),
                  (ye = de.pin),
                  ye &&
                    de.start - de._pinPush <= Le &&
                    !E &&
                    de.end > 0 &&
                    ((W =
                      de.end -
                      (D._startClamp ? Math.max(0, de.start) : de.start)),
                    ((ye === f && de.start - de._pinPush < Le) || ye === mn) &&
                      isNaN(wt) &&
                      (St += W * (1 - de.progress)),
                    ye === d && (Tt += W));
              if (
                ((Le += St),
                (U += St),
                D._startClamp && (D._startClamp += St),
                D._endClamp &&
                  !Sn &&
                  ((D._endClamp = U || -0.001), (U = Math.min(U, Di(I, x)))),
                (R = U - Le || ((Le -= 0.01) && 0.001)),
                Wt &&
                  (ge = Se.utils.clamp(0, 1, Se.utils.normalize(Le, U, ce))),
                (D._pinPush = Tt),
                Mt &&
                  St &&
                  ((W = {}),
                  (W[x.a] = "+=" + St),
                  mn && (W[x.p] = "-=" + ne()),
                  Se.set([Mt, Fe], W)),
                d && !(yu && D.end >= Di(I, x)))
              )
                (W = ri(d)),
                  (re = x === qt),
                  (B = ne()),
                  (pe = parseFloat(ue(x.a)) + Tt),
                  !bt &&
                    U > 1 &&
                    ((qe = (k ? Dt.scrollingElement || mi : I).style),
                    (qe = {
                      style: qe,
                      value: qe["overflow" + x.a.toUpperCase()],
                    }),
                    k &&
                      ri(Ct)["overflow" + x.a.toUpperCase()] !== "scroll" &&
                      (qe.style["overflow" + x.a.toUpperCase()] = "scroll")),
                  oh(d, J, W),
                  (Q = dl(d)),
                  (X = Qi(d, !0)),
                  (ke = G && Nr(I, re ? bn : qt)()),
                  _
                    ? ((ae = [_ + x.os2, R + Tt + Yt]),
                      (ae.t = J),
                      (N = _ === Vt ? Kl(d, x) + R + Tt : 0),
                      N &&
                        (ae.push(x.d, N + Yt),
                        J.style.flexBasis !== "auto" &&
                          (J.style.flexBasis = N + Yt)),
                      to(ae),
                      mn &&
                        tt.forEach(function (zt) {
                          zt.pin === mn &&
                            zt.vars.pinSpacing !== !1 &&
                            (zt._subPinOffset = !0);
                        }),
                      G && ne(ce))
                    : ((N = Kl(d, x)),
                      N &&
                        J.style.flexBasis !== "auto" &&
                        (J.style.flexBasis = N + Yt)),
                  G &&
                    ((se = {
                      top: X.top + (re ? B - Le : ke) + Yt,
                      left: X.left + (re ? ke : B - Le) + Yt,
                      boxSizing: "border-box",
                      position: "fixed",
                    }),
                    (se[os] = se["max" + yo] = Math.ceil(X.width) + Yt),
                    (se[as] = se["max" + pf] = Math.ceil(X.height) + Yt),
                    (se[ii] =
                      se[ii + oa] =
                      se[ii + ra] =
                      se[ii + aa] =
                      se[ii + sa] =
                        "0"),
                    (se[Vt] = W[Vt]),
                    (se[Vt + oa] = W[Vt + oa]),
                    (se[Vt + ra] = W[Vt + ra]),
                    (se[Vt + aa] = W[Vt + aa]),
                    (se[Vt + sa] = W[Vt + sa]),
                    (Y = Wb(T, se, C)),
                    Sn && ne(0)),
                  i
                    ? ((Xe = i._initted),
                      th(1),
                      i.render(i.duration(), !0, !0),
                      (Ye = ue(x.a) - pe + R + Tt),
                      (Ie = Math.abs(R - Ye) > 1),
                      G && Ie && Y.splice(Y.length - 2, 2),
                      i.render(0, !0, !0),
                      Xe || i.invalidate(!0),
                      i.parent || i.totalTime(i.totalTime()),
                      th(0))
                    : (Ye = R),
                  qe &&
                    (qe.value
                      ? (qe.style["overflow" + x.a.toUpperCase()] = qe.value)
                      : qe.style.removeProperty("overflow-" + x.a));
              else if (f && ne() && !E)
                for (X = f.parentNode; X && X !== Ct; )
                  X._pinOffset && ((Le -= X._pinOffset), (U -= X._pinOffset)),
                    (X = X.parentNode);
              Te &&
                Te.forEach(function (zt) {
                  return zt.revert(!1, !0);
                }),
                (D.start = Le),
                (D.end = U),
                (Qe = Ge = Sn ? ce : ne()),
                !E && !Sn && (Qe < ce && ne(ce), (D.scroll.rec = 0)),
                D.revert(!1, !0),
                (te = hn()),
                Z && ((K = -1), Z.restart(!0)),
                (cn = 0),
                i &&
                  P &&
                  (i._initted || fe) &&
                  i.progress() !== fe &&
                  i.progress(fe || 0, !0).render(i.time(), !0, !0),
                (Wt || ge !== D.progress || E || g) &&
                  (i &&
                    !P &&
                    i.totalProgress(
                      E && Le < -0.001 && !ge
                        ? Se.utils.normalize(Le, U, 0)
                        : ge,
                      !0
                    ),
                  (D.progress = Wt || (Qe - Le) / R === ge ? 0 : ge)),
                d && _ && (J._pinOffset = Math.round(D.progress * Ye)),
                L && L.invalidate(),
                isNaN(ut) ||
                  ((ut -= Se.getProperty(V, x.p)),
                  (pt -= Se.getProperty(be, x.p)),
                  pl(V, x, ut),
                  pl(Mt, x, ut - (ze || 0)),
                  pl(be, x, pt),
                  pl(Fe, x, pt - (ze || 0))),
                Wt && !Sn && D.update(),
                h && !Sn && !Re && ((Re = !0), h(D), (Re = !1));
            }
          }),
          (D.getVelocity = function () {
            return ((ne() - Ge) / (hn() - Go)) * 1e3 || 0;
          }),
          (D.endAnimation = function () {
            Fo(D.callbackAnimation),
              i &&
                (L
                  ? L.progress(1)
                  : i.paused()
                  ? P || Fo(i, D.direction < 0, 1)
                  : Fo(i, i.reversed()));
          }),
          (D.labelToScroll = function (me) {
            return (
              (i &&
                i.labels &&
                (Le || D.refresh() || Le) +
                  (i.labels[me] / i.duration()) * R) ||
              0
            );
          }),
          (D.getTrailing = function (me) {
            var We = tt.indexOf(D),
              Ce =
                D.direction > 0 ? tt.slice(0, We).reverse() : tt.slice(We + 1);
            return (
              Xn(me)
                ? Ce.filter(function (ze) {
                    return ze.vars.preventOverlaps === me;
                  })
                : Ce
            ).filter(function (ze) {
              return D.direction > 0 ? ze.end <= Le : ze.start >= U;
            });
          }),
          (D.update = function (me, We, Ce) {
            if (!(E && !Ce && !me)) {
              var ze = Sn === !0 ? ce : D.scroll(),
                Ft = me ? 0 : (ze - Le) / R,
                et = Ft < 0 ? 0 : Ft > 1 ? 1 : Ft || 0,
                bt = D.progress,
                Wt,
                St,
                Tt,
                dt,
                zn,
                wt,
                mn,
                b;
              if (
                (We &&
                  ((Ge = Qe),
                  (Qe = E ? ne() : ze),
                  v && ((ct = Oe), (Oe = i && !P ? i.totalProgress() : et))),
                m &&
                  d &&
                  !cn &&
                  !al &&
                  li &&
                  (!et && Le < ze + ((ze - Ge) / (hn() - Go)) * m
                    ? (et = 1e-4)
                    : et === 1 &&
                      U > ze + ((ze - Ge) / (hn() - Go)) * m &&
                      (et = 0.9999)),
                et !== bt && D.enabled)
              ) {
                if (
                  ((Wt = D.isActive = !!et && et < 1),
                  (St = !!bt && bt < 1),
                  (wt = Wt !== St),
                  (zn = wt || !!et != !!bt),
                  (D.direction = et > bt ? 1 : -1),
                  (D.progress = et),
                  zn &&
                    !cn &&
                    ((Tt = et && !bt ? 0 : et === 1 ? 1 : bt === 1 ? 2 : 3),
                    P &&
                      ((dt =
                        (!wt && q[Tt + 1] !== "none" && q[Tt + 1]) || q[Tt]),
                      (b =
                        i &&
                        (dt === "complete" || dt === "reset" || dt in i)))),
                  y &&
                    (wt || b) &&
                    (b || u || !i) &&
                    (An(y)
                      ? y(D)
                      : D.getTrailing(y).forEach(function (B) {
                          return B.endAnimation();
                        })),
                  P ||
                    (L && !cn && !al
                      ? (L._dp._time - L._start !== L._time &&
                          L.render(L._dp._time - L._start),
                        L.resetTo
                          ? L.resetTo("totalProgress", et, i._tTime / i._tDur)
                          : ((L.vars.totalProgress = et),
                            L.invalidate().restart()))
                      : i && i.totalProgress(et, !!(cn && (te || me)))),
                  d)
                ) {
                  if ((me && _ && (J.style[_ + x.os2] = ie), !G))
                    le(Xo(pe + Ye * et));
                  else if (zn) {
                    if (
                      ((mn =
                        !me && et > bt && U + 1 > ze && ze + 1 >= Di(I, x)),
                      C)
                    )
                      if (!me && (Wt || mn)) {
                        var N = Qi(d, !0),
                          W = ze - Le;
                        Ap(
                          d,
                          Ct,
                          N.top + (x === qt ? W : 0) + Yt,
                          N.left + (x === qt ? 0 : W) + Yt
                        );
                      } else Ap(d, J);
                    to(Wt || mn ? Y : Q),
                      (Ie && et < 1 && Wt) ||
                        le(pe + (et === 1 && !mn ? Ye : 0));
                  }
                }
                v && !Ee.tween && !cn && !al && Z.restart(!0),
                  a &&
                    (wt || (S && et && (et < 1 || !nh))) &&
                    ya(a.targets).forEach(function (B) {
                      return B.classList[Wt || S ? "add" : "remove"](
                        a.className
                      );
                    }),
                  o && !P && !me && o(D),
                  zn && !cn
                    ? (P &&
                        (b &&
                          (dt === "complete"
                            ? i.pause().totalProgress(1)
                            : dt === "reset"
                            ? i.restart(!0).pause()
                            : dt === "restart"
                            ? i.restart(!0)
                            : i[dt]()),
                        o && o(D)),
                      (wt || !nh) &&
                        (c && wt && rh(D, c),
                        z[Tt] && rh(D, z[Tt]),
                        S && (et === 1 ? D.kill(!1, 1) : (z[Tt] = 0)),
                        wt || ((Tt = et === 1 ? 1 : 3), z[Tt] && rh(D, z[Tt]))),
                      A &&
                        !Wt &&
                        Math.abs(D.getVelocity()) > (Yo(A) ? A : 2500) &&
                        (Fo(D.callbackAnimation),
                        L
                          ? L.progress(1)
                          : Fo(i, dt === "reverse" ? 1 : !et, 1)))
                    : P && o && !cn && o(D);
              }
              if (xe) {
                var X = E ? (ze / E.duration()) * (E._caScrollDist || 0) : ze;
                Ne(X + (V._isFlipped ? 1 : 0)), xe(X);
              }
              Be && Be((-ze / E.duration()) * (E._caScrollDist || 0));
            }
          }),
          (D.enable = function (me, We) {
            D.enabled ||
              ((D.enabled = !0),
              Jt(I, "resize", qo),
              k || Jt(I, "scroll", Fs),
              oe && Jt(s, "refreshInit", oe),
              me !== !1 && ((D.progress = ge = 0), (Qe = Ge = K = ne())),
              We !== !1 && D.refresh());
          }),
          (D.getTween = function (me) {
            return me && Ee ? Ee.tween : L;
          }),
          (D.setPositions = function (me, We, Ce, ze) {
            if (E) {
              var Ft = E.scrollTrigger,
                et = E.duration(),
                bt = Ft.end - Ft.start;
              (me = Ft.start + (bt * me) / et),
                (We = Ft.start + (bt * We) / et);
            }
            D.refresh(
              !1,
              !1,
              {
                start: gp(me, Ce && !!D._startClamp),
                end: gp(We, Ce && !!D._endClamp),
              },
              ze
            ),
              D.update();
          }),
          (D.adjustPinSpacing = function (me) {
            if (ae && me) {
              var We = ae.indexOf(x.d) + 1;
              (ae[We] = parseFloat(ae[We]) + me + Yt),
                (ae[1] = parseFloat(ae[1]) + me + Yt),
                to(ae);
            }
          }),
          (D.disable = function (me, We) {
            if (
              D.enabled &&
              (me !== !1 && D.revert(!0, !0),
              (D.enabled = D.isActive = !1),
              We || (L && L.pause()),
              (ce = 0),
              we && (we.uncache = 1),
              oe && Zt(s, "refreshInit", oe),
              Z && (Z.pause(), Ee.tween && Ee.tween.kill() && (Ee.tween = 0)),
              !k)
            ) {
              for (var Ce = tt.length; Ce--; )
                if (tt[Ce].scroller === I && tt[Ce] !== D) return;
              Zt(I, "resize", qo), k || Zt(I, "scroll", Fs);
            }
          }),
          (D.kill = function (me, We) {
            D.disable(me, We), L && !We && L.kill(), l && delete Mu[l];
            var Ce = tt.indexOf(D);
            Ce >= 0 && tt.splice(Ce, 1),
              Ce === Mn && Pl > 0 && Mn--,
              (Ce = 0),
              tt.forEach(function (ze) {
                return ze.scroller === D.scroller && (Ce = 1);
              }),
              Ce || Sn || (D.scroll.rec = 0),
              i &&
                ((i.scrollTrigger = null),
                me && i.revert({ kill: !1 }),
                We || i.kill()),
              Mt &&
                [Mt, Fe, V, be].forEach(function (ze) {
                  return ze.parentNode && ze.parentNode.removeChild(ze);
                }),
              la === D && (la = 0),
              d &&
                (we && (we.uncache = 1),
                (Ce = 0),
                tt.forEach(function (ze) {
                  return ze.pin === d && Ce++;
                }),
                Ce || (we.spacer = 0)),
              n.onKill && n.onKill(D);
          }),
          tt.push(D),
          D.enable(!1, !1),
          ht && ht(D),
          i && i.add && !R)
        ) {
          var Ke = D.update;
          (D.update = function () {
            (D.update = Ke), Le || U || D.refresh();
          }),
            Se.delayedCall(0.01, D.update),
            (R = 0.01),
            (Le = U = 0);
        } else D.refresh();
        d && Hb();
      }),
      (s.register = function (n) {
        return (
          Bs ||
            ((Se = n || N_()),
            U_() && window.document && s.enable(),
            (Bs = Wo)),
          Bs
        );
      }),
      (s.defaults = function (n) {
        if (n) for (var i in n) ul[i] = n[i];
        return ul;
      }),
      (s.disable = function (n, i) {
        (Wo = 0),
          tt.forEach(function (o) {
            return o[i ? "kill" : "disable"](n);
          }),
          Zt(ot, "wheel", Fs),
          Zt(Dt, "scroll", Fs),
          clearInterval(ol),
          Zt(Dt, "touchcancel", Ei),
          Zt(Ct, "touchstart", Ei),
          cl(Zt, Dt, "pointerdown,touchstart,mousedown", vp),
          cl(Zt, Dt, "pointerup,touchend,mouseup", xp),
          ql.kill(),
          ll(Zt);
        for (var r = 0; r < nt.length; r += 3)
          hl(Zt, nt[r], nt[r + 1]), hl(Zt, nt[r], nt[r + 2]);
      }),
      (s.enable = function () {
        if (
          ((ot = window),
          (Dt = document),
          (mi = Dt.documentElement),
          (Ct = Dt.body),
          Se &&
            ((ya = Se.utils.toArray),
            (ia = Se.utils.clamp),
            (xu = Se.core.context || Ei),
            (th = Se.core.suppressOverwrites || Ei),
            (hf = ot.history.scrollRestoration || "auto"),
            (Su = ot.pageYOffset),
            Se.core.globals("ScrollTrigger", s),
            Ct))
        ) {
          (Wo = 1),
            (eo = document.createElement("div")),
            (eo.style.height = "100vh"),
            (eo.style.position = "absolute"),
            W_(),
            Ub(),
            kt.register(Se),
            (s.isTouch = kt.isTouch),
            (xr =
              kt.isTouch &&
              /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
            (vu = kt.isTouch === 1),
            Jt(ot, "wheel", Fs),
            (C_ = [ot, Dt, mi, Ct]),
            Se.matchMedia
              ? ((s.matchMedia = function (l) {
                  var c = Se.matchMedia(),
                    h;
                  for (h in l) c.add(h, l[h]);
                  return c;
                }),
                Se.addEventListener("matchMediaInit", function () {
                  return _f();
                }),
                Se.addEventListener("matchMediaRevert", function () {
                  return V_();
                }),
                Se.addEventListener("matchMedia", function () {
                  es(0, 1), ps("matchMedia");
                }),
                Se.matchMedia("(orientation: portrait)", function () {
                  return sh(), sh;
                }))
              : console.warn("Requires GSAP 3.11.0 or later"),
            sh(),
            Jt(Dt, "scroll", Fs);
          var n = Ct.style,
            i = n.borderTopStyle,
            r = Se.core.Animation.prototype,
            o,
            a;
          for (
            r.revert ||
              Object.defineProperty(r, "revert", {
                value: function () {
                  return this.time(-0.01, !0);
                },
              }),
              n.borderTopStyle = "solid",
              o = Qi(Ct),
              qt.m = Math.round(o.top + qt.sc()) || 0,
              bn.m = Math.round(o.left + bn.sc()) || 0,
              i ? (n.borderTopStyle = i) : n.removeProperty("border-top-style"),
              ol = setInterval(Sp, 250),
              Se.delayedCall(0.5, function () {
                return (al = 0);
              }),
              Jt(Dt, "touchcancel", Ei),
              Jt(Ct, "touchstart", Ei),
              cl(Jt, Dt, "pointerdown,touchstart,mousedown", vp),
              cl(Jt, Dt, "pointerup,touchend,mouseup", xp),
              gu = Se.utils.checkPrefix("transform"),
              Dl.push(gu),
              Bs = hn(),
              ql = Se.delayedCall(0.2, es).pause(),
              ks = [
                Dt,
                "visibilitychange",
                function () {
                  var l = ot.innerWidth,
                    c = ot.innerHeight;
                  Dt.hidden
                    ? ((pp = l), (mp = c))
                    : (pp !== l || mp !== c) && qo();
                },
                Dt,
                "DOMContentLoaded",
                es,
                ot,
                "load",
                es,
                ot,
                "resize",
                qo,
              ],
              ll(Jt),
              tt.forEach(function (l) {
                return l.enable(0, 1);
              }),
              a = 0;
            a < nt.length;
            a += 3
          )
            hl(Zt, nt[a], nt[a + 1]), hl(Zt, nt[a], nt[a + 2]);
        }
      }),
      (s.config = function (n) {
        "limitCallbacks" in n && (nh = !!n.limitCallbacks);
        var i = n.syncInterval;
        (i && clearInterval(ol)) || ((ol = i) && setInterval(Sp, i)),
          "ignoreMobileResize" in n &&
            (vu = s.isTouch === 1 && n.ignoreMobileResize),
          "autoRefreshEvents" in n &&
            (ll(Zt) || ll(Jt, n.autoRefreshEvents || "none"),
            (D_ = (n.autoRefreshEvents + "").indexOf("resize") === -1));
      }),
      (s.scrollerProxy = function (n, i) {
        var r = Pn(n),
          o = nt.indexOf(r),
          a = fs(r);
        ~o && nt.splice(o, a ? 6 : 2),
          i && (a ? Ui.unshift(ot, i, Ct, i, mi, i) : Ui.unshift(r, i));
      }),
      (s.clearMatchMedia = function (n) {
        tt.forEach(function (i) {
          return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0);
        });
      }),
      (s.isInViewport = function (n, i, r) {
        var o = (Xn(n) ? Pn(n) : n).getBoundingClientRect(),
          a = o[r ? os : as] * i || 0;
        return r
          ? o.right - a > 0 && o.left + a < ot.innerWidth
          : o.bottom - a > 0 && o.top + a < ot.innerHeight;
      }),
      (s.positionInViewport = function (n, i, r) {
        Xn(n) && (n = Pn(n));
        var o = n.getBoundingClientRect(),
          a = o[r ? os : as],
          l =
            i == null
              ? a / 2
              : i in $l
              ? $l[i] * a
              : ~i.indexOf("%")
              ? (parseFloat(i) * a) / 100
              : parseFloat(i) || 0;
        return r ? (o.left + l) / ot.innerWidth : (o.top + l) / ot.innerHeight;
      }),
      (s.killAll = function (n) {
        if (
          (tt.slice(0).forEach(function (r) {
            return r.vars.id !== "ScrollSmoother" && r.kill();
          }),
          n !== !0)
        ) {
          var i = ds.killAll || [];
          (ds = {}),
            i.forEach(function (r) {
              return r();
            });
        }
      }),
      s
    );
  })();
rt.version = "3.12.5";
rt.saveStyles = function (s) {
  return s
    ? ya(s).forEach(function (e) {
        if (e && e.style) {
          var t = Wn.indexOf(e);
          t >= 0 && Wn.splice(t, 5),
            Wn.push(
              e,
              e.style.cssText,
              e.getBBox && e.getAttribute("transform"),
              Se.core.getCache(e),
              xu()
            );
        }
      })
    : Wn;
};
rt.revert = function (s, e) {
  return _f(!s, e);
};
rt.create = function (s, e) {
  return new rt(s, e);
};
rt.refresh = function (s) {
  return s ? qo() : (Bs || rt.register()) && es(!0);
};
rt.update = function (s) {
  return ++nt.cache && rr(s === !0 ? 2 : 0);
};
rt.clearScrollMemory = G_;
rt.maxScroll = function (s, e) {
  return Di(s, e ? bn : qt);
};
rt.getScrollFunc = function (s, e) {
  return Nr(Pn(s), e ? bn : qt);
};
rt.getById = function (s) {
  return Mu[s];
};
rt.getAll = function () {
  return tt.filter(function (s) {
    return s.vars.id !== "ScrollSmoother";
  });
};
rt.isScrolling = function () {
  return !!li;
};
rt.snapDirectional = mf;
rt.addEventListener = function (s, e) {
  var t = ds[s] || (ds[s] = []);
  ~t.indexOf(e) || t.push(e);
};
rt.removeEventListener = function (s, e) {
  var t = ds[s],
    n = t && t.indexOf(e);
  n >= 0 && t.splice(n, 1);
};
rt.batch = function (s, e) {
  var t = [],
    n = {},
    i = e.interval || 0.016,
    r = e.batchMax || 1e9,
    o = function (c, h) {
      var u = [],
        f = [],
        d = Se.delayedCall(i, function () {
          h(u, f), (u = []), (f = []);
        }).pause();
      return function (_) {
        u.length || d.restart(!0),
          u.push(_.trigger),
          f.push(_),
          r <= u.length && d.progress(1);
      };
    },
    a;
  for (a in e)
    n[a] =
      a.substr(0, 2) === "on" && An(e[a]) && a !== "onRefreshInit"
        ? o(a, e[a])
        : e[a];
  return (
    An(r) &&
      ((r = r()),
      Jt(rt, "refresh", function () {
        return (r = e.batchMax());
      })),
    ya(s).forEach(function (l) {
      var c = {};
      for (a in n) c[a] = n[a];
      (c.trigger = l), t.push(rt.create(c));
    }),
    t
  );
};
var Rp = function (e, t, n, i) {
    return (
      t > i ? e(i) : t < 0 && e(0),
      n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
    );
  },
  ah = function s(e, t) {
    t === !0
      ? e.style.removeProperty("touch-action")
      : (e.style.touchAction =
          t === !0
            ? "auto"
            : t
            ? "pan-" + t + (kt.isTouch ? " pinch-zoom" : "")
            : "none"),
      e === mi && s(Ct, t);
  },
  ml = { auto: 1, scroll: 1 },
  Yb = function (e) {
    var t = e.event,
      n = e.target,
      i = e.axis,
      r = (t.changedTouches ? t.changedTouches[0] : t).target,
      o = r._gsap || Se.core.getCache(r),
      a = hn(),
      l;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
      for (
        ;
        r &&
        r !== Ct &&
        ((r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth) ||
          !(ml[(l = ri(r)).overflowY] || ml[l.overflowX]));

      )
        r = r.parentNode;
      (o._isScroll =
        r &&
        r !== n &&
        !fs(r) &&
        (ml[(l = ri(r)).overflowY] || ml[l.overflowX])),
        (o._isScrollT = a);
    }
    (o._isScroll || i === "x") && (t.stopPropagation(), (t._gsapAllow = !0));
  },
  Y_ = function (e, t, n, i) {
    return kt.create({
      target: e,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: t,
      onWheel: (i = i && Yb),
      onPress: i,
      onDrag: i,
      onScroll: i,
      onEnable: function () {
        return n && Jt(Dt, kt.eventTypes[0], Pp, !1, !0);
      },
      onDisable: function () {
        return Zt(Dt, kt.eventTypes[0], Pp, !0);
      },
    });
  },
  qb = /(input|label|select|textarea)/i,
  Cp,
  Pp = function (e) {
    var t = qb.test(e.target.tagName);
    (t || Cp) && ((e._gsapAllow = !0), (Cp = t));
  },
  jb = function (e) {
    Kr(e) || (e = {}),
      (e.preventDefault = e.isNormalizer = e.allowClicks = !0),
      e.type || (e.type = "wheel,touch"),
      (e.debounce = !!e.debounce),
      (e.id = e.id || "normalizer");
    var t = e,
      n = t.normalizeScrollX,
      i = t.momentum,
      r = t.allowNestedScroll,
      o = t.onRelease,
      a,
      l,
      c = Pn(e.target) || mi,
      h = Se.core.globals().ScrollSmoother,
      u = h && h.get(),
      f =
        xr &&
        ((e.content && Pn(e.content)) ||
          (u && e.content !== !1 && !u.smooth() && u.content())),
      d = Nr(c, qt),
      _ = Nr(c, bn),
      g = 1,
      m =
        (kt.isTouch && ot.visualViewport
          ? ot.visualViewport.scale * ot.visualViewport.width
          : ot.outerWidth) / ot.innerWidth,
      p = 0,
      M = An(i)
        ? function () {
            return i(a);
          }
        : function () {
            return i || 2.8;
          },
      S,
      v,
      C = Y_(c, e.type, !0, r),
      w = function () {
        return (v = !1);
      },
      E = Ei,
      A = Ei,
      y = function () {
        (l = Di(c, qt)),
          (A = ia(xr ? 1 : 0, l)),
          n && (E = ia(0, Di(c, bn))),
          (S = ls);
      },
      x = function () {
        (f._gsap.y = Xo(parseFloat(f._gsap.y) + d.offset) + "px"),
          (f.style.transform =
            "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
            parseFloat(f._gsap.y) +
            ", 0, 1)"),
          (d.offset = d.cacheID = 0);
      },
      P = function () {
        if (v) {
          requestAnimationFrame(w);
          var H = Xo(a.deltaY / 2),
            ee = A(d.v - H);
          if (f && ee !== d.v + d.offset) {
            d.offset = ee - d.v;
            var D = Xo((parseFloat(f && f._gsap.y) || 0) - d.offset);
            (f.style.transform =
              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
              D +
              ", 0, 1)"),
              (f._gsap.y = D + "px"),
              (d.cacheID = nt.cache),
              rr();
          }
          return !0;
        }
        d.offset && x(), (v = !0);
      },
      I,
      O,
      k,
      G,
      z = function () {
        y(),
          I.isActive() &&
            I.vars.scrollY > l &&
            (d() > l ? I.progress(1) && d(l) : I.resetTo("scrollY", l));
      };
    return (
      f && Se.set(f, { y: "+=0" }),
      (e.ignoreCheck = function (q) {
        return (
          (xr && q.type === "touchmove" && P()) ||
          (g > 1.05 && q.type !== "touchstart") ||
          a.isGesturing ||
          (q.touches && q.touches.length > 1)
        );
      }),
      (e.onPress = function () {
        v = !1;
        var q = g;
        (g = Xo(((ot.visualViewport && ot.visualViewport.scale) || 1) / m)),
          I.pause(),
          q !== g && ah(c, g > 1.01 ? !0 : n ? !1 : "x"),
          (O = _()),
          (k = d()),
          y(),
          (S = ls);
      }),
      (e.onRelease = e.onGestureStart =
        function (q, H) {
          if ((d.offset && x(), !H)) G.restart(!0);
          else {
            nt.cache++;
            var ee = M(),
              D,
              oe;
            n &&
              ((D = _()),
              (oe = D + (ee * 0.05 * -q.velocityX) / 0.227),
              (ee *= Rp(_, D, oe, Di(c, bn))),
              (I.vars.scrollX = E(oe))),
              (D = d()),
              (oe = D + (ee * 0.05 * -q.velocityY) / 0.227),
              (ee *= Rp(d, D, oe, Di(c, qt))),
              (I.vars.scrollY = A(oe)),
              I.invalidate().duration(ee).play(0.01),
              ((xr && I.vars.scrollY >= l) || D >= l - 1) &&
                Se.to({}, { onUpdate: z, duration: ee });
          }
          o && o(q);
        }),
      (e.onWheel = function () {
        I._ts && I.pause(), hn() - p > 1e3 && ((S = 0), (p = hn()));
      }),
      (e.onChange = function (q, H, ee, D, oe) {
        if (
          (ls !== S && y(),
          H && n && _(E(D[2] === H ? O + (q.startX - q.x) : _() + H - D[1])),
          ee)
        ) {
          d.offset && x();
          var Me = oe[2] === ee,
            Ue = Me ? k + q.startY - q.y : d() + ee - oe[1],
            K = A(Ue);
          Me && Ue !== K && (k += K - Ue), d(K);
        }
        (ee || H) && rr();
      }),
      (e.onEnable = function () {
        ah(c, n ? !1 : "x"),
          rt.addEventListener("refresh", z),
          Jt(ot, "resize", z),
          d.smooth &&
            ((d.target.style.scrollBehavior = "auto"),
            (d.smooth = _.smooth = !1)),
          C.enable();
      }),
      (e.onDisable = function () {
        ah(c, !0),
          Zt(ot, "resize", z),
          rt.removeEventListener("refresh", z),
          C.kill();
      }),
      (e.lockAxis = e.lockAxis !== !1),
      (a = new kt(e)),
      (a.iOS = xr),
      xr && !d() && d(1),
      xr && Se.ticker.add(Ei),
      (G = a._dc),
      (I = Se.to(a, {
        ease: "power4",
        paused: !0,
        inherit: !1,
        scrollX: n ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
          scrollY: X_(d, d(), function () {
            return I.pause();
          }),
        },
        onUpdate: rr,
        onComplete: G.vars.onComplete,
      })),
      a
    );
  };
rt.sort = function (s) {
  return tt.sort(
    s ||
      function (e, t) {
        return (
          (e.vars.refreshPriority || 0) * -1e6 +
          e.start -
          (t.start + (t.vars.refreshPriority || 0) * -1e6)
        );
      }
  );
};
rt.observe = function (s) {
  return new kt(s);
};
rt.normalizeScroll = function (s) {
  if (typeof s > "u") return yn;
  if (s === !0 && yn) return yn.enable();
  if (s === !1) {
    yn && yn.kill(), (yn = s);
    return;
  }
  var e = s instanceof kt ? s : jb(s);
  return yn && yn.target === e.target && yn.kill(), fs(e.target) && (yn = e), e;
};
rt.core = {
  _getVelocityProp: _u,
  _inputObserver: Y_,
  _scrollers: nt,
  _proxies: Ui,
  bridge: {
    ss: function () {
      li || ps("scrollStart"), (li = hn());
    },
    ref: function () {
      return cn;
    },
  },
};
N_() && Se.registerPlugin(rt);
ss.registerPlugin(rt);
let _l = ss.timeline();
new Pb();
const Kb = document.querySelector(".canvas"),
  ac = new pS(),
  Sa = new Tn(75, window.innerWidth / window.innerHeight, 0.1, 100),
  $b = new XS(16777215, 1);
ac.add($b);
const Zb = new QT();
Zb.load(
  "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/4k/snowy_forest_path_01_4k.hdr",
  function (s) {
    (s.mapping = Il), (ac.environment = s);
  }
);
let Eu;
const Jb = new vT();
Jb.load(
  "./gla.glb",
  function (s) {
    (Eu = s.scene), ac.add(Eu);
  },
  function (s) {
    console.log((s.loaded / s.total) * 100 + "% loaded");
  },
  function (s) {
    console.error("An error occurred:", s);
  }
);
Sa.position.z = 0.6;
const vs = new dS({ canvas: Kb });
vs.toneMapping = Ip;
vs.toneMappingExposure = 1;
vs.outputEncoding = void 0;
vs.setSize(window.innerWidth, window.innerHeight);
const lc = new sE(vs),
  Qb = new oE(ac, Sa);
lc.addPass(Qb);
const eA = new po(
  new De(window.innerWidth, window.innerHeight),
  1.5,
  0.4,
  0.85
);
lc.addPass(eA);
const q_ = new sT(Sa, vs.domElement);
q_.enableDamping = !0;
window.addEventListener("resize", () => {
  vs.setSize(window.innerWidth, window.innerHeight),
    lc.setSize(window.innerWidth, window.innerHeight),
    (Sa.aspect = window.innerWidth / window.innerHeight),
    Sa.updateProjectionMatrix();
});
function tA() {
  const s = document.querySelector(".nav-icon"),
    e = document.querySelector(".close");
  s.addEventListener("click", () => {
    _l.to(".nav-div", { height: "100vh", duration: 0.5 }),
      _l.to(".items-list", {
        duration: 1,
        translateY: 0,
        opacity: 1,
        stagger: 0.7,
        ease: "expo.inOut",
      });
  }),
    e.addEventListener("click", () => {
      _l.to(".items-list", {
        duration: 0.3,
        translateY: "1.5rem",
        opacity: 0,
        stagger: 0.7,
        ease: "expo.inOut",
      }),
        _l.to(".nav-div", { height: "0vh", duration: 2 });
    }),
    ss.to(e, {
      rotate: "360deg",
      duration: 6,
      ease: "elastic.inOut",
      repeat: -1,
    });
}
tA();
function nA() {
  ss.to(".footer ", {
    scrollTrigger: {
      trigger: ".main-footer",
      start: "top 20%",
      end: "bottom 80%",
      scrub: 1,
      toggleActions: "play pause reverse reset",
    },
    height: "264px",
    translateY: 0,
    duration: 1,
    opacity: 1,
    ease: "power2.out",
  }),
    ss.from(".developed span", {
      scrollTrigger: {
        trigger: ".main-footer",
        start: "top top",
        end: "bottom bottom",
        scrub: 5,
        toggleActions: "play pause reverse reset",
      },
      duration: 1,
      y: 500,
      opacity: 0,
      stagger: 2,
      ease: "power2.out",
    }),
    ss.to(" .bluurr", {
      scrollTrigger: {
        trigger: ".main-footer",
        start: "top top",
        end: "bottom bottom",
        scrub: 5,
        toggleActions: "play pause reverse reset",
      },
      duration: 2,
      height: "200px",
      width: "200px",
      ease: "power2.out",
    });
}
nA();
function j_() {
  window.requestAnimationFrame(j_),
    lc.render(),
    (Eu.rotation.y -= 0.01),
    q_.update();
}
j_();
